(self["webpackChunkcofounder_theia_app"] = self["webpackChunkcofounder_theia_app"] || []).push([["vendors-node_modules_theia_plugin-ext_lib_plugin-ext-frontend-module_js"],{

/***/ "../../node_modules/@theia/ai-mcp/lib/common/index.js"
/*!************************************************************!*\
  !*** ../../node_modules/@theia/ai-mcp/lib/common/index.js ***!
  \************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
// *****************************************************************************
// Copyright (C) 2024 EclipseSource GmbH.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
tslib_1.__exportStar(__webpack_require__(/*! ./mcp-server-manager */ "../../node_modules/@theia/ai-mcp/lib/common/mcp-server-manager.js"), exports);


/***/ },

/***/ "../../node_modules/@theia/ai-mcp/lib/common/mcp-server-manager.js"
/*!*************************************************************************!*\
  !*** ../../node_modules/@theia/ai-mcp/lib/common/mcp-server-manager.js ***!
  \*************************************************************************/
(__unused_webpack_module, exports) {

"use strict";

// *****************************************************************************
// Copyright (C) 2024 EclipseSource GmbH.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MCPServerManagerPath = exports.MCPServerManager = exports.isRemoteMCPServerDescription = exports.isLocalMCPServerDescription = exports.MCPServerStatus = exports.MCPFrontendNotificationService = exports.MCPFrontendService = void 0;
exports.MCPFrontendService = Symbol('MCPFrontendService');
exports.MCPFrontendNotificationService = Symbol('MCPFrontendNotificationService');
var MCPServerStatus;
(function (MCPServerStatus) {
    MCPServerStatus["NotRunning"] = "Not Running";
    MCPServerStatus["NotConnected"] = "Not Connected";
    MCPServerStatus["Starting"] = "Starting";
    MCPServerStatus["Connecting"] = "Connecting";
    MCPServerStatus["Running"] = "Running";
    MCPServerStatus["Connected"] = "Connected";
    MCPServerStatus["Errored"] = "Errored";
})(MCPServerStatus || (exports.MCPServerStatus = MCPServerStatus = {}));
function isLocalMCPServerDescription(description) {
    return description.command !== undefined;
}
exports.isLocalMCPServerDescription = isLocalMCPServerDescription;
function isRemoteMCPServerDescription(description) {
    return description.serverUrl !== undefined;
}
exports.isRemoteMCPServerDescription = isRemoteMCPServerDescription;
exports.MCPServerManager = Symbol('MCPServerManager');
exports.MCPServerManagerPath = '/services/mcpservermanager';


/***/ },

/***/ "../../node_modules/@theia/callhierarchy/lib/browser/index.js"
/*!********************************************************************!*\
  !*** ../../node_modules/@theia/callhierarchy/lib/browser/index.js ***!
  \********************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
tslib_1.__exportStar(__webpack_require__(/*! ./callhierarchy */ "../../node_modules/@theia/callhierarchy/lib/browser/callhierarchy.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./callhierarchy-contribution */ "../../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-contribution.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./callhierarchy-frontend-module */ "../../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-frontend-module.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./callhierarchy-service */ "../../node_modules/@theia/callhierarchy/lib/browser/callhierarchy-service.js"), exports);


/***/ },

/***/ "../../node_modules/@theia/core/shared/@theia/request/index.js"
/*!*********************************************************************!*\
  !*** ../../node_modules/@theia/core/shared/@theia/request/index.js ***!
  \*********************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(/*! @theia/request */ "../../node_modules/@theia/request/lib/index.js");


/***/ },

/***/ "../../node_modules/@theia/editor-preview/lib/browser/editor-preview-widget.js"
/*!*************************************************************************************!*\
  !*** ../../node_modules/@theia/editor-preview/lib/browser/editor-preview-widget.js ***!
  \*************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EditorPreviewWidget = void 0;
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "../../node_modules/@theia/editor/lib/browser/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../../node_modules/@theia/core/lib/common/index.js");
const PREVIEW_TITLE_CLASS = 'theia-editor-preview-title-unpinned';
class EditorPreviewWidget extends browser_2.EditorWidget {
    get isPreview() {
        return this._isPreview;
    }
    constructor(editor, selectionService) {
        super(editor, selectionService);
        this._isPreview = false;
        this.onDidChangePreviewStateEmitter = new common_1.Emitter();
        this.onDidChangePreviewState = this.onDidChangePreviewStateEmitter.event;
        this.toDispose.push(this.onDidChangePreviewStateEmitter);
    }
    initializePreview() {
        const oneTimeListeners = new common_1.DisposableCollection();
        this._isPreview = true;
        this.title.className += ` ${PREVIEW_TITLE_CLASS}`;
        const oneTimeDirtyChangeListener = this.saveable.onDirtyChanged(() => {
            this.convertToNonPreview();
            oneTimeListeners.dispose();
        });
        oneTimeListeners.push(oneTimeDirtyChangeListener);
        const oneTimeTitleChangeHandler = () => {
            if (this.title.className.includes(browser_1.PINNED_CLASS)) {
                this.convertToNonPreview();
                oneTimeListeners.dispose();
            }
        };
        this.title.changed.connect(oneTimeTitleChangeHandler);
        oneTimeListeners.push(common_1.Disposable.create(() => this.title.changed.disconnect(oneTimeTitleChangeHandler)));
        this.toDispose.push(oneTimeListeners);
    }
    convertToNonPreview() {
        if (this._isPreview) {
            this._isPreview = false;
            this.currentTabbar = undefined;
            this.title.className = this.title.className.replace(PREVIEW_TITLE_CLASS, '');
            this.onDidChangePreviewStateEmitter.fire();
            this.onDidChangePreviewStateEmitter.dispose();
        }
    }
    handleTabBarChange(oldTabBar, newTabBar) {
        super.handleTabBarChange(oldTabBar, newTabBar);
        if (this._isPreview) {
            if (oldTabBar && newTabBar) {
                this.convertToNonPreview();
            }
        }
    }
    storeState() {
        var _a;
        if (((_a = this.getResourceUri()) === null || _a === void 0 ? void 0 : _a.scheme) !== common_1.UNTITLED_SCHEME) {
            const { _isPreview: isPreview } = this;
            return { isPreview, editorState: this.editor.storeViewState() };
        }
    }
    restoreState(oldState) {
        if (!oldState.isPreview) {
            this.convertToNonPreview();
        }
        this.editor.restoreViewState(oldState.editorState);
    }
}
exports.EditorPreviewWidget = EditorPreviewWidget;


/***/ },

/***/ "../../node_modules/@theia/monaco/lib/browser/textmate/index.js"
/*!**********************************************************************!*\
  !*** ../../node_modules/@theia/monaco/lib/browser/textmate/index.js ***!
  \**********************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
tslib_1.__exportStar(__webpack_require__(/*! ./textmate-registry */ "../../node_modules/@theia/monaco/lib/browser/textmate/textmate-registry.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./textmate-contribution */ "../../node_modules/@theia/monaco/lib/browser/textmate/textmate-contribution.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./monaco-textmate-service */ "../../node_modules/@theia/monaco/lib/browser/textmate/monaco-textmate-service.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./monaco-textmate-frontend-bindings */ "../../node_modules/@theia/monaco/lib/browser/textmate/monaco-textmate-frontend-bindings.js"), exports);


/***/ },

/***/ "../../node_modules/@theia/notebook/lib/browser/index.js"
/*!***************************************************************!*\
  !*** ../../node_modules/@theia/notebook/lib/browser/index.js ***!
  \***************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
tslib_1.__exportStar(__webpack_require__(/*! ./notebook-type-registry */ "../../node_modules/@theia/notebook/lib/browser/notebook-type-registry.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./notebook-renderer-registry */ "../../node_modules/@theia/notebook/lib/browser/notebook-renderer-registry.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./notebook-editor-widget */ "../../node_modules/@theia/notebook/lib/browser/notebook-editor-widget.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./service/notebook-service */ "../../node_modules/@theia/notebook/lib/browser/service/notebook-service.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./service/notebook-editor-widget-service */ "../../node_modules/@theia/notebook/lib/browser/service/notebook-editor-widget-service.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./service/notebook-kernel-service */ "../../node_modules/@theia/notebook/lib/browser/service/notebook-kernel-service.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./service/notebook-execution-state-service */ "../../node_modules/@theia/notebook/lib/browser/service/notebook-execution-state-service.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./service/notebook-model-resolver-service */ "../../node_modules/@theia/notebook/lib/browser/service/notebook-model-resolver-service.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./service/notebook-renderer-messaging-service */ "../../node_modules/@theia/notebook/lib/browser/service/notebook-renderer-messaging-service.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./service/notebook-cell-editor-service */ "../../node_modules/@theia/notebook/lib/browser/service/notebook-cell-editor-service.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./renderers/cell-output-webview */ "../../node_modules/@theia/notebook/lib/browser/renderers/cell-output-webview.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./notebook-types */ "../../node_modules/@theia/notebook/lib/browser/notebook-types.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./notebook-editor-split-contribution */ "../../node_modules/@theia/notebook/lib/browser/notebook-editor-split-contribution.js"), exports);


/***/ },

/***/ "../../node_modules/@theia/notebook/lib/browser/notebook-types.js"
/*!************************************************************************!*\
  !*** ../../node_modules/@theia/notebook/lib/browser/notebook-types.js ***!
  \************************************************************************/
(__unused_webpack_module, exports) {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionStateType = void 0;
;
;
var SelectionStateType;
(function (SelectionStateType) {
    SelectionStateType[SelectionStateType["Handle"] = 0] = "Handle";
    SelectionStateType[SelectionStateType["Index"] = 1] = "Index";
})(SelectionStateType || (exports.SelectionStateType = SelectionStateType = {}));
;
;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/common/language-pack-service.js"
/*!********************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/common/language-pack-service.js ***!
  \********************************************************************************/
(__unused_webpack_module, exports) {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LanguagePackService = exports.languagePackServicePath = void 0;
exports.languagePackServicePath = '/services/languagePackService';
exports.LanguagePackService = Symbol('LanguagePackService');


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin-watcher.js"
/*!****************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin-watcher.js ***!
  \****************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HostedPluginWatcher = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../node_modules/@theia/core/lib/common/event.js");
let HostedPluginWatcher = class HostedPluginWatcher {
    constructor() {
        this.onPostMessage = new event_1.Emitter();
        this.onLogMessage = new event_1.Emitter();
        this.onDidDeployEmitter = new event_1.Emitter();
        this.onDidDeploy = this.onDidDeployEmitter.event;
    }
    getHostedPluginClient() {
        const messageEmitter = this.onPostMessage;
        const logEmitter = this.onLogMessage;
        return {
            postMessage(pluginHostId, message) {
                messageEmitter.fire({ pluginHostId, message });
                return Promise.resolve();
            },
            log(logPart) {
                logEmitter.fire(logPart);
                return Promise.resolve();
            },
            onDidDeploy: () => this.onDidDeployEmitter.fire(undefined)
        };
    }
    get onPostMessageEvent() {
        return this.onPostMessage.event;
    }
    get onLogMessageEvent() {
        return this.onLogMessage.event;
    }
};
exports.HostedPluginWatcher = HostedPluginWatcher;
exports.HostedPluginWatcher = HostedPluginWatcher = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], HostedPluginWatcher);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin.js"
/*!********************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin.js ***!
  \********************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/da5fb7d5b865aa522abc7e82c10b746834b98639/src/vs/workbench/api/node/extHostExtensionService.ts
var HostedPluginSupport_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HostedPluginSupport = exports.PluginProgressLocation = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
/* eslint-disable @typescript-eslint/no-explicit-any */
const uuid_1 = __webpack_require__(/*! @theia/core/lib/common/uuid */ "../../node_modules/@theia/core/lib/common/uuid.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const plugin_worker_1 = __webpack_require__(/*! ./plugin-worker */ "../../node_modules/@theia/plugin-ext/lib/hosted/browser/plugin-worker.js");
const plugin_protocol_1 = __webpack_require__(/*! ../../common/plugin-protocol */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-protocol.js");
const hosted_plugin_watcher_1 = __webpack_require__(/*! ./hosted-plugin-watcher */ "../../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin-watcher.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const main_context_1 = __webpack_require__(/*! ../../main/browser/main-context */ "../../node_modules/@theia/plugin-ext/lib/main/browser/main-context.js");
const rpc_protocol_1 = __webpack_require__(/*! ../../common/rpc-protocol */ "../../node_modules/@theia/plugin-ext/lib/common/rpc-protocol.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const preferences_1 = __webpack_require__(/*! @theia/core/lib/common/preferences */ "../../node_modules/@theia/core/lib/common/preferences/index.js");
const browser_1 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../../node_modules/@theia/workspace/lib/browser/index.js");
const plugin_contribution_handler_1 = __webpack_require__(/*! ../../main/browser/plugin-contribution-handler */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-contribution-handler.js");
const env_main_1 = __webpack_require__(/*! ../../main/browser/env-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/env-main.js");
const preference_registry_main_1 = __webpack_require__(/*! ../../main/browser/preference-registry-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/preference-registry-main.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../../node_modules/@theia/core/lib/common/promise-util.js");
const debug_session_manager_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-session-manager */ "../../node_modules/@theia/debug/lib/browser/debug-session-manager.js");
const debug_configuration_manager_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-configuration-manager */ "../../node_modules/@theia/debug/lib/browser/debug-configuration-manager.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../node_modules/@theia/core/lib/common/event.js");
const file_search_service_1 = __webpack_require__(/*! @theia/file-search/lib/common/file-search-service */ "../../node_modules/@theia/file-search/lib/common/file-search-service.js");
const frontend_application_state_1 = __webpack_require__(/*! @theia/core/lib/browser/frontend-application-state */ "../../node_modules/@theia/core/lib/browser/frontend-application-state.js");
const plugin_view_registry_1 = __webpack_require__(/*! ../../main/browser/view/plugin-view-registry */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-registry.js");
const task_contribution_1 = __webpack_require__(/*! @theia/task/lib/browser/task-contribution */ "../../node_modules/@theia/task/lib/browser/task-contribution.js");
const task_definition_registry_1 = __webpack_require__(/*! @theia/task/lib/browser/task-definition-registry */ "../../node_modules/@theia/task/lib/browser/task-definition-registry.js");
const webview_environment_1 = __webpack_require__(/*! ../../main/browser/webview/webview-environment */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-environment.js");
const webview_1 = __webpack_require__(/*! ../../main/browser/webview/webview */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview.js");
const widget_manager_1 = __webpack_require__(/*! @theia/core/lib/browser/widget-manager */ "../../node_modules/@theia/core/lib/browser/widget-manager.js");
const terminal_service_1 = __webpack_require__(/*! @theia/terminal/lib/browser/base/terminal-service */ "../../node_modules/@theia/terminal/lib/browser/base/terminal-service.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../../node_modules/@theia/core/lib/common/uri.js");
const frontend_application_config_provider_1 = __webpack_require__(/*! @theia/core/lib/browser/frontend-application-config-provider */ "../../node_modules/@theia/core/lib/browser/frontend-application-config-provider.js");
const environment_1 = __webpack_require__(/*! @theia/core/shared/@theia/application-package/lib/environment */ "../../node_modules/@theia/core/shared/@theia/application-package/lib/environment/index.js");
const json_schema_store_1 = __webpack_require__(/*! @theia/core/lib/browser/json-schema-store */ "../../node_modules/@theia/core/lib/browser/json-schema-store.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../../node_modules/@theia/filesystem/lib/browser/file-service.js");
const plugin_custom_editor_registry_1 = __webpack_require__(/*! ../../main/browser/custom-editors/plugin-custom-editor-registry */ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/plugin-custom-editor-registry.js");
const custom_editor_widget_1 = __webpack_require__(/*! ../../main/browser/custom-editors/custom-editor-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-widget.js");
const standaloneServices_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices */ "../../node_modules/@theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices.js");
const language_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/common/languages/language */ "../../node_modules/@theia/monaco-editor-core/esm/vs/editor/common/languages/language.js");
const uint8_array_message_buffer_1 = __webpack_require__(/*! @theia/core/lib/common/message-rpc/uint8-array-message-buffer */ "../../node_modules/@theia/core/lib/common/message-rpc/uint8-array-message-buffer.js");
const channel_1 = __webpack_require__(/*! @theia/core/lib/common/message-rpc/channel */ "../../node_modules/@theia/core/lib/common/message-rpc/channel.js");
const browser_2 = __webpack_require__(/*! @theia/notebook/lib/browser */ "../../node_modules/@theia/notebook/lib/browser/index.js");
const application_protocol_1 = __webpack_require__(/*! @theia/core/lib/common/application-protocol */ "../../node_modules/@theia/core/lib/common/application-protocol.js");
const hosted_plugin_1 = __webpack_require__(/*! ../common/hosted-plugin */ "../../node_modules/@theia/plugin-ext/lib/hosted/common/hosted-plugin.js");
const browser_3 = __webpack_require__(/*! @theia/core/lib/browser/browser */ "../../node_modules/@theia/core/lib/browser/browser.js");
exports.PluginProgressLocation = 'plugin';
let HostedPluginSupport = HostedPluginSupport_1 = class HostedPluginSupport extends hosted_plugin_1.AbstractHostedPluginSupport {
    constructor() {
        super((0, uuid_1.generateUuid)());
        this.webviewsToRestore = new Map();
        this.webviewRevivers = new Map();
    }
    init() {
        super.init();
        this.workspaceService.onWorkspaceChanged(() => this.updateStoragePath());
        const languageService = standaloneServices_1.StandaloneServices.get(language_1.ILanguageService);
        for (const language of languageService['_requestedBasicLanguages']) {
            this.activateByLanguage(language);
        }
        languageService.onDidRequestBasicLanguageFeatures(language => this.activateByLanguage(language));
        this.commands.onWillExecuteCommand(event => this.ensureCommandHandlerRegistration(event));
        this.debugSessionManager.onWillStartDebugSession(event => this.ensureDebugActivation(event));
        this.debugSessionManager.onWillResolveDebugConfiguration(event => this.ensureDebugActivation(event, 'onDebugResolve', event.debugType));
        this.debugConfigurationManager.onWillProvideDebugConfiguration(event => this.ensureDebugActivation(event, 'onDebugInitialConfigurations'));
        // Activate all providers of dynamic configurations, i.e. Let the user pick a configuration from all the available ones.
        this.debugConfigurationManager.onWillProvideDynamicDebugConfiguration(event => this.ensureDebugActivation(event, 'onDebugDynamicConfigurations', hosted_plugin_1.ALL_ACTIVATION_EVENT));
        this.viewRegistry.onDidExpandView(id => this.activateByView(id));
        this.taskProviderRegistry.onWillProvideTaskProvider(event => this.ensureTaskActivation(event));
        this.taskResolverRegistry.onWillProvideTaskResolver(event => this.ensureTaskActivation(event));
        this.fileService.onWillActivateFileSystemProvider(event => this.ensureFileSystemActivation(event));
        this.customEditorRegistry.onWillOpenCustomEditor(event => this.activateByCustomEditor(event));
        this.notebookService.onWillOpenNotebook(async (event) => this.activateByNotebook(event));
        this.notebookRendererMessagingService.onWillActivateRenderer(rendererId => this.activateByNotebookRenderer(rendererId));
        this.widgets.onDidCreateWidget(({ factoryId, widget }) => {
            // note: state restoration of custom editors is handled in `PluginCustomEditorRegistry.init`
            if (factoryId === webview_1.WebviewWidget.FACTORY_ID && widget instanceof webview_1.WebviewWidget) {
                const storeState = widget.storeState.bind(widget);
                const restoreState = widget.restoreState.bind(widget);
                widget.storeState = () => {
                    if (this.webviewRevivers.has(widget.viewType)) {
                        return storeState();
                    }
                    return undefined;
                };
                widget.restoreState = state => {
                    if (state.viewType) {
                        restoreState(state);
                        this.preserveWebview(widget);
                    }
                    else {
                        widget.dispose();
                    }
                };
            }
        });
    }
    createTheiaReadyPromise() {
        return Promise.all([this.preferenceServiceImpl.ready, this.workspaceService.roots]);
    }
    runOperation(operation) {
        return this.progressService.withProgress('', exports.PluginProgressLocation, () => this.doLoad());
    }
    afterStart() {
        this.watcher.onDidDeploy(() => this.load());
        this.server.onDidOpenConnection(() => this.load());
    }
    // Only load connection-scoped plugins
    acceptPlugin(plugin) {
        return (0, hosted_plugin_1.isConnectionScopedBackendPlugin)(plugin);
    }
    async beforeSyncPlugins(toDisconnect) {
        await super.beforeSyncPlugins(toDisconnect);
        toDisconnect.push(core_1.Disposable.create(() => this.preserveWebviews()));
        this.server.onDidCloseConnection(() => toDisconnect.dispose());
    }
    async beforeLoadContributions(toDisconnect) {
        // make sure that the previous state, including plugin widgets, is restored
        // and core layout is initialized, i.e. explorer, scm, debug views are already added to the shell
        // but shell is not yet revealed
        await this.appState.reachedState('initialized_layout');
    }
    async afterLoadContributions(toDisconnect) {
        await this.viewRegistry.initWidgets();
        // remove restored plugin widgets which were not registered by contributions
        this.viewRegistry.removeStaleWidgets();
    }
    handleContributions(plugin) {
        return this.contributionHandler.handleContributions(this.clientId, plugin);
    }
    handlePluginStarted(manager, plugin) {
        this.activateByWorkspaceContains(manager, plugin);
    }
    async obtainManager(host, hostContributions, toDisconnect) {
        var _a;
        let manager = this.managers.get(host);
        if (!manager) {
            const pluginId = (0, plugin_protocol_1.getPluginId)(hostContributions[0].plugin.metadata.model);
            const rpc = this.initRpc(host, pluginId);
            toDisconnect.push(rpc);
            manager = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.HOSTED_PLUGIN_MANAGER_EXT);
            this.managers.set(host, manager);
            toDisconnect.push(core_1.Disposable.create(() => this.managers.delete(host)));
            const [extApi, globalState, workspaceState, webviewResourceRoot, webviewCspSource, defaultShell, jsonValidation] = await Promise.all([
                this.server.getExtPluginAPI(),
                this.pluginServer.getAllStorageValues(undefined),
                this.pluginServer.getAllStorageValues({
                    workspace: (_a = this.workspaceService.workspace) === null || _a === void 0 ? void 0 : _a.resource.toString(),
                    roots: this.workspaceService.tryGetRoots().map(root => root.resource.toString())
                }),
                this.webviewEnvironment.resourceRoot(host),
                this.webviewEnvironment.cspSource(),
                this.terminalService.getDefaultShell(),
                this.jsonSchemaStore.schemas
            ]);
            if (toDisconnect.disposed) {
                return undefined;
            }
            const isElectron = environment_1.environment.electron.is();
            const supportedActivationEvents = [...HostedPluginSupport_1.BUILTIN_ACTIVATION_EVENTS];
            const [additionalActivationEvents, appRoot] = await Promise.all([
                this.envServer.getValue(HostedPluginSupport_1.ADDITIONAL_ACTIVATION_EVENTS_ENV),
                this.applicationServer.getApplicationRoot()
            ]);
            if (additionalActivationEvents && additionalActivationEvents.value) {
                additionalActivationEvents.value.split(',').forEach(event => supportedActivationEvents.push(event));
            }
            await manager.$init({
                preferences: (0, preference_registry_main_1.getPreferences)(this.preferenceProviderProvider, this.workspaceService.tryGetRoots()),
                globalState,
                workspaceState,
                env: {
                    queryParams: (0, env_main_1.getQueryParameters)(),
                    language: core_1.nls.locale || core_1.nls.defaultLocale,
                    shell: defaultShell,
                    uiKind: isElectron ? plugin_api_rpc_1.UIKind.Desktop : plugin_api_rpc_1.UIKind.Web,
                    appName: frontend_application_config_provider_1.FrontendApplicationConfigProvider.get().applicationName,
                    appHost: isElectron ? 'desktop' : 'web', // TODO: 'web' could be the embedder's name, e.g. 'github.dev'
                    appRoot,
                    appUriScheme: frontend_application_config_provider_1.FrontendApplicationConfigProvider.get().electron.uriScheme
                },
                extApi,
                webview: {
                    webviewResourceRoot,
                    webviewCspSource
                },
                jsonValidation,
                pluginKind: browser_3.isRemote ? plugin_api_rpc_1.ExtensionKind.Workspace : plugin_api_rpc_1.ExtensionKind.UI,
                supportedActivationEvents
            });
            if (toDisconnect.disposed) {
                return undefined;
            }
            this.activationEvents.forEach(event => manager.$activateByEvent(event));
        }
        return manager;
    }
    initRpc(host, pluginId) {
        const rpc = host === 'frontend' ? new plugin_worker_1.PluginWorker().rpc : this.createServerRpc(host);
        (0, main_context_1.setUpPluginApi)(rpc, this.container);
        this.mainPluginApiProviders.getContributions().forEach(p => p.initialize(rpc, this.container));
        return rpc;
    }
    createServerRpc(pluginHostId) {
        const channel = new channel_1.BasicChannel(() => {
            const writer = new uint8_array_message_buffer_1.Uint8ArrayWriteBuffer();
            writer.onCommit(buffer => {
                this.server.onMessage(pluginHostId, buffer);
            });
            return writer;
        });
        // Create RPC protocol before adding the listener to the watcher to receive the watcher's cached messages after the rpc protocol was created.
        const rpc = new rpc_protocol_1.RPCProtocolImpl(channel);
        this.watcher.onPostMessageEvent(received => {
            if (pluginHostId === received.pluginHostId) {
                channel.onMessageEmitter.fire(() => new uint8_array_message_buffer_1.Uint8ArrayReadBuffer(received.message));
            }
        });
        return rpc;
    }
    async updateStoragePath() {
        const path = await this.getStoragePath();
        for (const manager of this.managers.values()) {
            manager.$updateStoragePath(path);
        }
    }
    async getStoragePath() {
        var _a;
        const roots = await this.workspaceService.roots;
        return this.pluginPathsService.getHostStoragePath((_a = this.workspaceService.workspace) === null || _a === void 0 ? void 0 : _a.resource.toString(), roots.map(root => root.resource.toString()));
    }
    async getHostGlobalStoragePath() {
        const configDirUri = await this.envServer.getConfigDirUri();
        const globalStorageFolderUri = new uri_1.default(configDirUri).resolve('globalStorage');
        // Make sure that folder by the path exists
        if (!await this.fileService.exists(globalStorageFolderUri)) {
            await this.fileService.createFolder(globalStorageFolderUri, { fromUserGesture: false });
        }
        const globalStorageFolderFsPath = await this.fileService.fsPath(globalStorageFolderUri);
        if (!globalStorageFolderFsPath) {
            throw new Error(`Could not resolve the FS path for URI: ${globalStorageFolderUri}`);
        }
        return globalStorageFolderFsPath;
    }
    async activateByViewContainer(viewContainerId) {
        await Promise.all(this.viewRegistry.getContainerViews(viewContainerId).map(viewId => this.activateByView(viewId)));
    }
    async activateByView(viewId) {
        await this.activateByEvent(`onView:${viewId}`);
    }
    async activateByLanguage(languageId) {
        await this.activateByEvent('onLanguage');
        await this.activateByEvent(`onLanguage:${languageId}`);
    }
    async activateByUri(scheme, authority) {
        await this.activateByEvent(`onUri:${scheme}://${authority}`);
    }
    async activateByCommand(commandId) {
        await this.activateByEvent(`onCommand:${commandId}`);
    }
    async activateByTaskType(taskType) {
        await this.activateByEvent(`onTaskType:${taskType}`);
    }
    async activateByCustomEditor(viewType) {
        await this.activateByEvent(`onCustomEditor:${viewType}`);
    }
    async activateByNotebook(viewType) {
        await this.activateByEvent(`onNotebook:${viewType}`);
    }
    async activateByNotebookSerializer(viewType) {
        await this.activateByEvent(`onNotebookSerializer:${viewType}`);
    }
    async activateByNotebookRenderer(rendererId) {
        await this.activateByEvent(`onRenderer:${rendererId}`);
    }
    activateByFileSystem(event) {
        return this.activateByEvent(`onFileSystem:${event.scheme}`);
    }
    activateByTerminalProfile(profileId) {
        return this.activateByEvent(`onTerminalProfile:${profileId}`);
    }
    ensureFileSystemActivation(event) {
        event.waitUntil(this.activateByFileSystem(event).then(() => {
            if (!this.fileService.hasProvider(event.scheme)) {
                return (0, promise_util_1.waitForEvent)(event_1.Event.filter(this.fileService.onDidChangeFileSystemProviderRegistrations, ({ added, scheme }) => added && scheme === event.scheme), 3000);
            }
        }));
    }
    ensureCommandHandlerRegistration(event) {
        const activation = this.activateByCommand(event.commandId);
        if (this.commands.getCommand(event.commandId) &&
            (!this.contributionHandler.hasCommand(event.commandId) ||
                this.contributionHandler.hasCommandHandler(event.commandId))) {
            return;
        }
        const waitForCommandHandler = new promise_util_1.Deferred();
        const listener = this.contributionHandler.onDidRegisterCommandHandler(id => {
            if (id === event.commandId) {
                listener.dispose();
                waitForCommandHandler.resolve();
            }
        });
        const p = Promise.all([
            activation,
            waitForCommandHandler.promise
        ]);
        p.then(() => listener.dispose(), () => listener.dispose());
        event.waitUntil(p);
    }
    ensureTaskActivation(event) {
        const promises = [this.activateByCommand('workbench.action.tasks.runTask')];
        const taskType = event.taskType;
        if (taskType) {
            if (taskType === hosted_plugin_1.ALL_ACTIVATION_EVENT) {
                for (const taskDefinition of this.taskDefinitionRegistry.getAll()) {
                    promises.push(this.activateByTaskType(taskDefinition.taskType));
                }
            }
            else {
                promises.push(this.activateByTaskType(taskType));
            }
        }
        event.waitUntil(Promise.all(promises));
    }
    ensureDebugActivation(event, activationEvent, debugType) {
        event.waitUntil(this.activateByDebug(activationEvent, debugType));
    }
    async activateByDebug(activationEvent, debugType) {
        const promises = [this.activateByEvent('onDebug')];
        if (activationEvent) {
            promises.push(this.activateByEvent(activationEvent));
            if (debugType) {
                promises.push(this.activateByEvent(activationEvent + ':' + debugType));
            }
        }
        await Promise.all(promises);
    }
    async activateByWorkspaceContains(manager, plugin) {
        const activationEvents = plugin.contributes && plugin.contributes.activationEvents;
        if (!activationEvents) {
            return;
        }
        const paths = [];
        const includePatterns = [];
        // should be aligned with https://github.com/microsoft/vscode/blob/da5fb7d5b865aa522abc7e82c10b746834b98639/src/vs/workbench/api/node/extHostExtensionService.ts#L460-L469
        for (const activationEvent of activationEvents) {
            if (/^workspaceContains:/.test(activationEvent)) {
                const fileNameOrGlob = activationEvent.substring('workspaceContains:'.length);
                if (fileNameOrGlob.indexOf(hosted_plugin_1.ALL_ACTIVATION_EVENT) >= 0 || fileNameOrGlob.indexOf('?') >= 0) {
                    includePatterns.push(fileNameOrGlob);
                }
                else {
                    paths.push(fileNameOrGlob);
                }
            }
        }
        const activatePlugin = () => manager.$activateByEvent(`onPlugin:${plugin.metadata.model.id}`);
        const promises = [];
        if (paths.length) {
            promises.push(this.workspaceService.containsSome(paths));
        }
        if (includePatterns.length) {
            const tokenSource = new core_1.CancellationTokenSource();
            const searchTimeout = setTimeout(() => {
                tokenSource.cancel();
                // activate eagerly if took to long to search
                activatePlugin();
            }, 7000);
            promises.push((async () => {
                try {
                    const result = await this.fileSearchService.find('', {
                        rootUris: this.workspaceService.tryGetRoots().map(r => r.resource.toString()),
                        includePatterns,
                        limit: 1
                    }, tokenSource.token);
                    return result.length > 0;
                }
                catch (e) {
                    if (!(0, core_1.isCancelled)(e)) {
                        console.error(e);
                    }
                    return false;
                }
                finally {
                    clearTimeout(searchTimeout);
                }
            })());
        }
        if (promises.length && await Promise.all(promises).then(exists => exists.some(v => v))) {
            await activatePlugin();
        }
    }
    registerWebviewReviver(viewType, reviver) {
        if (this.webviewRevivers.has(viewType)) {
            throw new Error(`Reviver for ${viewType} already registered`);
        }
        this.webviewRevivers.set(viewType, reviver);
        if (this.webviewsToRestore.has(viewType)) {
            this.restoreWebview(this.webviewsToRestore.get(viewType));
        }
    }
    unregisterWebviewReviver(viewType) {
        this.webviewRevivers.delete(viewType);
    }
    async preserveWebviews() {
        for (const webview of this.widgets.getWidgets(webview_1.WebviewWidget.FACTORY_ID)) {
            this.preserveWebview(webview);
        }
        for (const webview of this.widgets.getWidgets(custom_editor_widget_1.CustomEditorWidget.FACTORY_ID)) {
            webview.modelRef.dispose();
            if (webview['closeWithoutSaving']) {
                delete webview['closeWithoutSaving'];
            }
            this.customEditorRegistry.resolveWidget(webview);
        }
    }
    preserveWebview(webview) {
        if (!this.webviewsToRestore.has(webview.viewType)) {
            this.activateByEvent(`onWebviewPanel:${webview.viewType}`);
            this.webviewsToRestore.set(webview.viewType, webview);
            webview.disposed.connect(() => this.webviewsToRestore.delete(webview.viewType));
        }
    }
    async restoreWebview(webview) {
        const restore = this.webviewRevivers.get(webview.viewType);
        if (restore) {
            try {
                await restore(webview);
            }
            catch (e) {
                webview.setHTML(this.getDeserializationFailedContents(`
                An error occurred while restoring '${webview.viewType}' view. Please check logs.
                `));
                console.error('Failed to restore the webview', e);
            }
        }
    }
    getDeserializationFailedContents(message) {
        return `<!DOCTYPE html>
        <html>
            <head>
                <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
                <meta http-equiv="Content-Security-Policy" content="default-src 'none';">
            </head>
            <body>${message}</body>
        </html>`;
    }
};
exports.HostedPluginSupport = HostedPluginSupport;
HostedPluginSupport.ADDITIONAL_ACTIVATION_EVENTS_ENV = 'ADDITIONAL_ACTIVATION_EVENTS';
HostedPluginSupport.BUILTIN_ACTIVATION_EVENTS = [
    '*',
    'onLanguage',
    'onCommand',
    'onDebug',
    'onDebugInitialConfigurations',
    'onDebugResolve',
    'onDebugAdapterProtocolTracker',
    'onDebugDynamicConfigurations',
    'onTaskType',
    'workspaceContains',
    'onView',
    'onUri',
    'onTerminalProfile',
    'onWebviewPanel',
    'onFileSystem',
    'onCustomEditor',
    'onStartupFinished',
    'onAuthenticationRequest',
    'onNotebook',
    'onNotebookSerializer'
];
tslib_1.__decorate([
    (0, inversify_1.inject)(hosted_plugin_watcher_1.HostedPluginWatcher),
    tslib_1.__metadata("design:type", hosted_plugin_watcher_1.HostedPluginWatcher)
], HostedPluginSupport.prototype, "watcher", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_contribution_handler_1.PluginContributionHandler),
    tslib_1.__metadata("design:type", plugin_contribution_handler_1.PluginContributionHandler)
], HostedPluginSupport.prototype, "contributionHandler", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(preferences_1.PreferenceProviderProvider),
    tslib_1.__metadata("design:type", Function)
], HostedPluginSupport.prototype, "preferenceProviderProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(preferences_1.PreferenceServiceImpl),
    tslib_1.__metadata("design:type", preferences_1.PreferenceServiceImpl)
], HostedPluginSupport.prototype, "preferenceServiceImpl", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.WorkspaceService),
    tslib_1.__metadata("design:type", browser_1.WorkspaceService)
], HostedPluginSupport.prototype, "workspaceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.NotebookService),
    tslib_1.__metadata("design:type", browser_2.NotebookService)
], HostedPluginSupport.prototype, "notebookService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.NotebookRendererMessagingService),
    tslib_1.__metadata("design:type", browser_2.NotebookRendererMessagingService)
], HostedPluginSupport.prototype, "notebookRendererMessagingService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.CommandRegistry),
    tslib_1.__metadata("design:type", core_1.CommandRegistry)
], HostedPluginSupport.prototype, "commands", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_session_manager_1.DebugSessionManager),
    tslib_1.__metadata("design:type", debug_session_manager_1.DebugSessionManager)
], HostedPluginSupport.prototype, "debugSessionManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_configuration_manager_1.DebugConfigurationManager),
    tslib_1.__metadata("design:type", debug_configuration_manager_1.DebugConfigurationManager)
], HostedPluginSupport.prototype, "debugConfigurationManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(file_service_1.FileService),
    tslib_1.__metadata("design:type", file_service_1.FileService)
], HostedPluginSupport.prototype, "fileService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(file_search_service_1.FileSearchService),
    tslib_1.__metadata("design:type", Object)
], HostedPluginSupport.prototype, "fileSearchService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(frontend_application_state_1.FrontendApplicationStateService),
    tslib_1.__metadata("design:type", frontend_application_state_1.FrontendApplicationStateService)
], HostedPluginSupport.prototype, "appState", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.NotebookTypeRegistry),
    tslib_1.__metadata("design:type", browser_2.NotebookTypeRegistry)
], HostedPluginSupport.prototype, "notebookTypeRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_view_registry_1.PluginViewRegistry),
    tslib_1.__metadata("design:type", plugin_view_registry_1.PluginViewRegistry)
], HostedPluginSupport.prototype, "viewRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_contribution_1.TaskProviderRegistry),
    tslib_1.__metadata("design:type", task_contribution_1.TaskProviderRegistry)
], HostedPluginSupport.prototype, "taskProviderRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_contribution_1.TaskResolverRegistry),
    tslib_1.__metadata("design:type", task_contribution_1.TaskResolverRegistry)
], HostedPluginSupport.prototype, "taskResolverRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(task_definition_registry_1.TaskDefinitionRegistry),
    tslib_1.__metadata("design:type", task_definition_registry_1.TaskDefinitionRegistry)
], HostedPluginSupport.prototype, "taskDefinitionRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.ProgressService),
    tslib_1.__metadata("design:type", core_1.ProgressService)
], HostedPluginSupport.prototype, "progressService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(webview_environment_1.WebviewEnvironment),
    tslib_1.__metadata("design:type", webview_environment_1.WebviewEnvironment)
], HostedPluginSupport.prototype, "webviewEnvironment", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(widget_manager_1.WidgetManager),
    tslib_1.__metadata("design:type", widget_manager_1.WidgetManager)
], HostedPluginSupport.prototype, "widgets", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(terminal_service_1.TerminalService),
    tslib_1.__metadata("design:type", Object)
], HostedPluginSupport.prototype, "terminalService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(json_schema_store_1.JsonSchemaStore),
    tslib_1.__metadata("design:type", json_schema_store_1.JsonSchemaStore)
], HostedPluginSupport.prototype, "jsonSchemaStore", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_custom_editor_registry_1.PluginCustomEditorRegistry),
    tslib_1.__metadata("design:type", plugin_custom_editor_registry_1.PluginCustomEditorRegistry)
], HostedPluginSupport.prototype, "customEditorRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(application_protocol_1.ApplicationServer),
    tslib_1.__metadata("design:type", Object)
], HostedPluginSupport.prototype, "applicationServer", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], HostedPluginSupport.prototype, "init", null);
exports.HostedPluginSupport = HostedPluginSupport = HostedPluginSupport_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], HostedPluginSupport);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/hosted/browser/plugin-worker.js"
/*!********************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/hosted/browser/plugin-worker.js ***!
  \********************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginWorker = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const channel_1 = __webpack_require__(/*! @theia/core/lib/common/message-rpc/channel */ "../../node_modules/@theia/core/lib/common/message-rpc/channel.js");
const uint8_array_message_buffer_1 = __webpack_require__(/*! @theia/core/lib/common/message-rpc/uint8-array-message-buffer */ "../../node_modules/@theia/core/lib/common/message-rpc/uint8-array-message-buffer.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const rpc_protocol_1 = __webpack_require__(/*! ../../common/rpc-protocol */ "../../node_modules/@theia/plugin-ext/lib/common/rpc-protocol.js");
let PluginWorker = class PluginWorker {
    constructor() {
        this.worker = new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u("_a1e5-_75a9-_1447-_8a3f"), __webpack_require__.b));
        const channel = new channel_1.BasicChannel(() => {
            const writer = new uint8_array_message_buffer_1.Uint8ArrayWriteBuffer();
            writer.onCommit(buffer => {
                this.worker.postMessage(buffer);
            });
            return writer;
        });
        this.rpc = new rpc_protocol_1.RPCProtocolImpl(channel);
        // eslint-disable-next-line arrow-body-style
        this.worker.onmessage = buffer => channel.onMessageEmitter.fire(() => {
            return new uint8_array_message_buffer_1.Uint8ArrayReadBuffer(buffer.data);
        });
        this.worker.onerror = e => channel.onErrorEmitter.fire(e);
    }
};
exports.PluginWorker = PluginWorker;
exports.PluginWorker = PluginWorker = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], PluginWorker);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/hosted/common/hosted-plugin.js"
/*!*******************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/hosted/common/hosted-plugin.js ***!
  \*******************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/da5fb7d5b865aa522abc7e82c10b746834b98639/src/vs/workbench/api/node/extHostExtensionService.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginContributions = exports.AbstractHostedPluginSupport = exports.isConnectionScopedBackendPlugin = exports.ALL_ACTIVATION_EVENT = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
/* eslint-disable @typescript-eslint/no-explicit-any */
const debounce = __webpack_require__(/*! @theia/core/shared/lodash.debounce */ "../../node_modules/@theia/core/shared/lodash.debounce/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const plugin_protocol_1 = __webpack_require__(/*! ../../common/plugin-protocol */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-protocol.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const plugin_ext_api_contribution_1 = __webpack_require__(/*! ../../common/plugin-ext-api-contribution */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-ext-api-contribution.js");
const plugin_paths_protocol_1 = __webpack_require__(/*! ../../main/common/plugin-paths-protocol */ "../../node_modules/@theia/plugin-ext/lib/main/common/plugin-paths-protocol.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../../node_modules/@theia/core/lib/common/promise-util.js");
const env_variables_1 = __webpack_require__(/*! @theia/core/lib/common/env-variables */ "../../node_modules/@theia/core/lib/common/env-variables/index.js");
const environment_1 = __webpack_require__(/*! @theia/core/shared/@theia/application-package/lib/environment */ "../../node_modules/@theia/core/shared/@theia/application-package/lib/environment/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../../node_modules/@theia/core/lib/common/index.js");
exports.ALL_ACTIVATION_EVENT = '*';
function isConnectionScopedBackendPlugin(plugin) {
    const entryPoint = plugin.metadata.model.entryPoint;
    // A plugin doesn't have to have any entry-point if it doesn't need the activation handler,
    // in which case it's assumed to be a backend plugin.
    return !entryPoint.headless || !!entryPoint.backend;
}
exports.isConnectionScopedBackendPlugin = isConnectionScopedBackendPlugin;
let AbstractHostedPluginSupport = class AbstractHostedPluginSupport {
    /**
     * Resolves when the initial plugins are loaded and about to be started.
     */
    get willStart() {
        return this.deferredWillStart.promise;
    }
    /**
     * Resolves when the initial plugins are started.
     */
    get didStart() {
        return this.deferredDidStart.promise;
    }
    constructor(clientId) {
        this.clientId = clientId;
        this.managers = new Map();
        this.contributions = new Map();
        this.activationEvents = new Set();
        this.onDidChangePluginsEmitter = new core_1.Emitter();
        this.onDidChangePlugins = this.onDidChangePluginsEmitter.event;
        this.deferredWillStart = new promise_util_1.Deferred();
        this.deferredDidStart = new promise_util_1.Deferred();
        this.loadQueue = Promise.resolve(undefined);
        this.load = debounce(() => this.loadQueue = this.loadQueue.then(async () => {
            try {
                await this.runOperation(() => this.doLoad());
            }
            catch (e) {
                console.error('Failed to load plugins:', e);
            }
        }), 50, { leading: true });
    }
    init() {
        this.theiaReadyPromise = this.createTheiaReadyPromise();
    }
    get plugins() {
        const plugins = [];
        this.contributions.forEach(contributions => plugins.push(contributions.plugin.metadata));
        return plugins;
    }
    getPlugin(id) {
        const contributions = this.contributions.get(id);
        return contributions && contributions.plugin;
    }
    /** do not call it, except from the plugin frontend contribution */
    onStart(container) {
        this.container = container;
        this.load();
        this.afterStart();
    }
    afterStart() {
        // Nothing to do in the abstract
    }
    runOperation(operation) {
        return operation();
    }
    async doLoad() {
        const toDisconnect = new core_1.DisposableCollection(core_1.Disposable.create(() => { }));
        await this.beforeSyncPlugins(toDisconnect);
        // process empty plugins as well in order to properly remove stale plugin widgets
        await this.syncPlugins();
        // it has to be resolved before awaiting layout is initialized
        // otherwise clients can hang forever in the initialization phase
        this.deferredWillStart.resolve();
        await this.beforeLoadContributions(toDisconnect);
        if (toDisconnect.disposed) {
            // if disconnected then don't try to load plugin contributions
            return;
        }
        const contributionsByHost = this.loadContributions(toDisconnect);
        await this.afterLoadContributions(toDisconnect);
        await this.theiaReadyPromise;
        if (toDisconnect.disposed) {
            // if disconnected then don't try to init plugin code and dynamic contributions
            return;
        }
        await this.startPlugins(contributionsByHost, toDisconnect);
        this.deferredDidStart.resolve();
    }
    beforeSyncPlugins(toDisconnect) {
        // Nothing to do in the abstract
        return Promise.resolve();
    }
    beforeLoadContributions(toDisconnect) {
        // Nothing to do in the abstract
        return Promise.resolve();
    }
    afterLoadContributions(toDisconnect) {
        // Nothing to do in the abstract
        return Promise.resolve();
    }
    /**
     * Sync loaded and deployed plugins:
     * - undeployed plugins are unloaded
     * - newly deployed plugins are initialized
     */
    async syncPlugins() {
        var _a;
        let initialized = 0;
        const waitPluginsMeasurement = this.measure('waitForDeployment');
        let syncPluginsMeasurement;
        const toUnload = new Set(this.contributions.keys());
        let didChangeInstallationStatus = false;
        try {
            const newPluginIds = [];
            const [deployedPluginIds, uninstalledPluginIds, disabledPlugins] = await Promise.all([this.server.getDeployedPluginIds(), this.server.getUninstalledPluginIds(), this.server.getDisabledPluginIds()]);
            waitPluginsMeasurement.log('Waiting for backend deployment');
            syncPluginsMeasurement = this.measure('syncPlugins');
            for (const versionedId of deployedPluginIds) {
                const unversionedId = plugin_protocol_1.PluginIdentifiers.unversionedFromVersioned(versionedId);
                toUnload.delete(unversionedId);
                if (!this.contributions.has(unversionedId)) {
                    newPluginIds.push(versionedId);
                }
            }
            for (const pluginId of toUnload) {
                (_a = this.contributions.get(pluginId)) === null || _a === void 0 ? void 0 : _a.dispose();
            }
            for (const versionedId of uninstalledPluginIds) {
                const plugin = this.getPlugin(plugin_protocol_1.PluginIdentifiers.unversionedFromVersioned(versionedId));
                if (plugin && plugin_protocol_1.PluginIdentifiers.componentsToVersionedId(plugin.metadata.model) === versionedId && !plugin.metadata.outOfSync) {
                    plugin.metadata.outOfSync = didChangeInstallationStatus = true;
                }
            }
            for (const unversionedId of disabledPlugins) {
                const plugin = this.getPlugin(unversionedId);
                if (plugin && plugin_protocol_1.PluginIdentifiers.componentsToUnversionedId(plugin.metadata.model) === unversionedId && !plugin.metadata.outOfSync) {
                    plugin.metadata.outOfSync = didChangeInstallationStatus = true;
                }
            }
            for (const contribution of this.contributions.values()) {
                if (contribution.plugin.metadata.outOfSync && !(uninstalledPluginIds.includes(plugin_protocol_1.PluginIdentifiers.componentsToVersionedId(contribution.plugin.metadata.model))
                    || disabledPlugins.includes(plugin_protocol_1.PluginIdentifiers.componentsToUnversionedId(contribution.plugin.metadata.model)))) {
                    contribution.plugin.metadata.outOfSync = false;
                    didChangeInstallationStatus = true;
                }
            }
            if (newPluginIds.length) {
                const deployedPlugins = await this.server.getDeployedPlugins(newPluginIds);
                const plugins = [];
                for (const plugin of deployedPlugins) {
                    const accepted = this.acceptPlugin(plugin);
                    if (typeof accepted === 'object') {
                        plugins.push(accepted);
                    }
                    else if (accepted) {
                        plugins.push(plugin);
                    }
                }
                for (const plugin of plugins) {
                    const pluginId = plugin_protocol_1.PluginIdentifiers.componentsToUnversionedId(plugin.metadata.model);
                    const contributions = new PluginContributions(plugin);
                    this.contributions.set(pluginId, contributions);
                    contributions.push(core_1.Disposable.create(() => this.contributions.delete(pluginId)));
                    initialized++;
                }
            }
        }
        finally {
            if (initialized || toUnload.size || didChangeInstallationStatus) {
                this.onDidChangePluginsEmitter.fire(undefined);
            }
            if (!syncPluginsMeasurement) {
                // await didn't complete normally
                waitPluginsMeasurement.error('Backend deployment failed.');
            }
        }
        if (initialized > 0) {
            // Only log sync measurement if there are were plugins to sync.
            syncPluginsMeasurement === null || syncPluginsMeasurement === void 0 ? void 0 : syncPluginsMeasurement.log(`Sync of ${this.getPluginCount(initialized)}`);
        }
        else {
            syncPluginsMeasurement === null || syncPluginsMeasurement === void 0 ? void 0 : syncPluginsMeasurement.stop();
        }
    }
    /**
     * Always synchronous in order to simplify handling disconnections.
     * @throws never
     */
    loadContributions(toDisconnect) {
        let loaded = 0;
        const loadPluginsMeasurement = this.measure('loadPlugins');
        const hostContributions = new Map();
        console.log(`[${this.clientId}] Loading plugin contributions`);
        for (const contributions of this.contributions.values()) {
            const plugin = contributions.plugin.metadata;
            const pluginId = plugin.model.id;
            if (contributions.state === PluginContributions.State.INITIALIZING) {
                contributions.state = PluginContributions.State.LOADING;
                contributions.push(core_1.Disposable.create(() => console.log(`[${pluginId}]: Unloaded plugin.`)));
                contributions.push(this.handleContributions(contributions.plugin));
                contributions.state = PluginContributions.State.LOADED;
                console.debug(`[${this.clientId}][${pluginId}]: Loaded contributions.`);
                loaded++;
            }
            if (contributions.state === PluginContributions.State.LOADED) {
                contributions.state = PluginContributions.State.STARTING;
                const host = plugin.model.entryPoint.frontend ? 'frontend' : plugin.host;
                const dynamicContributions = hostContributions.get(host) || [];
                dynamicContributions.push(contributions);
                hostContributions.set(host, dynamicContributions);
                toDisconnect.push(core_1.Disposable.create(() => {
                    contributions.state = PluginContributions.State.LOADED;
                    console.debug(`[${this.clientId}][${pluginId}]: Disconnected.`);
                }));
            }
        }
        if (loaded > 0) {
            // Only log load measurement if there are were plugins to load.
            loadPluginsMeasurement === null || loadPluginsMeasurement === void 0 ? void 0 : loadPluginsMeasurement.log(`Load contributions of ${this.getPluginCount(loaded)}`);
        }
        else {
            loadPluginsMeasurement.stop();
        }
        return hostContributions;
    }
    async startPlugins(contributionsByHost, toDisconnect) {
        let started = 0;
        const startPluginsMeasurement = this.measure('startPlugins');
        const [hostLogPath, hostStoragePath, hostGlobalStoragePath] = await Promise.all([
            this.pluginPathsService.getHostLogPath(),
            this.getStoragePath(),
            this.getHostGlobalStoragePath()
        ]);
        if (toDisconnect.disposed) {
            return;
        }
        const thenable = [];
        const configStorage = {
            hostLogPath,
            hostStoragePath,
            hostGlobalStoragePath
        };
        for (const [host, hostContributions] of contributionsByHost) {
            // do not start plugins for electron browser
            if (host === 'frontend' && environment_1.environment.electron.is()) {
                continue;
            }
            const manager = await this.obtainManager(host, hostContributions, toDisconnect);
            if (!manager) {
                continue;
            }
            const plugins = hostContributions.map(contributions => contributions.plugin.metadata);
            thenable.push((async () => {
                try {
                    const activationEvents = [...this.activationEvents];
                    await manager.$start({ plugins, configStorage, activationEvents });
                    if (toDisconnect.disposed) {
                        return;
                    }
                    console.log(`[${this.clientId}] Starting plugins.`);
                    for (const contributions of hostContributions) {
                        started++;
                        const plugin = contributions.plugin;
                        const id = plugin.metadata.model.id;
                        contributions.state = PluginContributions.State.STARTED;
                        console.debug(`[${this.clientId}][${id}]: Started plugin.`);
                        toDisconnect.push(contributions.push(core_1.Disposable.create(() => {
                            console.debug(`[${this.clientId}][${id}]: Stopped plugin.`);
                            manager.$stop(id);
                        })));
                        this.handlePluginStarted(manager, plugin);
                    }
                }
                catch (e) {
                    console.error(`Failed to start plugins for '${host}' host`, e);
                }
            })());
        }
        await Promise.all(thenable);
        await this.activateByEvent('onStartupFinished');
        if (toDisconnect.disposed) {
            return;
        }
        if (started > 0) {
            startPluginsMeasurement.log(`Start of ${this.getPluginCount(started)}`);
        }
        else {
            startPluginsMeasurement.stop();
        }
    }
    async activateByEvent(activationEvent) {
        if (this.activationEvents.has(activationEvent)) {
            return;
        }
        this.activationEvents.add(activationEvent);
        await Promise.all(Array.from(this.managers.values(), manager => manager.$activateByEvent(activationEvent)));
    }
    async activatePlugin(id) {
        const activation = [];
        for (const manager of this.managers.values()) {
            activation.push(manager.$activatePlugin(id));
        }
        await Promise.all(activation);
    }
    handlePluginStarted(manager, plugin) {
        // Nothing to do in the abstract
    }
    measure(name) {
        return this.stopwatch.start(name, { context: this.clientId });
    }
    getPluginCount(plugins) {
        return `${plugins} plugin${plugins === 1 ? '' : 's'}`;
    }
};
exports.AbstractHostedPluginSupport = AbstractHostedPluginSupport;
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.ILogger),
    tslib_1.__metadata("design:type", Object)
], AbstractHostedPluginSupport.prototype, "logger", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_protocol_1.HostedPluginServer),
    tslib_1.__metadata("design:type", Object)
], AbstractHostedPluginSupport.prototype, "server", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.ContributionProvider),
    (0, inversify_1.named)(plugin_ext_api_contribution_1.MainPluginApiProvider),
    tslib_1.__metadata("design:type", Object)
], AbstractHostedPluginSupport.prototype, "mainPluginApiProviders", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_protocol_1.PluginServer),
    tslib_1.__metadata("design:type", Object)
], AbstractHostedPluginSupport.prototype, "pluginServer", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_paths_protocol_1.PluginPathsService),
    tslib_1.__metadata("design:type", Object)
], AbstractHostedPluginSupport.prototype, "pluginPathsService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(env_variables_1.EnvVariablesServer),
    tslib_1.__metadata("design:type", Object)
], AbstractHostedPluginSupport.prototype, "envServer", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.Stopwatch),
    tslib_1.__metadata("design:type", common_1.Stopwatch)
], AbstractHostedPluginSupport.prototype, "stopwatch", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], AbstractHostedPluginSupport.prototype, "init", null);
exports.AbstractHostedPluginSupport = AbstractHostedPluginSupport = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.unmanaged)()),
    tslib_1.__metadata("design:paramtypes", [String])
], AbstractHostedPluginSupport);
class PluginContributions extends core_1.DisposableCollection {
    constructor(plugin) {
        super();
        this.plugin = plugin;
        this.state = PluginContributions.State.INITIALIZING;
    }
}
exports.PluginContributions = PluginContributions;
(function (PluginContributions) {
    let State;
    (function (State) {
        State[State["INITIALIZING"] = 0] = "INITIALIZING";
        State[State["LOADING"] = 1] = "LOADING";
        State[State["LOADED"] = 2] = "LOADED";
        State[State["STARTING"] = 3] = "STARTING";
        State[State["STARTED"] = 4] = "STARTED";
    })(State = PluginContributions.State || (PluginContributions.State = {}));
})(PluginContributions || (exports.PluginContributions = PluginContributions = {}));


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/authentication-main.js"
/*!************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/authentication-main.js ***!
  \************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthenticationProviderImpl = exports.AuthenticationMainImpl = exports.getAuthenticationProviderActivationEvent = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const message_service_1 = __webpack_require__(/*! @theia/core/lib/common/message-service */ "../../node_modules/@theia/core/lib/common/message-service.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const authentication_service_1 = __webpack_require__(/*! @theia/core/lib/browser/authentication-service */ "../../node_modules/@theia/core/lib/browser/authentication-service.js");
const quick_pick_service_1 = __webpack_require__(/*! @theia/core/lib/common/quick-pick-service */ "../../node_modules/@theia/core/lib/common/quick-pick-service.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../../node_modules/@theia/core/lib/common/nls.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
function getAuthenticationProviderActivationEvent(id) { return `onAuthenticationRequest:${id}`; }
exports.getAuthenticationProviderActivationEvent = getAuthenticationProviderActivationEvent;
class AuthenticationMainImpl {
    constructor(rpc, container) {
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.AUTHENTICATION_EXT);
        this.messageService = container.get(message_service_1.MessageService);
        this.storageService = container.get(browser_1.StorageService);
        this.authenticationService = container.get(authentication_service_1.AuthenticationService);
        this.quickPickService = container.get(quick_pick_service_1.QuickPickService);
        this.authenticationService.onDidChangeSessions(e => {
            this.proxy.$onDidChangeAuthenticationSessions({ id: e.providerId, label: e.label });
        });
    }
    async $registerAuthenticationProvider(id, label, supportsMultipleAccounts) {
        const provider = new AuthenticationProviderImpl(this.proxy, id, label, supportsMultipleAccounts, this.storageService, this.messageService);
        this.authenticationService.registerAuthenticationProvider(id, provider);
    }
    async $unregisterAuthenticationProvider(id) {
        this.authenticationService.unregisterAuthenticationProvider(id);
    }
    async $updateSessions(id, event) {
        this.authenticationService.updateSessions(id, event);
    }
    $logout(providerId, sessionId) {
        return this.authenticationService.logout(providerId, sessionId);
    }
    $getAccounts(providerId) {
        return this.authenticationService.getSessions(providerId).then(sessions => sessions.map(session => session.account));
    }
    async $getSession(providerId, scopeListOrRequest, extensionId, extensionName, options) {
        const sessions = await this.authenticationService.getSessions(providerId, scopeListOrRequest, options === null || options === void 0 ? void 0 : options.account);
        // Error cases
        if (options.forceNewSession && options.createIfNone) {
            throw new Error('Invalid combination of options. Please remove one of the following: forceNewSession, createIfNone');
        }
        if (options.forceNewSession && options.silent) {
            throw new Error('Invalid combination of options. Please remove one of the following: forceNewSession, silent');
        }
        if (options.createIfNone && options.silent) {
            throw new Error('Invalid combination of options. Please remove one of the following: createIfNone, silent');
        }
        const supportsMultipleAccounts = this.authenticationService.supportsMultipleAccounts(providerId);
        // Check if the sessions we have are valid
        if (!options.forceNewSession && sessions.length) {
            if (supportsMultipleAccounts) {
                if (options.clearSessionPreference) {
                    await this.storageService.setData(`authentication-session-${extensionName}-${providerId}`, undefined);
                }
                else {
                    const existingSessionPreference = await this.storageService.getData(`authentication-session-${extensionName}-${providerId}`);
                    if (existingSessionPreference) {
                        const matchingSession = sessions.find(session => session.id === existingSessionPreference);
                        if (matchingSession && await this.isAccessAllowed(providerId, matchingSession.account.label, extensionId)) {
                            return matchingSession;
                        }
                    }
                }
            }
            else if (await this.isAccessAllowed(providerId, sessions[0].account.label, extensionId)) {
                return sessions[0];
            }
        }
        // We may need to prompt because we don't have a valid session modal flows
        if (options.createIfNone || options.forceNewSession) {
            const providerName = this.authenticationService.getLabel(providerId);
            let detail;
            if (isAuthenticationGetSessionPresentationOptions(options.forceNewSession)) {
                detail = options.forceNewSession.detail;
            }
            else if (isAuthenticationGetSessionPresentationOptions(options.createIfNone)) {
                detail = options.createIfNone.detail;
            }
            const shouldForceNewSession = !!options.forceNewSession;
            const recreatingSession = shouldForceNewSession && !sessions.length;
            const isAllowed = await this.loginPrompt(providerName, extensionName, recreatingSession, detail);
            if (!isAllowed) {
                throw new Error('User did not consent to login.');
            }
            const session = (sessions === null || sessions === void 0 ? void 0 : sessions.length) && !shouldForceNewSession && supportsMultipleAccounts
                ? await this.selectSession(providerId, providerName, extensionId, extensionName, sessions, scopeListOrRequest, !!options.clearSessionPreference)
                : await this.authenticationService.login(providerId, scopeListOrRequest);
            await this.setTrustedExtensionAndAccountPreference(providerId, session.account.label, extensionId, extensionName, session.id);
            return session;
        }
        // passive flows (silent or default)
        const validSession = sessions.find(s => this.isAccessAllowed(providerId, s.account.label, extensionId));
        if (!options.silent && !validSession) {
            this.authenticationService.requestNewSession(providerId, scopeListOrRequest, extensionId, extensionName);
        }
        return validSession;
    }
    async selectSession(providerId, providerName, extensionId, extensionName, potentialSessions, scopeListOrRequest, clearSessionPreference) {
        if (!potentialSessions.length) {
            throw new Error('No potential sessions found');
        }
        return new Promise(async (resolve, reject) => {
            var _a, _b;
            const items = potentialSessions.map(session => ({
                label: session.account.label,
                value: { session }
            }));
            items.push({
                label: nls_1.nls.localizeByDefault('Sign in to another account'),
                value: {}
            });
            // VS Code has code here that pushes accounts that have no active sessions. However, since we do not store
            // any accounts that don't have sessions, we dont' do this.
            const selected = await this.quickPickService.show(items, {
                title: nls_1.nls.localizeByDefault("The extension '{0}' wants to access a {1} account", extensionName, providerName),
                ignoreFocusOut: true
            });
            if (selected) {
                // if we ever have accounts without sessions, pass the account to the login call
                const session = (_b = (_a = selected.value) === null || _a === void 0 ? void 0 : _a.session) !== null && _b !== void 0 ? _b : await this.authenticationService.login(providerId, scopeListOrRequest);
                const accountName = session.account.label;
                const allowList = await (0, authentication_service_1.readAllowedExtensions)(this.storageService, providerId, accountName);
                if (!allowList.find(allowed => allowed.id === extensionId)) {
                    allowList.push({ id: extensionId, name: extensionName });
                    this.storageService.setData(`authentication-trusted-extensions-${providerId}-${accountName}`, JSON.stringify(allowList));
                }
                this.storageService.setData(`authentication-session-${extensionName}-${providerId}`, session.id);
                resolve(session);
            }
            else {
                reject('User did not consent to account access');
            }
        });
    }
    async getSessionsPrompt(providerId, accountName, providerName, extensionId, extensionName) {
        const allowList = await (0, authentication_service_1.readAllowedExtensions)(this.storageService, providerId, accountName);
        const extensionData = allowList.find(extension => extension.id === extensionId);
        if (extensionData) {
            addAccountUsage(this.storageService, providerId, accountName, extensionId, extensionName);
            return true;
        }
        const choice = await this.messageService.info(`The extension '${extensionName}' wants to access the ${providerName} account '${accountName}'.`, 'Allow', 'Cancel');
        const allow = choice === 'Allow';
        if (allow) {
            await addAccountUsage(this.storageService, providerId, accountName, extensionId, extensionName);
            allowList.push({ id: extensionId, name: extensionName });
            this.storageService.setData(`authentication-trusted-extensions-${providerId}-${accountName}`, JSON.stringify(allowList));
        }
        return allow;
    }
    async loginPrompt(providerName, extensionName, recreatingSession, detail) {
        const msg = document.createElement('span');
        msg.textContent = recreatingSession
            ? nls_1.nls.localizeByDefault("The extension '{0}' wants you to sign in again using {1}.", extensionName, providerName)
            : nls_1.nls.localizeByDefault("The extension '{0}' wants to sign in using {1}.", extensionName, providerName);
        if (detail) {
            const detailElement = document.createElement('p');
            detailElement.textContent = detail;
            msg.appendChild(detailElement);
        }
        return !!await new browser_1.ConfirmDialog({
            title: nls_1.nls.localize('theia/plugin-ext/authentication-main/loginTitle', 'Login'),
            msg,
            ok: nls_1.nls.localizeByDefault('Allow'),
            cancel: browser_1.Dialog.CANCEL
        }).open();
    }
    async isAccessAllowed(providerId, accountName, extensionId) {
        const allowList = await (0, authentication_service_1.readAllowedExtensions)(this.storageService, providerId, accountName);
        return !!allowList.find(allowed => allowed.id === extensionId);
    }
    async setTrustedExtensionAndAccountPreference(providerId, accountName, extensionId, extensionName, sessionId) {
        const allowList = await (0, authentication_service_1.readAllowedExtensions)(this.storageService, providerId, accountName);
        if (!allowList.find(allowed => allowed.id === extensionId)) {
            allowList.push({ id: extensionId, name: extensionName });
            this.storageService.setData(`authentication-trusted-extensions-${providerId}-${accountName}`, JSON.stringify(allowList));
        }
        this.storageService.setData(`authentication-session-${extensionName}-${providerId}`, sessionId);
    }
    $onDidChangeSessions(providerId, event) {
        this.authenticationService.updateSessions(providerId, event);
    }
}
exports.AuthenticationMainImpl = AuthenticationMainImpl;
function isAuthenticationGetSessionPresentationOptions(arg) {
    return (0, core_1.isObject)(arg) && typeof arg.detail === 'string';
}
async function addAccountUsage(storageService, providerId, accountName, extensionId, extensionName) {
    const accountKey = `authentication-${providerId}-${accountName}-usages`;
    const usages = await readAccountUsages(storageService, providerId, accountName);
    const existingUsageIndex = usages.findIndex(usage => usage.extensionId === extensionId);
    if (existingUsageIndex > -1) {
        usages.splice(existingUsageIndex, 1, {
            extensionId,
            extensionName,
            lastUsed: Date.now()
        });
    }
    else {
        usages.push({
            extensionId,
            extensionName,
            lastUsed: Date.now()
        });
    }
    await storageService.setData(accountKey, JSON.stringify(usages));
}
class AuthenticationProviderImpl {
    constructor(proxy, id, label, supportsMultipleAccounts, storageService, messageService) {
        this.proxy = proxy;
        this.id = id;
        this.label = label;
        this.supportsMultipleAccounts = supportsMultipleAccounts;
        this.storageService = storageService;
        this.messageService = messageService;
        /** map from account name to session ids */
        this.accounts = new Map();
        /** map from session id to account name */
        this.sessions = new Map();
    }
    hasSessions() {
        return !!this.sessions.size;
    }
    registerSession(session) {
        this.sessions.set(session.id, session.account.label);
        const existingSessionsForAccount = this.accounts.get(session.account.label);
        if (existingSessionsForAccount) {
            this.accounts.set(session.account.label, existingSessionsForAccount.concat(session.id));
            return;
        }
        else {
            this.accounts.set(session.account.label, [session.id]);
        }
    }
    async signOut(accountName) {
        const accountUsages = await readAccountUsages(this.storageService, this.id, accountName);
        const sessionsForAccount = this.accounts.get(accountName);
        const result = await this.messageService.info(accountUsages.length
            ? nls_1.nls.localizeByDefault("The account '{0}' has been used by: \n\n{1}\n\n Sign out from these extensions?", accountName, accountUsages.map(usage => usage.extensionName).join(', '))
            : nls_1.nls.localizeByDefault("Sign out of '{0}'?", accountName), nls_1.nls.localizeByDefault('Sign Out'), browser_1.Dialog.CANCEL);
        if (result && result === nls_1.nls.localizeByDefault('Sign Out') && sessionsForAccount) {
            sessionsForAccount.forEach(sessionId => this.removeSession(sessionId));
            removeAccountUsage(this.storageService, this.id, accountName);
        }
    }
    async getSessions(scopes, account) {
        return this.proxy.$getSessions(this.id, scopes, { account: account });
    }
    async updateSessionItems(event) {
        const { added, removed } = event;
        const session = await this.proxy.$getSessions(this.id, undefined, {});
        const addedSessions = added ? session.filter(s => added.some(addedSession => addedSession.id === s.id)) : [];
        removed === null || removed === void 0 ? void 0 : removed.forEach(removedSession => {
            const sessionId = removedSession.id;
            if (sessionId) {
                const accountName = this.sessions.get(sessionId);
                if (accountName) {
                    this.sessions.delete(sessionId);
                    const sessionsForAccount = this.accounts.get(accountName) || [];
                    const sessionIndex = sessionsForAccount.indexOf(sessionId);
                    sessionsForAccount.splice(sessionIndex);
                    if (!sessionsForAccount.length) {
                        this.accounts.delete(accountName);
                    }
                }
            }
        });
        addedSessions.forEach(s => this.registerSession(s));
    }
    async login(scopes, options) {
        return this.createSession(scopes, options);
    }
    async logout(sessionId) {
        return this.removeSession(sessionId);
    }
    createSession(scopes, options) {
        return this.proxy.$createSession(this.id, scopes, options);
    }
    removeSession(sessionId) {
        return this.proxy.$removeSession(this.id, sessionId)
            .then(() => {
            this.messageService.info(nls_1.nls.localize('theia/plugin-ext/authentication-main/signedOut', 'Successfully signed out.'));
        });
    }
}
exports.AuthenticationProviderImpl = AuthenticationProviderImpl;
async function readAccountUsages(storageService, providerId, accountName) {
    const accountKey = `authentication-${providerId}-${accountName}-usages`;
    const storedUsages = await storageService.getData(accountKey);
    let usages = [];
    if (storedUsages) {
        try {
            usages = JSON.parse(storedUsages);
        }
        catch (e) {
            console.log(e);
        }
    }
    return usages;
}
function removeAccountUsage(storageService, providerId, accountName) {
    const accountKey = `authentication-${providerId}-${accountName}-usages`;
    storageService.setData(accountKey, undefined);
}


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/clipboard-main.js"
/*!*******************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/clipboard-main.js ***!
  \*******************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 RedHat and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClipboardMainImpl = void 0;
const clipboard_service_1 = __webpack_require__(/*! @theia/core/lib/browser/clipboard-service */ "../../node_modules/@theia/core/lib/browser/clipboard-service.js");
class ClipboardMainImpl {
    constructor(container) {
        this.clipboardService = container.get(clipboard_service_1.ClipboardService);
    }
    async $readText() {
        const result = await this.clipboardService.readText();
        return result;
    }
    async $writeText(value) {
        await this.clipboardService.writeText(value);
    }
}
exports.ClipboardMainImpl = ClipboardMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/command-registry-main.js"
/*!**************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/command-registry-main.js ***!
  \**************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandRegistryMainImpl = exports.ArgumentProcessorContribution = void 0;
const command_1 = __webpack_require__(/*! @theia/core/lib/common/command */ "../../node_modules/@theia/core/lib/common/command.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const plugin_contribution_handler_1 = __webpack_require__(/*! ./plugin-contribution-handler */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-contribution-handler.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
exports.ArgumentProcessorContribution = Symbol('ArgumentProcessorContribution');
class CommandRegistryMainImpl {
    constructor(rpc, container) {
        this.commands = new Map();
        this.handlers = new Map();
        this.argumentProcessors = [];
        this.toDispose = new disposable_1.DisposableCollection();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.COMMAND_REGISTRY_EXT);
        this.delegate = container.get(command_1.CommandRegistry);
        this.keyBinding = container.get(browser_1.KeybindingRegistry);
        this.contributions = container.get(plugin_contribution_handler_1.PluginContributionHandler);
        container.getNamed(core_1.ContributionProvider, exports.ArgumentProcessorContribution).getContributions().forEach(processor => {
            this.registerArgumentProcessor(processor);
        });
    }
    dispose() {
        this.toDispose.dispose();
    }
    registerArgumentProcessor(processor) {
        this.argumentProcessors.push(processor);
        return disposable_1.Disposable.create(() => {
            const index = this.argumentProcessors.lastIndexOf(processor);
            if (index >= 0) {
                this.argumentProcessors.splice(index, 1);
            }
        });
    }
    $registerCommand(command) {
        const id = command.id;
        this.commands.set(id, this.contributions.registerCommand(command));
        this.toDispose.push(disposable_1.Disposable.create(() => this.$unregisterCommand(id)));
    }
    $unregisterCommand(id) {
        const command = this.commands.get(id);
        if (command) {
            command.dispose();
            this.commands.delete(id);
        }
    }
    $registerHandler(id) {
        this.handlers.set(id, this.contributions.registerCommandHandler(id, (...args) => this.proxy.$executeCommand(id, ...args.map(arg => this.argumentProcessors.reduce((currentValue, processor) => processor.processArgument(currentValue), arg)))));
        this.toDispose.push(disposable_1.Disposable.create(() => this.$unregisterHandler(id)));
    }
    $unregisterHandler(id) {
        const handler = this.handlers.get(id);
        if (handler) {
            handler.dispose();
            this.handlers.delete(id);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async $executeCommand(id, ...args) {
        if (!this.delegate.getCommand(id)) {
            throw new Error(`Command with id '${id}' is not registered.`);
        }
        try {
            return await this.delegate.executeCommand(id, ...args);
        }
        catch (e) {
            // Command handler may be not active at the moment so the error must be caught. See https://github.com/eclipse-theia/theia/pull/6687#discussion_r354810079
            if ('code' in e && e['code'] === 'NO_ACTIVE_HANDLER') {
                return;
            }
            else {
                throw e;
            }
        }
    }
    $getKeyBinding(commandId) {
        try {
            const keyBindings = this.keyBinding.getKeybindingsForCommand(commandId);
            if (keyBindings) {
                // transform inner type to CommandKeyBinding
                return Promise.resolve(keyBindings.map(keyBinding => ({ id: commandId, value: keyBinding.keybinding })));
            }
            else {
                return Promise.resolve(undefined);
            }
        }
        catch (e) {
            return Promise.reject(e);
        }
    }
    $getCommands() {
        return Promise.resolve(this.delegate.commandIds);
    }
}
exports.CommandRegistryMainImpl = CommandRegistryMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/commands.js"
/*!*************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/commands.js ***!
  \*************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OpenUriCommandHandler = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const command_1 = __webpack_require__(/*! @theia/core/lib/common/command */ "../../node_modules/@theia/core/lib/common/command.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const window_service_1 = __webpack_require__(/*! @theia/core/lib/browser/window/window-service */ "../../node_modules/@theia/core/lib/browser/window/window-service.js");
const DOMPurify = __webpack_require__(/*! @theia/core/shared/dompurify */ "../../node_modules/@theia/core/shared/dompurify/index.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../../node_modules/@theia/core/lib/common/nls.js");
let OpenUriCommandHandler = class OpenUriCommandHandler {
    constructor(windowService, commandService) {
        this.windowService = windowService;
        this.commandService = commandService;
        this.openNewTabDialog = new OpenNewTabDialog(windowService);
    }
    execute(resource) {
        if (!resource) {
            return;
        }
        const uriString = resource.toString();
        if (uriString.startsWith('http://') || uriString.startsWith('https://')) {
            this.openWebUri(uriString);
        }
        else {
            this.commandService.executeCommand('editor.action.openLink', uriString);
        }
    }
    openWebUri(uri) {
        try {
            this.windowService.openNewWindow(uri);
        }
        catch (err) {
            // browser has blocked opening of a new tab
            this.openNewTabDialog.showOpenNewTabDialog(uri);
        }
    }
};
exports.OpenUriCommandHandler = OpenUriCommandHandler;
OpenUriCommandHandler.COMMAND_METADATA = {
    id: 'theia.open'
};
exports.OpenUriCommandHandler = OpenUriCommandHandler = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(window_service_1.WindowService)),
    tslib_1.__param(1, (0, inversify_1.inject)(command_1.CommandService)),
    tslib_1.__metadata("design:paramtypes", [Object, Object])
], OpenUriCommandHandler);
class OpenNewTabDialog extends browser_1.AbstractDialog {
    constructor(windowService) {
        super({
            title: nls_1.nls.localize('theia/plugin/blockNewTab', 'Your browser prevented opening of a new tab')
        });
        this.windowService = windowService;
        this.linkNode = document.createElement('a');
        this.linkNode.target = '_blank';
        this.linkNode.setAttribute('style', 'color: var(--theia-editorWidget-foreground);');
        this.contentNode.appendChild(this.linkNode);
        const messageNode = document.createElement('div');
        messageNode.innerText = 'You are going to open: ';
        messageNode.appendChild(this.linkNode);
        this.contentNode.appendChild(messageNode);
        this.appendCloseButton();
        this.openButton = this.appendAcceptButton(nls_1.nls.localizeByDefault('Open'));
    }
    showOpenNewTabDialog(uri) {
        this.value = uri;
        this.linkNode.innerHTML = DOMPurify.sanitize(uri);
        this.linkNode.href = uri;
        this.openButton.onclick = () => {
            this.windowService.openNewWindow(uri);
        };
        // show dialog window to user
        this.open();
    }
}


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comment-glyph-widget.js"
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comment-glyph-widget.js ***!
  \**********************************************************************************************/
(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommentGlyphWidget = void 0;
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/1.49.3/src/vs/workbench/contrib/comments/browser/commentGlyphWidget.ts
class CommentGlyphWidget {
    constructor(editor) {
        this.commentsDecorations = [];
        this.commentsOptions = {
            isWholeLine: true,
            linesDecorationsClassName: 'comment-range-glyph comment-thread'
        };
        this.editor = editor;
    }
    getPosition() {
        const model = this.editor.getModel();
        const range = model && this.commentsDecorations && this.commentsDecorations.length
            ? model.getDecorationRange(this.commentsDecorations[0])
            : null;
        return range ? range.startLineNumber : this.lineNumber;
    }
    setLineNumber(lineNumber) {
        this.lineNumber = lineNumber;
        const commentsDecorations = [{
                range: {
                    startLineNumber: lineNumber, startColumn: 1,
                    endLineNumber: lineNumber, endColumn: 1
                },
                options: this.commentsOptions
            }];
        this.commentsDecorations = this.editor.deltaDecorations(this.commentsDecorations, commentsDecorations);
    }
    dispose() {
        if (this.commentsDecorations) {
            this.editor.deltaDecorations(this.commentsDecorations, []);
        }
    }
}
exports.CommentGlyphWidget = CommentGlyphWidget;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comment-thread-widget.js"
/*!***********************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comment-thread-widget.js ***!
  \***********************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommentAction = exports.CommentActions = exports.CommentsInlineAction = exports.CommentEditContainer = exports.CommentBody = exports.ReviewComment = exports.CommentForm = exports.CommentThreadWidget = exports.COMMENT_TITLE = exports.COMMENT_CONTEXT = exports.COMMENT_THREAD_CONTEXT = void 0;
// *****************************************************************************
// Copyright (C) 2020 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const monaco_editor_zone_widget_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor-zone-widget */ "../../node_modules/@theia/monaco/lib/browser/monaco-editor-zone-widget.js");
const plugin_api_rpc_model_1 = __webpack_require__(/*! ../../../common/plugin-api-rpc-model */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc-model.js");
const comment_glyph_widget_1 = __webpack_require__(/*! ./comment-glyph-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comment-glyph-widget.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../../node_modules/@theia/core/shared/react/index.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "../../node_modules/@theia/editor/lib/browser/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../../node_modules/@theia/core/lib/common/index.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const client_1 = __webpack_require__(/*! @theia/core/shared/react-dom/client */ "../../node_modules/@theia/core/shared/react-dom/client/index.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/1.49.3/src/vs/workbench/contrib/comments/browser/commentThreadWidget.ts
exports.COMMENT_THREAD_CONTEXT = ['comment_thread-context-menu'];
exports.COMMENT_CONTEXT = ['comment-context-menu'];
exports.COMMENT_TITLE = ['comment-title-menu'];
class CommentThreadWidget extends browser_1.BaseWidget {
    constructor(editor, _owner, _commentThread, commentService, menus, commentsContext, contextKeyService, commands) {
        super();
        this._owner = _owner;
        this._commentThread = _commentThread;
        this.commentService = commentService;
        this.menus = menus;
        this.commentsContext = commentsContext;
        this.contextKeyService = contextKeyService;
        this.commands = commands;
        this.commentFormRef = React.createRef();
        this.toDispose.push(this.zoneWidget = new monaco_editor_zone_widget_1.MonacoEditorZoneWidget(editor));
        this.containerNodeRoot = (0, client_1.createRoot)(this.zoneWidget.containerNode);
        this.toDispose.push(this.commentGlyphWidget = new comment_glyph_widget_1.CommentGlyphWidget(editor));
        this.toDispose.push(this._commentThread.onDidChangeCollapsibleState(state => {
            var _a, _b;
            if (state === plugin_api_rpc_model_1.CommentThreadCollapsibleState.Expanded && !this.isExpanded) {
                const lineNumber = (_b = (_a = this._commentThread.range) === null || _a === void 0 ? void 0 : _a.startLineNumber) !== null && _b !== void 0 ? _b : 0;
                this.display({ afterLineNumber: lineNumber, afterColumn: 1, heightInLines: 2 });
                return;
            }
            if (state === plugin_api_rpc_model_1.CommentThreadCollapsibleState.Collapsed && this.isExpanded) {
                this.hide();
                return;
            }
        }));
        this.commentsContext.commentIsEmpty.set(true);
        this.toDispose.push(this.zoneWidget.editor.onMouseDown(e => this.onEditorMouseDown(e)));
        this.toDispose.push(this._commentThread.onDidChangeCanReply(_canReply => {
            const commentForm = this.commentFormRef.current;
            if (commentForm) {
                commentForm.update();
            }
        }));
        this.toDispose.push(this._commentThread.onDidChangeState(_state => {
            this.update();
        }));
        const contextMenu = this.menus.getMenu(exports.COMMENT_THREAD_CONTEXT);
        contextMenu === null || contextMenu === void 0 ? void 0 : contextMenu.children.forEach(node => {
            if (node.onDidChange) {
                this.toDispose.push(node.onDidChange(() => {
                    const commentForm = this.commentFormRef.current;
                    if (commentForm) {
                        commentForm.update();
                    }
                }));
            }
        });
    }
    getGlyphPosition() {
        return this.commentGlyphWidget.getPosition();
    }
    collapse() {
        this._commentThread.collapsibleState = plugin_api_rpc_model_1.CommentThreadCollapsibleState.Collapsed;
        if (this._commentThread.comments && this._commentThread.comments.length === 0) {
            this.deleteCommentThread();
        }
        this.hide();
    }
    deleteCommentThread() {
        this.dispose();
        this.commentService.disposeCommentThread(this.owner, this._commentThread.threadId);
    }
    dispose() {
        super.dispose();
        if (this.commentGlyphWidget) {
            this.commentGlyphWidget.dispose();
        }
    }
    toggleExpand(lineNumber) {
        if (this.isExpanded) {
            this._commentThread.collapsibleState = plugin_api_rpc_model_1.CommentThreadCollapsibleState.Collapsed;
            this.hide();
            if (!this._commentThread.comments || !this._commentThread.comments.length) {
                this.deleteCommentThread();
            }
        }
        else {
            this._commentThread.collapsibleState = plugin_api_rpc_model_1.CommentThreadCollapsibleState.Expanded;
            this.display({ afterLineNumber: lineNumber, afterColumn: 1, heightInLines: 2 });
        }
    }
    hide() {
        this.zoneWidget.hide();
        this.isExpanded = false;
        super.hide();
    }
    display(options) {
        this.isExpanded = true;
        if (this._commentThread.collapsibleState && this._commentThread.collapsibleState !== plugin_api_rpc_model_1.CommentThreadCollapsibleState.Expanded) {
            return;
        }
        this.commentGlyphWidget.setLineNumber(options.afterLineNumber);
        this._commentThread.collapsibleState = plugin_api_rpc_model_1.CommentThreadCollapsibleState.Expanded;
        this.zoneWidget.show(options);
        this.update();
    }
    onEditorMouseDown(e) {
        const range = e.target.range;
        if (!range) {
            return;
        }
        if (!e.event.leftButton) {
            return;
        }
        if (e.target.type !== browser_2.MouseTargetType.GUTTER_LINE_DECORATIONS) {
            return;
        }
        const data = e.target.detail;
        const gutterOffsetX = data.offsetX - data.glyphMarginWidth - data.lineNumbersWidth - data.glyphMarginLeft;
        // don't collide with folding and git decorations
        if (gutterOffsetX > 14) {
            return;
        }
        const mouseDownInfo = { lineNumber: range.startLineNumber };
        const { lineNumber } = mouseDownInfo;
        if (!range || range.startLineNumber !== lineNumber) {
            return;
        }
        if (e.target.type !== browser_2.MouseTargetType.GUTTER_LINE_DECORATIONS) {
            return;
        }
        if (!e.target.element) {
            return;
        }
        if (this.commentGlyphWidget && this.commentGlyphWidget.getPosition() !== lineNumber) {
            return;
        }
        if (e.target.element.className.indexOf('comment-thread') >= 0) {
            this.toggleExpand(lineNumber);
            return;
        }
        if (this._commentThread.collapsibleState === plugin_api_rpc_model_1.CommentThreadCollapsibleState.Collapsed) {
            this.display({ afterLineNumber: mouseDownInfo.lineNumber, heightInLines: 2 });
        }
        else {
            this.hide();
        }
    }
    get owner() {
        return this._owner;
    }
    get commentThread() {
        return this._commentThread;
    }
    getThreadLabel() {
        let label;
        label = this._commentThread.label;
        if (label === undefined) {
            if (this._commentThread.comments && this._commentThread.comments.length) {
                const onlyUnique = (value, index, self) => self.indexOf(value) === index;
                const participantsList = this._commentThread.comments.filter(onlyUnique).map(comment => `@${comment.userName}`).join(', ');
                const resolutionState = this._commentThread.state === plugin_api_rpc_model_1.CommentThreadState.Resolved ? '(Resolved)' : '(Unresolved)';
                label = `Participants: ${participantsList} ${resolutionState}`;
            }
            else {
                label = 'Start discussion';
            }
        }
        return label;
    }
    update() {
        var _a, _b, _c;
        if (!this.isExpanded) {
            return;
        }
        this.render();
        const headHeight = Math.ceil(this.zoneWidget.editor.getOption(monaco.editor.EditorOption.lineHeight) * 1.2);
        const lineHeight = this.zoneWidget.editor.getOption(monaco.editor.EditorOption.lineHeight);
        const arrowHeight = Math.round(lineHeight / 3);
        const frameThickness = Math.round(lineHeight / 9) * 2;
        const body = this.zoneWidget.containerNode.getElementsByClassName('body')[0];
        const computedLinesNumber = Math.ceil((headHeight + ((_a = body === null || body === void 0 ? void 0 : body.clientHeight) !== null && _a !== void 0 ? _a : 0) + arrowHeight + frameThickness + 8 /** margin bottom to avoid margin collapse */)
            / lineHeight);
        this.zoneWidget.show({ afterLineNumber: (_c = (_b = this._commentThread.range) === null || _b === void 0 ? void 0 : _b.startLineNumber) !== null && _c !== void 0 ? _c : 0, heightInLines: computedLinesNumber });
    }
    render() {
        var _a;
        const headHeight = Math.ceil(this.zoneWidget.editor.getOption(monaco.editor.EditorOption.lineHeight) * 1.2);
        this.containerNodeRoot.render(React.createElement("div", { className: 'review-widget' },
            React.createElement("div", { className: 'head', style: { height: headHeight, lineHeight: `${headHeight}px` } },
                React.createElement("div", { className: 'review-title' },
                    React.createElement("span", { className: 'filename' }, this.getThreadLabel())),
                React.createElement("div", { className: 'review-actions' },
                    React.createElement("div", { className: 'monaco-action-bar animated' },
                        React.createElement("ul", { className: 'actions-container', role: 'toolbar' },
                            React.createElement("li", { className: 'action-item', role: 'presentation' },
                                React.createElement("a", { className: 'action-label codicon expand-review-action codicon-chevron-up', role: 'button', tabIndex: 0, title: 'Collapse', onClick: () => this.collapse() })))))),
            React.createElement("div", { className: 'body' },
                React.createElement("div", { className: 'comments-container', role: 'presentation', tabIndex: 0 }, (_a = this._commentThread.comments) === null || _a === void 0 ? void 0 : _a.map((comment, index) => React.createElement(ReviewComment, { key: index, contextKeyService: this.contextKeyService, commentsContext: this.commentsContext, menus: this.menus, comment: comment, commentForm: this.commentFormRef, commands: this.commands, commentThread: this._commentThread }))),
                React.createElement(CommentForm, { contextKeyService: this.contextKeyService, commentsContext: this.commentsContext, commands: this.commands, commentThread: this._commentThread, menus: this.menus, widget: this, ref: this.commentFormRef }))));
    }
}
exports.CommentThreadWidget = CommentThreadWidget;
class CommentForm extends React.Component {
    update() {
        this.setState(this.state);
    }
    componentDidMount() {
        // Wait for the widget to be rendered.
        setTimeout(() => {
            var _a;
            (_a = this.inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        }, 100);
    }
    componentWillUnmount() {
        this.toDisposeOnUnmount.dispose();
    }
    constructor(props) {
        super(props);
        this.inputRef = React.createRef();
        this.inputValue = '';
        this.getInput = () => this.inputValue;
        this.toDisposeOnUnmount = new common_1.DisposableCollection();
        this.clearInput = () => {
            const input = this.inputRef.current;
            if (input) {
                this.inputValue = '';
                input.value = this.inputValue;
                this.props.commentsContext.commentIsEmpty.set(true);
            }
        };
        this.expand = () => {
            this.setState({ expanded: true });
            // Wait for the widget to be rendered.
            setTimeout(() => {
                var _a;
                // Update the widget's height.
                this.props.widget.update();
                (_a = this.inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
            }, 100);
        };
        this.collapse = () => {
            this.setState({ expanded: false });
            // Wait for the widget to be rendered.
            setTimeout(() => {
                // Update the widget's height.
                this.props.widget.update();
            }, 100);
        };
        this.onInput = (event) => {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const value = event.target.value;
            if (this.inputValue.length === 0 || value.length === 0) {
                this.props.commentsContext.commentIsEmpty.set(value.length === 0);
            }
            this.inputValue = value;
        };
        this.state = {
            expanded: false
        };
        const setState = this.setState.bind(this);
        this.setState = newState => {
            setState(newState);
        };
    }
    /**
     * Renders the comment form with textarea, actions, and reply button.
     *
     * @returns The rendered comment form
     */
    renderCommentForm() {
        const { commentThread, commentsContext, contextKeyService, menus } = this.props;
        const hasExistingComments = commentThread.comments && commentThread.comments.length > 0;
        // Determine when to show the expanded form:
        // - When state.expanded is true (user clicked the reply button)
        // - When there are no existing comments (new thread)
        const shouldShowExpanded = this.state.expanded || (commentThread.comments && commentThread.comments.length === 0);
        return commentThread.canReply ? (React.createElement("div", { className: `comment-form${shouldShowExpanded ? ' expand' : ''}` },
            React.createElement("div", { className: 'theia-comments-input-message-container' },
                React.createElement("textarea", { className: 'theia-comments-input-message theia-input', spellCheck: false, placeholder: hasExistingComments ? 'Reply...' : 'Type a new comment', onInput: this.onInput, 
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    onBlur: (event) => {
                        if (event.target.value.length > 0) {
                            return;
                        }
                        if (event.relatedTarget && event.relatedTarget.className === 'comments-button comments-text-button theia-button') {
                            this.state = { expanded: false };
                            return;
                        }
                        this.collapse();
                    }, ref: this.inputRef })),
            React.createElement(CommentActions, { menu: menus.getMenu(exports.COMMENT_THREAD_CONTEXT), menuPath: [], contextKeyService: contextKeyService, commentsContext: commentsContext, commentThread: commentThread, getInput: this.getInput, clearInput: this.clearInput }),
            React.createElement("button", { className: 'review-thread-reply-button', title: 'Reply...', onClick: this.expand }, "Reply..."))) : null;
    }
    /**
     * Renders the author information section.
     *
     * @param authorInfo The author information to display
     * @returns The rendered author information section
     */
    renderAuthorInfo(authorInfo) {
        return (React.createElement("div", { className: 'avatar-container' }, authorInfo.iconPath && (React.createElement("img", { className: 'avatar', src: authorInfo.iconPath.toString() }))));
    }
    render() {
        const { commentThread } = this.props;
        if (!commentThread.canReply) {
            return null;
        }
        // If there's author info, wrap in a container with author info on the left
        if (isCommentAuthorInformation(commentThread.canReply)) {
            return (React.createElement("div", { className: 'review-comment' },
                this.renderAuthorInfo(commentThread.canReply),
                React.createElement("div", { className: 'review-comment-contents' },
                    React.createElement("div", { className: 'comment-title monaco-mouse-cursor-text' },
                        React.createElement("strong", { className: 'author' }, commentThread.canReply.name)),
                    this.renderCommentForm())));
        }
        // Otherwise, just return the comment form
        return (React.createElement("div", { className: 'review-comment' },
            React.createElement("div", { className: 'review-comment-contents' }, this.renderCommentForm())));
    }
}
exports.CommentForm = CommentForm;
function isCommentAuthorInformation(item) {
    return (0, common_1.isObject)(item) && 'name' in item;
}
class ReviewComment extends React.Component {
    constructor(props) {
        super(props);
        this.detectHover = (element) => {
            if (element) {
                window.requestAnimationFrame(() => {
                    const hover = element.matches(':hover');
                    this.setState({ hover });
                });
            }
        };
        this.showHover = () => this.setState({ hover: true });
        this.hideHover = () => this.setState({ hover: false });
        this.state = {
            hover: false
        };
        const setState = this.setState.bind(this);
        this.setState = newState => {
            setState(newState);
        };
    }
    render() {
        var _a;
        const { comment, commentForm, contextKeyService, commentsContext, menus, commands, commentThread } = this.props;
        const commentUniqueId = comment.uniqueIdInThread;
        const { hover } = this.state;
        commentsContext.comment.set(comment.contextValue);
        return React.createElement("div", { className: 'review-comment', tabIndex: -1, "aria-label": `${comment.userName}, ${comment.body.value}`, ref: this.detectHover, onMouseEnter: this.showHover, onMouseLeave: this.hideHover },
            React.createElement("div", { className: 'avatar-container' },
                React.createElement("img", { className: 'avatar', src: comment.userIconPath })),
            React.createElement("div", { className: 'review-comment-contents' },
                React.createElement("div", { className: 'comment-title monaco-mouse-cursor-text' },
                    React.createElement("strong", { className: 'author' }, comment.userName),
                    React.createElement("small", { className: 'timestamp' }, this.localeDate(comment.timestamp)),
                    React.createElement("span", { className: 'isPending' }, comment.label),
                    React.createElement("div", { className: 'theia-comments-inline-actions-container' },
                        React.createElement("div", { className: 'theia-comments-inline-actions', role: 'toolbar' }, hover && menus.getMenuNode(exports.COMMENT_TITLE) && ((_a = menus.getMenu(exports.COMMENT_TITLE)) === null || _a === void 0 ? void 0 : _a.children.map((node, index) => common_1.CommandMenu.is(node) &&
                            React.createElement(CommentsInlineAction, { key: index, node, nodePath: [...exports.COMMENT_TITLE, node.id], commands, commentThread, commentUniqueId,
                                contextKeyService, commentsContext })))))),
                React.createElement(CommentBody, { value: comment.body.value, isVisible: comment.mode === undefined || comment.mode === plugin_api_rpc_model_1.CommentMode.Preview }),
                React.createElement(CommentEditContainer, { contextKeyService: contextKeyService, commentsContext: commentsContext, menus: menus, comment: comment, commentThread: commentThread, commentForm: commentForm, commands: commands })));
    }
    localeDate(timestamp) {
        if (timestamp === undefined) {
            return '';
        }
        const date = new Date(timestamp);
        if (!isNaN(date.getTime())) {
            return date.toLocaleString();
        }
        return '';
    }
}
exports.ReviewComment = ReviewComment;
class CommentBody extends React.Component {
    render() {
        const { value, isVisible } = this.props;
        if (!isVisible) {
            return false;
        }
        return React.createElement("div", { className: 'comment-body monaco-mouse-cursor-text' },
            React.createElement("div", null,
                React.createElement("p", null, value)));
    }
}
exports.CommentBody = CommentBody;
class CommentEditContainer extends React.Component {
    constructor() {
        super(...arguments);
        this.inputRef = React.createRef();
    }
    componentDidUpdate(prevProps, prevState) {
        var _a;
        const commentFormState = (_a = this.props.commentForm.current) === null || _a === void 0 ? void 0 : _a.state;
        const mode = this.props.comment.mode;
        if (this.dirtyCommentMode !== mode || (this.dirtyCommentFormState !== (commentFormState === null || commentFormState === void 0 ? void 0 : commentFormState.expanded) && !(commentFormState === null || commentFormState === void 0 ? void 0 : commentFormState.expanded))) {
            const currentInput = this.inputRef.current;
            if (currentInput) {
                // Wait for the widget to be rendered.
                setTimeout(() => {
                    currentInput.focus();
                    currentInput.setSelectionRange(currentInput.value.length, currentInput.value.length);
                }, 50);
            }
        }
        this.dirtyCommentMode = mode;
        this.dirtyCommentFormState = commentFormState === null || commentFormState === void 0 ? void 0 : commentFormState.expanded;
    }
    render() {
        var _a;
        const { menus, comment, commands, commentThread, contextKeyService, commentsContext } = this.props;
        if (!(comment.mode === plugin_api_rpc_model_1.CommentMode.Editing)) {
            return false;
        }
        return React.createElement("div", { className: 'edit-container' },
            React.createElement("div", { className: 'edit-textarea' },
                React.createElement("div", { className: 'theia-comments-input-message-container' },
                    React.createElement("textarea", { className: 'theia-comments-input-message theia-input', spellCheck: false, defaultValue: comment.body.value, ref: this.inputRef }))),
            React.createElement("div", { className: 'form-actions' }, (_a = menus.getMenu(exports.COMMENT_CONTEXT)) === null || _a === void 0 ? void 0 : _a.children.map((node, index) => {
                const onClick = () => {
                    commands.executeCommand(node.id, {
                        commentControlHandle: commentThread.controllerHandle,
                        commentThreadHandle: commentThread.commentThreadHandle,
                        commentUniqueId: comment.uniqueIdInThread,
                        text: this.inputRef.current ? this.inputRef.current.value : ''
                    });
                };
                return common_1.CommandMenu.is(node) &&
                    React.createElement(CommentAction, { key: index, node, nodePath: [...exports.COMMENT_CONTEXT, node.id], comment,
                        commands, onClick, contextKeyService, commentsContext, commentThread });
            })));
    }
}
exports.CommentEditContainer = CommentEditContainer;
class CommentsInlineAction extends React.Component {
    render() {
        const { node, nodePath, commands, contextKeyService, commentThread, commentUniqueId } = this.props;
        if (node.isVisible(nodePath, contextKeyService, undefined, {
            thread: commentThread,
            commentUniqueId
        })) {
            return false;
        }
        return React.createElement("div", { className: 'theia-comments-inline-action' },
            React.createElement("a", { className: node.icon, title: node.label, onClick: () => {
                    commands.executeCommand(node.id, {
                        thread: commentThread,
                        commentUniqueId: commentUniqueId
                    });
                } }));
    }
}
exports.CommentsInlineAction = CommentsInlineAction;
class CommentActions extends React.Component {
    render() {
        const { contextKeyService, commentsContext, menuPath, menu, commentThread, getInput, clearInput } = this.props;
        return React.createElement("div", { className: 'form-actions' }, menu === null || menu === void 0 ? void 0 : menu.children.map((node, index) => common_1.CommandMenu.is(node) &&
            React.createElement(CommentAction, { key: index, nodePath: menuPath, node: node, onClick: () => {
                    node.run([...menuPath, menu.id], {
                        thread: commentThread,
                        text: getInput()
                    });
                    clearInput();
                }, commentThread: commentThread, contextKeyService: contextKeyService, commentsContext: commentsContext })));
    }
}
exports.CommentActions = CommentActions;
class CommentAction extends React.Component {
    render() {
        const classNames = ['comments-button', 'comments-text-button', 'theia-button'];
        const { node, nodePath, contextKeyService, onClick, commentThread } = this.props;
        if (!node.isVisible(nodePath, contextKeyService, undefined, {
            thread: commentThread
        })) {
            return false;
        }
        const isEnabled = node.isEnabled(nodePath, {
            thread: commentThread
        });
        if (!isEnabled) {
            classNames.push(browser_1.DISABLED_CLASS);
        }
        return React.createElement("button", { className: classNames.join(' '), tabIndex: 0, role: 'button', onClick: () => {
                if (isEnabled) {
                    onClick();
                }
            } }, node.label);
    }
}
exports.CommentAction = CommentAction;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-context.js"
/*!******************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-context.js ***!
  \******************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommentsContext = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../../node_modules/@theia/core/lib/browser/context-key-service.js");
let CommentsContext = class CommentsContext {
    constructor() {
        this.contextKeys = new Set();
    }
    get commentController() {
        return this._commentController;
    }
    get comment() {
        return this._comment;
    }
    get commentIsEmpty() {
        return this._commentIsEmpty;
    }
    init() {
        this.contextKeys.add('commentIsEmpty');
        this._commentController = this.contextKeyService.createKey('commentController', undefined);
        this._comment = this.contextKeyService.createKey('comment', undefined);
        this._commentIsEmpty = this.contextKeyService.createKey('commentIsEmpty', true);
    }
};
exports.CommentsContext = CommentsContext;
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], CommentsContext.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], CommentsContext.prototype, "init", null);
exports.CommentsContext = CommentsContext = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], CommentsContext);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-contribution.js"
/*!***********************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-contribution.js ***!
  \***********************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommentsContribution = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const comments_decorator_1 = __webpack_require__(/*! ./comments-decorator */ "../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-decorator.js");
const browser_1 = __webpack_require__(/*! @theia/editor/lib/browser */ "../../node_modules/@theia/editor/lib/browser/index.js");
const monaco_diff_editor_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-diff-editor */ "../../node_modules/@theia/monaco/lib/browser/monaco-diff-editor.js");
const comment_thread_widget_1 = __webpack_require__(/*! ./comment-thread-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comment-thread-widget.js");
const comments_service_1 = __webpack_require__(/*! ./comments-service */ "../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-service.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../../node_modules/@theia/core/lib/common/index.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../../node_modules/@theia/core/shared/vscode-uri/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../../node_modules/@theia/core/lib/browser/context-key-service.js");
const comments_context_1 = __webpack_require__(/*! ./comments-context */ "../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-context.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/1.49.3/src/vs/workbench/contrib/comments/browser/comments.contribution.ts
let CommentsContribution = class CommentsContribution {
    constructor(rangeDecorator, commentService, editorManager) {
        this.rangeDecorator = rangeDecorator;
        this.commentService = commentService;
        this.editorManager = editorManager;
        this.emptyThreadsToAddQueue = [];
        this.commentWidgets = [];
        this.commentInfos = [];
        this.commentService.onDidSetResourceCommentInfos(e => {
            const editor = this.getCurrentEditor();
            const editorURI = editor && editor.editor instanceof monaco_diff_editor_1.MonacoDiffEditor && editor.editor.diffEditor.getModifiedEditor().getModel();
            if (editorURI && editorURI.toString() === e.resource.toString()) {
                this.setComments(e.commentInfos.filter(commentInfo => commentInfo !== null));
            }
        });
        this.editorManager.onCreated(async (widget) => {
            const disposables = new common_1.DisposableCollection();
            const editor = widget.editor;
            if (editor instanceof monaco_diff_editor_1.MonacoDiffEditor) {
                const originalEditorModel = editor.diffEditor.getOriginalEditor().getModel();
                if (originalEditorModel) {
                    // need to cast because of vscode issue https://github.com/microsoft/vscode/issues/190584
                    const originalComments = await this.commentService.getComments(originalEditorModel.uri);
                    if (originalComments) {
                        this.rangeDecorator.update(editor.diffEditor.getOriginalEditor(), originalComments.filter(c => !!c));
                    }
                }
                const modifiedEditorModel = editor.diffEditor.getModifiedEditor().getModel();
                if (modifiedEditorModel) {
                    // need to cast because of vscode issue https://github.com/microsoft/vscode/issues/190584
                    const modifiedComments = await this.commentService.getComments(modifiedEditorModel.uri);
                    if (modifiedComments) {
                        this.rangeDecorator.update(editor.diffEditor.getModifiedEditor(), modifiedComments.filter(c => !!c));
                    }
                }
                disposables.push(editor.onMouseDown(e => this.onEditorMouseDown(e)));
                disposables.push(this.commentService.onDidUpdateCommentThreads(async (e) => {
                    const editorURI = editor.document.uri;
                    const commentInfo = this.commentInfos.filter(info => info.owner === e.owner);
                    if (!commentInfo || !commentInfo.length) {
                        return;
                    }
                    const added = e.added.filter(thread => thread.resource && thread.resource.toString() === editorURI.toString());
                    const removed = e.removed.filter(thread => thread.resource && thread.resource.toString() === editorURI.toString());
                    const changed = e.changed.filter(thread => thread.resource && thread.resource.toString() === editorURI.toString());
                    removed.forEach(thread => {
                        const matchedZones = this.commentWidgets.filter(zoneWidget => zoneWidget.owner === e.owner
                            && zoneWidget.commentThread.threadId === thread.threadId && zoneWidget.commentThread.threadId !== '');
                        if (matchedZones.length) {
                            const matchedZone = matchedZones[0];
                            const index = this.commentWidgets.indexOf(matchedZone);
                            this.commentWidgets.splice(index, 1);
                            matchedZone.dispose();
                        }
                    });
                    changed.forEach(thread => {
                        const matchedZones = this.commentWidgets.filter(zoneWidget => zoneWidget.owner === e.owner
                            && zoneWidget.commentThread.threadId === thread.threadId);
                        if (matchedZones.length) {
                            const matchedZone = matchedZones[0];
                            matchedZone.update();
                        }
                    });
                    added.forEach(thread => {
                        this.displayCommentThread(e.owner, thread);
                        this.commentInfos.filter(info => info.owner === e.owner)[0].threads.push(thread);
                    });
                }));
                editor.onDispose(() => {
                    disposables.dispose();
                });
                this.beginCompute();
            }
        });
    }
    onEditorMouseDown(e) {
        let mouseDownInfo = null;
        const range = e.target.range;
        if (!range) {
            return;
        }
        if (e.target.type !== monaco.editor.MouseTargetType.GUTTER_LINE_DECORATIONS) {
            return;
        }
        const data = e.target.detail;
        const gutterOffsetX = data.offsetX - data.glyphMarginWidth - data.lineNumbersWidth - data.glyphMarginLeft;
        // don't collide with folding and git decorations
        if (gutterOffsetX > 14) {
            return;
        }
        mouseDownInfo = { lineNumber: range.start };
        const { lineNumber } = mouseDownInfo;
        mouseDownInfo = null;
        if (!range || range.start !== lineNumber) {
            return;
        }
        if (!e.target.element) {
            return;
        }
        if (e.target.element.className.indexOf('comment-diff-added') >= 0) {
            this.addOrToggleCommentAtLine(e.target.position.line + 1, e);
        }
    }
    async beginCompute() {
        const editorModel = this.editor && this.editor.getModel();
        const editorURI = this.editor && editorModel && editorModel.uri;
        if (editorURI) {
            // need to cast because of vscode issue https://github.com/microsoft/vscode/issues/190584
            const comments = await this.commentService.getComments(editorURI);
            this.setComments(comments.filter(c => !!c));
        }
    }
    setComments(commentInfos) {
        if (!this.editor) {
            return;
        }
        this.commentInfos = commentInfos;
    }
    get editor() {
        const editor = this.getCurrentEditor();
        if (editor && editor.editor instanceof monaco_diff_editor_1.MonacoDiffEditor) {
            return editor.editor.diffEditor.getModifiedEditor();
        }
    }
    displayCommentThread(owner, thread) {
        var _a;
        const editor = this.editor;
        if (editor) {
            const provider = this.commentService.getCommentController(owner);
            if (provider) {
                this.commentsContext.commentController.set(provider.id);
            }
            const zoneWidget = new comment_thread_widget_1.CommentThreadWidget(editor, owner, thread, this.commentService, this.menus, this.commentsContext, this.contextKeyService, this.commands);
            zoneWidget.display({ afterLineNumber: ((_a = thread.range) === null || _a === void 0 ? void 0 : _a.startLineNumber) || 0, heightInLines: 5 });
            const currentEditor = this.getCurrentEditor();
            if (currentEditor) {
                currentEditor.onDispose(() => zoneWidget.dispose());
            }
            this.commentWidgets.push(zoneWidget);
        }
    }
    async addOrToggleCommentAtLine(lineNumber, e) {
        // If an add is already in progress, queue the next add and process it after the current one finishes to
        // prevent empty comment threads from being added to the same line.
        if (!this.addInProgress) {
            this.addInProgress = true;
            // The widget's position is undefined until the widget has been displayed, so rely on the glyph position instead
            const existingCommentsAtLine = this.commentWidgets.filter(widget => widget.getGlyphPosition() === lineNumber);
            if (existingCommentsAtLine.length) {
                existingCommentsAtLine.forEach(widget => widget.toggleExpand(lineNumber));
                this.processNextThreadToAdd();
                return;
            }
            else {
                this.addCommentAtLine(lineNumber, e);
            }
        }
        else {
            this.emptyThreadsToAddQueue.push([lineNumber, e]);
        }
    }
    processNextThreadToAdd() {
        this.addInProgress = false;
        const info = this.emptyThreadsToAddQueue.shift();
        if (info) {
            this.addOrToggleCommentAtLine(info[0], info[1]);
        }
    }
    getCurrentEditor() {
        return this.editorManager.currentEditor;
    }
    addCommentAtLine(lineNumber, e) {
        const newCommentInfos = this.rangeDecorator.getMatchedCommentAction(lineNumber);
        const editor = this.getCurrentEditor();
        if (!editor) {
            return Promise.resolve();
        }
        if (!newCommentInfos.length) {
            return Promise.resolve();
        }
        const { ownerId } = newCommentInfos[0];
        this.addCommentAtLine2(lineNumber, ownerId);
        return Promise.resolve();
    }
    addCommentAtLine2(lineNumber, ownerId) {
        const editorModel = this.editor && this.editor.getModel();
        const editorURI = this.editor && editorModel && editorModel.uri;
        if (editorURI) {
            this.commentService.createCommentThreadTemplate(ownerId, vscode_uri_1.URI.parse(editorURI.toString()), {
                startLineNumber: lineNumber,
                endLineNumber: lineNumber,
                startColumn: 1,
                endColumn: 1
            });
            this.processNextThreadToAdd();
        }
    }
};
exports.CommentsContribution = CommentsContribution;
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.MenuModelRegistry),
    tslib_1.__metadata("design:type", common_1.MenuModelRegistry)
], CommentsContribution.prototype, "menus", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(comments_context_1.CommentsContext),
    tslib_1.__metadata("design:type", comments_context_1.CommentsContext)
], CommentsContribution.prototype, "commentsContext", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], CommentsContribution.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.CommandRegistry),
    tslib_1.__metadata("design:type", common_1.CommandRegistry)
], CommentsContribution.prototype, "commands", void 0);
exports.CommentsContribution = CommentsContribution = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(comments_decorator_1.CommentingRangeDecorator)),
    tslib_1.__param(1, (0, inversify_1.inject)(comments_service_1.CommentsService)),
    tslib_1.__param(2, (0, inversify_1.inject)(browser_1.EditorManager)),
    tslib_1.__metadata("design:paramtypes", [comments_decorator_1.CommentingRangeDecorator, Object, browser_1.EditorManager])
], CommentsContribution);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-decorator.js"
/*!********************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-decorator.js ***!
  \********************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommentingRangeDecorator = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
let CommentingRangeDecorator = class CommentingRangeDecorator {
    constructor() {
        this.commentingRangeDecorations = [];
        this.decorationOptions = {
            isWholeLine: true,
            linesDecorationsClassName: 'comment-range-glyph comment-diff-added'
        };
    }
    update(editor, commentInfos) {
        const model = editor.getModel();
        if (!model) {
            return;
        }
        const commentingRangeDecorations = [];
        for (const info of commentInfos) {
            info.commentingRanges.ranges.forEach(range => {
                commentingRangeDecorations.push(new CommentingRangeDecoration(editor, info.owner, info.extensionId, info.label, range, this.decorationOptions, info.commentingRanges));
            });
        }
        const oldDecorations = this.commentingRangeDecorations.map(decoration => decoration.id);
        editor.deltaDecorations(oldDecorations, []);
        this.commentingRangeDecorations = commentingRangeDecorations;
    }
    getMatchedCommentAction(line) {
        const result = [];
        for (const decoration of this.commentingRangeDecorations) {
            const range = decoration.getActiveRange();
            if (range && range.startLineNumber <= line && line <= range.endLineNumber) {
                result.push(decoration.getCommentAction());
            }
        }
        return result;
    }
};
exports.CommentingRangeDecorator = CommentingRangeDecorator;
exports.CommentingRangeDecorator = CommentingRangeDecorator = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], CommentingRangeDecorator);
class CommentingRangeDecoration {
    get id() {
        return this.decorationId;
    }
    constructor(_editor, _ownerId, _extensionId, _label, _range, commentingOptions, commentingRangesInfo) {
        this._editor = _editor;
        this._ownerId = _ownerId;
        this._extensionId = _extensionId;
        this._label = _label;
        this._range = _range;
        this.commentingRangesInfo = commentingRangesInfo;
        const startLineNumber = _range.startLineNumber;
        const endLineNumber = _range.endLineNumber;
        const commentingRangeDecorations = [{
                range: {
                    startLineNumber: startLineNumber, startColumn: 1,
                    endLineNumber: endLineNumber, endColumn: 1
                },
                options: commentingOptions
            }];
        this.decorationId = this._editor.deltaDecorations([], commentingRangeDecorations)[0];
    }
    getCommentAction() {
        return {
            extensionId: this._extensionId,
            label: this._label,
            ownerId: this._ownerId,
            commentingRangesInfo: this.commentingRangesInfo
        };
    }
    getOriginalRange() {
        return this._range;
    }
    getActiveRange() {
        const range = this._editor.getModel().getDecorationRange(this.decorationId);
        if (range) {
            return range;
        }
    }
}


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-main.js"
/*!***************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-main.js ***!
  \***************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommentsMainImp = exports.CommentController = exports.CommentThreadImpl = void 0;
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../node_modules/@theia/core/lib/common/event.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const comments_service_1 = __webpack_require__(/*! ./comments-service */ "../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-service.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../../node_modules/@theia/core/shared/vscode-uri/index.js");
const uuid_1 = __webpack_require__(/*! @theia/core/lib/common/uuid */ "../../node_modules/@theia/core/lib/common/uuid.js");
const comments_contribution_1 = __webpack_require__(/*! ./comments-contribution */ "../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-contribution.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/1.49.3/src/vs/workbench/api/browser/mainThreadComments.ts
class CommentThreadImpl {
    get input() {
        return this._input;
    }
    set input(value) {
        this._input = value;
        this.onDidChangeInputEmitter.fire(value);
    }
    get onDidChangeInput() { return this.onDidChangeInputEmitter.event; }
    get label() {
        return this._label;
    }
    set label(label) {
        this._label = label;
        this.onDidChangeLabelEmitter.fire(this._label);
    }
    get contextValue() {
        return this._contextValue;
    }
    set contextValue(context) {
        this._contextValue = context;
    }
    get comments() {
        return this._comments;
    }
    set comments(newComments) {
        this._comments = newComments;
        this.onDidChangeCommentsEmitter.fire(this._comments);
    }
    get onDidChangeComments() { return this.onDidChangeCommentsEmitter.event; }
    set range(range) {
        this._range = range;
        this.onDidChangeRangeEmitter.fire(this._range);
    }
    get range() {
        return this._range;
    }
    get collapsibleState() {
        return this._collapsibleState;
    }
    set collapsibleState(newState) {
        this._collapsibleState = newState;
        this.onDidChangeCollapsibleStateEmitter.fire(this._collapsibleState);
    }
    get state() {
        return this._state;
    }
    set state(newState) {
        if (this._state !== newState) {
            this._state = newState;
            this.onDidChangeStateEmitter.fire(this._state);
        }
    }
    get isDisposed() {
        return this._isDisposed;
    }
    get canReply() {
        return this._canReply;
    }
    set canReply(canReply) {
        this._canReply = canReply;
        this.onDidChangeCanReplyEmitter.fire(this._canReply);
    }
    constructor(commentThreadHandle, controllerHandle, extensionId, threadId, resource, _range) {
        this.commentThreadHandle = commentThreadHandle;
        this.controllerHandle = controllerHandle;
        this.extensionId = extensionId;
        this.threadId = threadId;
        this.resource = resource;
        this._range = _range;
        this.onDidChangeInputEmitter = new event_1.Emitter();
        this.onDidChangeLabelEmitter = new event_1.Emitter();
        this.onDidChangeLabel = this.onDidChangeLabelEmitter.event;
        this.onDidChangeCommentsEmitter = new event_1.Emitter();
        this.onDidChangeRangeEmitter = new event_1.Emitter();
        this.onDidChangeRange = this.onDidChangeRangeEmitter.event;
        this.onDidChangeCollapsibleStateEmitter = new event_1.Emitter();
        this.onDidChangeCollapsibleState = this.onDidChangeCollapsibleStateEmitter.event;
        this.onDidChangeStateEmitter = new event_1.Emitter();
        this.onDidChangeState = this.onDidChangeStateEmitter.event;
        this.onDidChangeCanReplyEmitter = new event_1.Emitter();
        this.onDidChangeCanReply = this.onDidChangeCanReplyEmitter.event;
        this._canReply = true;
        this._isDisposed = false;
    }
    batchUpdate(changes) {
        const modified = (value) => Object.prototype.hasOwnProperty.call(changes, value);
        if (modified('range')) {
            this._range = changes.range;
        }
        if (modified('label')) {
            this._label = changes.label;
        }
        if (modified('contextValue')) {
            this._contextValue = changes.contextValue;
        }
        if (modified('comments')) {
            this._comments = changes.comments;
        }
        if (modified('collapseState')) {
            this._collapsibleState = changes.collapseState;
        }
        if (modified('state')) {
            this._state = changes.state;
        }
        if (modified('canReply')) {
            this._canReply = changes.canReply;
        }
    }
    dispose() {
        this._isDisposed = true;
        this.onDidChangeCollapsibleStateEmitter.dispose();
        this.onDidChangeStateEmitter.dispose();
        this.onDidChangeCommentsEmitter.dispose();
        this.onDidChangeInputEmitter.dispose();
        this.onDidChangeLabelEmitter.dispose();
        this.onDidChangeRangeEmitter.dispose();
        this.onDidChangeCanReplyEmitter.dispose();
    }
}
exports.CommentThreadImpl = CommentThreadImpl;
class CommentController {
    get handle() {
        return this._handle;
    }
    get id() {
        return this._id;
    }
    get contextValue() {
        return this._id;
    }
    get proxy() {
        return this._proxy;
    }
    get label() {
        return this._label;
    }
    get options() {
        return this._features.options;
    }
    get features() {
        return this._features;
    }
    constructor(_proxy, _commentService, _handle, _uniqueId, _id, _label, _features) {
        this._proxy = _proxy;
        this._commentService = _commentService;
        this._handle = _handle;
        this._uniqueId = _uniqueId;
        this._id = _id;
        this._label = _label;
        this._features = _features;
        this.threads = new Map();
    }
    updateFeatures(features) {
        this._features = features;
    }
    createCommentThread(extensionId, commentThreadHandle, threadId, resource, range) {
        const thread = new CommentThreadImpl(commentThreadHandle, this.handle, extensionId, threadId, vscode_uri_1.URI.revive(resource).toString(), range);
        this.threads.set(commentThreadHandle, thread);
        this._commentService.updateComments(this._uniqueId, {
            added: [thread],
            removed: [],
            changed: []
        });
        return thread;
    }
    updateCommentThread(commentThreadHandle, threadId, resource, changes) {
        const thread = this.getKnownThread(commentThreadHandle);
        thread.batchUpdate(changes);
        this._commentService.updateComments(this._uniqueId, {
            added: [],
            removed: [],
            changed: [thread]
        });
    }
    deleteCommentThread(commentThreadHandle) {
        const thread = this.getKnownThread(commentThreadHandle);
        this.threads.delete(commentThreadHandle);
        this._commentService.updateComments(this._uniqueId, {
            added: [],
            removed: [thread],
            changed: []
        });
        thread.dispose();
    }
    deleteCommentThreadMain(commentThreadId) {
        this.threads.forEach(thread => {
            if (thread.threadId === commentThreadId) {
                this._proxy.$deleteCommentThread(this._handle, thread.commentThreadHandle);
            }
        });
    }
    updateInput(input) {
        const thread = this.activeCommentThread;
        if (thread && thread.input) {
            const commentInput = thread.input;
            commentInput.value = input;
            thread.input = commentInput;
        }
    }
    getKnownThread(commentThreadHandle) {
        const thread = this.threads.get(commentThreadHandle);
        if (!thread) {
            throw new Error('unknown thread');
        }
        return thread;
    }
    async getDocumentComments(resource, token) {
        const ret = [];
        for (const thread of [...this.threads.keys()]) {
            const commentThread = this.threads.get(thread);
            if (commentThread.resource === resource.toString()) {
                ret.push(commentThread);
            }
        }
        const commentingRanges = await this._proxy.$provideCommentingRanges(this.handle, resource, token);
        return {
            owner: this._uniqueId,
            label: this.label,
            threads: ret,
            commentingRanges: {
                resource: resource,
                ranges: (commentingRanges === null || commentingRanges === void 0 ? void 0 : commentingRanges.ranges) || [],
                fileComments: !!(commentingRanges === null || commentingRanges === void 0 ? void 0 : commentingRanges.fileComments)
            }
        };
    }
    async getCommentingRanges(resource, token) {
        const commentingRanges = await this._proxy.$provideCommentingRanges(this.handle, resource, token);
        return commentingRanges;
    }
    getAllComments() {
        const ret = [];
        for (const thread of [...this.threads.keys()]) {
            ret.push(this.threads.get(thread));
        }
        return ret;
    }
    createCommentThreadTemplate(resource, range) {
        this._proxy.$createCommentThreadTemplate(this.handle, resource, range);
    }
    async updateCommentThreadTemplate(threadHandle, range) {
        await this._proxy.$updateCommentThreadTemplate(this.handle, threadHandle, range);
    }
}
exports.CommentController = CommentController;
class CommentsMainImp {
    constructor(rpc, container) {
        this.documentProviders = new Map();
        this.workspaceProviders = new Map();
        this.handlers = new Map();
        this.commentControllers = new Map();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.COMMENTS_EXT);
        container.get(comments_contribution_1.CommentsContribution);
        this.commentService = container.get(comments_service_1.CommentsService);
        this.commentService.onDidChangeActiveCommentThread(async (thread) => {
            const handle = thread.controllerHandle;
            const controller = this.commentControllers.get(handle);
            if (!controller) {
                return;
            }
            this.activeCommentThread = thread;
            controller.activeCommentThread = this.activeCommentThread;
        });
    }
    $registerCommentController(handle, id, label) {
        const providerId = (0, uuid_1.generateUuid)();
        this.handlers.set(handle, providerId);
        const provider = new CommentController(this.proxy, this.commentService, handle, providerId, id, label, {});
        this.commentService.registerCommentController(providerId, provider);
        this.commentControllers.set(handle, provider);
        this.commentService.setWorkspaceComments(String(handle), []);
    }
    $unregisterCommentController(handle) {
        const providerId = this.handlers.get(handle);
        if (typeof providerId !== 'string') {
            throw new Error('unknown handler');
        }
        this.commentService.unregisterCommentController(providerId);
        this.handlers.delete(handle);
        this.commentControllers.delete(handle);
    }
    $updateCommentControllerFeatures(handle, features) {
        const provider = this.commentControllers.get(handle);
        if (!provider) {
            return undefined;
        }
        provider.updateFeatures(features);
    }
    $createCommentThread(handle, commentThreadHandle, threadId, resource, range, extensionId) {
        const provider = this.commentControllers.get(handle);
        if (!provider) {
            return undefined;
        }
        return provider.createCommentThread(extensionId, commentThreadHandle, threadId, resource, range);
    }
    $updateCommentThread(handle, commentThreadHandle, threadId, resource, changes) {
        const provider = this.commentControllers.get(handle);
        if (!provider) {
            return undefined;
        }
        return provider.updateCommentThread(commentThreadHandle, threadId, resource, changes);
    }
    $deleteCommentThread(handle, commentThreadHandle) {
        const provider = this.commentControllers.get(handle);
        if (!provider) {
            return;
        }
        return provider.deleteCommentThread(commentThreadHandle);
    }
    getHandler(handle) {
        if (!this.handlers.has(handle)) {
            throw new Error('Unknown handler');
        }
        return this.handlers.get(handle);
    }
    $onDidCommentThreadsChange(handle, event) {
        const providerId = this.getHandler(handle);
        this.commentService.updateComments(providerId, event);
    }
    dispose() {
        this.workspaceProviders.forEach(value => value.dispose());
        this.workspaceProviders.clear();
        this.documentProviders.forEach(value => value.dispose());
        this.documentProviders.clear();
    }
}
exports.CommentsMainImp = CommentsMainImp;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-service.js"
/*!******************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-service.js ***!
  \******************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginCommentService = exports.CommentsService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../node_modules/@theia/core/lib/common/event.js");
const cancellation_1 = __webpack_require__(/*! @theia/core/lib/common/cancellation */ "../../node_modules/@theia/core/lib/common/cancellation.js");
exports.CommentsService = Symbol('CommentsService');
let PluginCommentService = class PluginCommentService {
    constructor() {
        this.onDidSetDataProviderEmitter = new event_1.Emitter();
        this.onDidSetDataProvider = this.onDidSetDataProviderEmitter.event;
        this.onDidDeleteDataProviderEmitter = new event_1.Emitter();
        this.onDidDeleteDataProvider = this.onDidDeleteDataProviderEmitter.event;
        this.onDidSetResourceCommentInfosEmitter = new event_1.Emitter();
        this.onDidSetResourceCommentInfos = this.onDidSetResourceCommentInfosEmitter.event;
        this.onDidSetAllCommentThreadsEmitter = new event_1.Emitter();
        this.onDidSetAllCommentThreads = this.onDidSetAllCommentThreadsEmitter.event;
        this.onDidUpdateCommentThreadsEmitter = new event_1.Emitter();
        this.onDidUpdateCommentThreads = this.onDidUpdateCommentThreadsEmitter.event;
        this.onDidChangeActiveCommentThreadEmitter = new event_1.Emitter();
        this.onDidChangeActiveCommentThread = this.onDidChangeActiveCommentThreadEmitter.event;
        this.onDidChangeActiveCommentingRangeEmitter = new event_1.Emitter();
        this.onDidChangeActiveCommentingRange = this.onDidChangeActiveCommentingRangeEmitter.event;
        this.commentControls = new Map();
    }
    setActiveCommentThread(commentThread) {
        this.onDidChangeActiveCommentThreadEmitter.fire(commentThread);
    }
    setDocumentComments(resource, commentInfos) {
        this.onDidSetResourceCommentInfosEmitter.fire({ resource, commentInfos });
    }
    setWorkspaceComments(owner, commentsByResource) {
        this.onDidSetAllCommentThreadsEmitter.fire({ ownerId: owner, commentThreads: commentsByResource });
    }
    removeWorkspaceComments(owner) {
        this.onDidSetAllCommentThreadsEmitter.fire({ ownerId: owner, commentThreads: [] });
    }
    registerCommentController(owner, commentControl) {
        this.commentControls.set(owner, commentControl);
        this.onDidSetDataProviderEmitter.fire();
    }
    unregisterCommentController(owner) {
        this.commentControls.delete(owner);
        this.onDidDeleteDataProviderEmitter.fire(owner);
    }
    getCommentController(owner) {
        return this.commentControls.get(owner);
    }
    createCommentThreadTemplate(owner, resource, range) {
        const commentController = this.commentControls.get(owner);
        if (!commentController) {
            return;
        }
        commentController.createCommentThreadTemplate(resource, range);
    }
    async updateCommentThreadTemplate(owner, threadHandle, range) {
        const commentController = this.commentControls.get(owner);
        if (!commentController) {
            return;
        }
        await commentController.updateCommentThreadTemplate(threadHandle, range);
    }
    disposeCommentThread(owner, threadId) {
        const controller = this.getCommentController(owner);
        if (controller) {
            controller.deleteCommentThreadMain(threadId);
        }
    }
    updateComments(ownerId, event) {
        const evt = Object.assign({}, event, { owner: ownerId });
        this.onDidUpdateCommentThreadsEmitter.fire(evt);
    }
    async getComments(resource) {
        const commentControlResult = [];
        this.commentControls.forEach(control => {
            commentControlResult.push(control.getDocumentComments(resource, cancellation_1.CancellationToken.None)
                .catch(e => {
                console.log(e);
                return null;
            }));
        });
        return Promise.all(commentControlResult);
    }
    async getCommentingRanges(resource) {
        const commentControlResult = [];
        this.commentControls.forEach(control => {
            commentControlResult.push(control.getCommentingRanges(resource, cancellation_1.CancellationToken.None));
        });
        const ret = await Promise.all(commentControlResult);
        return ret.reduce((prev, curr) => {
            if (curr) {
                prev.push(...curr.ranges);
            }
            return prev;
        }, []);
    }
};
exports.PluginCommentService = PluginCommentService;
exports.PluginCommentService = PluginCommentService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginCommentService);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-opener.js"
/*!****************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-opener.js ***!
  \****************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 SAP SE or an SAP affiliate company and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CustomEditorOpener = void 0;
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const common_1 = __webpack_require__(/*! ../../../common */ "../../node_modules/@theia/plugin-ext/lib/common/index.js");
const custom_editor_widget_1 = __webpack_require__(/*! ./custom-editor-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-widget.js");
const uuid_1 = __webpack_require__(/*! @theia/core/lib/common/uuid */ "../../node_modules/@theia/core/lib/common/uuid.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const glob_1 = __webpack_require__(/*! @theia/core/lib/common/glob */ "../../node_modules/@theia/core/lib/common/glob.js");
class CustomEditorOpener {
    constructor(editor, shell, widgetManager, editorRegistry, preferenceService) {
        this.editor = editor;
        this.shell = shell;
        this.widgetManager = widgetManager;
        this.editorRegistry = editorRegistry;
        this.preferenceService = preferenceService;
        this.onDidOpenCustomEditorEmitter = new core_1.Emitter();
        this.onDidOpenCustomEditor = this.onDidOpenCustomEditorEmitter.event;
        this.pendingWidgetPromises = new Map();
        this.id = CustomEditorOpener.toCustomEditorId(this.editor.viewType);
        this.label = this.editor.displayName;
    }
    static toCustomEditorId(editorViewType) {
        return `custom-editor-${editorViewType}`;
    }
    canHandle(uri, options) {
        let priority = 0;
        const { selector } = this.editor;
        if (browser_1.DiffUris.isDiffUri(uri)) {
            const [left, right] = browser_1.DiffUris.decode(uri);
            if (this.matches(selector, right) && this.matches(selector, left)) {
                if ((0, browser_1.getDefaultHandler)(right, this.preferenceService) === this.editor.viewType) {
                    priority = browser_1.defaultHandlerPriority;
                }
                else {
                    priority = this.getPriority();
                }
            }
        }
        else if (this.matches(selector, uri)) {
            if ((0, browser_1.getDefaultHandler)(uri, this.preferenceService) === this.editor.viewType) {
                priority = browser_1.defaultHandlerPriority;
            }
            else {
                priority = this.getPriority();
            }
        }
        return priority;
    }
    canOpenWith(uri) {
        if (this.matches(this.editor.selector, uri)) {
            return this.getPriority();
        }
        return 0;
    }
    getPriority() {
        switch (this.editor.priority) {
            case common_1.CustomEditorPriority.default: return 500;
            case common_1.CustomEditorPriority.builtin: return 400;
            /** `option` should not open the custom-editor by default. */
            case common_1.CustomEditorPriority.option: return 1;
            default: return 200;
        }
    }
    async openCustomEditor(uri, options) {
        let widget;
        let isNewWidget = false;
        const uriString = uri.toString();
        let widgetPromise = this.pendingWidgetPromises.get(uriString);
        if (widgetPromise) {
            widget = await widgetPromise;
        }
        else {
            const widgets = this.widgetManager.getWidgets(custom_editor_widget_1.CustomEditorWidget.FACTORY_ID);
            widget = widgets.find(w => w.viewType === this.editor.viewType && w.resource.toString() === uriString);
            if (!widget) {
                isNewWidget = true;
                const id = (0, uuid_1.generateUuid)();
                widgetPromise = this.widgetManager.getOrCreateWidget(custom_editor_widget_1.CustomEditorWidget.FACTORY_ID, { id }).then(async (w) => {
                    try {
                        w.viewType = this.editor.viewType;
                        w.resource = uri;
                        await this.editorRegistry.resolveWidget(w);
                        if (options === null || options === void 0 ? void 0 : options.widgetOptions) {
                            await this.shell.addWidget(w, options.widgetOptions);
                        }
                        return w;
                    }
                    catch (e) {
                        w.dispose();
                        throw e;
                    }
                }).finally(() => this.pendingWidgetPromises.delete(uriString));
                this.pendingWidgetPromises.set(uriString, widgetPromise);
                widget = await widgetPromise;
            }
        }
        if ((options === null || options === void 0 ? void 0 : options.mode) === 'activate') {
            await this.shell.activateWidget(widget.id);
        }
        else if ((options === null || options === void 0 ? void 0 : options.mode) === 'reveal') {
            await this.shell.revealWidget(widget.id);
        }
        if (isNewWidget) {
            this.onDidOpenCustomEditorEmitter.fire([widget, options]);
        }
        return widget;
    }
    async openSideBySide(uri, options) {
        const [leftUri, rightUri] = browser_1.DiffUris.decode(uri);
        const widget = await this.widgetManager.getOrCreateWidget(custom_editor_widget_1.CustomEditorWidget.SIDE_BY_SIDE_FACTORY_ID, { uri: uri.toString(), viewType: this.editor.viewType });
        if (!widget.panes.length) { // a new widget
            const trackedDisposables = new core_1.DisposableCollection(widget);
            try {
                const createPane = async (paneUri) => {
                    let pane = await this.openCustomEditor(paneUri);
                    if (pane.isAttached) {
                        await this.shell.closeWidget(pane.id);
                        if (!pane.isDisposed) { // user canceled
                            return undefined;
                        }
                        pane = await this.openCustomEditor(paneUri);
                    }
                    return pane;
                };
                const rightPane = await createPane(rightUri);
                if (!rightPane) {
                    trackedDisposables.dispose();
                    return undefined;
                }
                trackedDisposables.push(rightPane);
                const leftPane = await createPane(leftUri);
                if (!leftPane) {
                    trackedDisposables.dispose();
                    return undefined;
                }
                trackedDisposables.push(leftPane);
                widget.addPane(leftPane);
                widget.addPane(rightPane);
                // dispose the widget if either of its panes gets externally disposed
                leftPane.disposed.connect(() => widget.dispose());
                rightPane.disposed.connect(() => widget.dispose());
                if (options === null || options === void 0 ? void 0 : options.widgetOptions) {
                    await this.shell.addWidget(widget, options.widgetOptions);
                }
            }
            catch (e) {
                trackedDisposables.dispose();
                console.error(e);
                throw e;
            }
        }
        if ((options === null || options === void 0 ? void 0 : options.mode) === 'activate') {
            await this.shell.activateWidget(widget.id);
        }
        else if ((options === null || options === void 0 ? void 0 : options.mode) === 'reveal') {
            await this.shell.revealWidget(widget.id);
        }
        return widget;
    }
    async open(uri, options) {
        var _a, _b;
        options = { ...options };
        (_a = options.mode) !== null && _a !== void 0 ? _a : (options.mode = 'activate');
        (_b = options.widgetOptions) !== null && _b !== void 0 ? _b : (options.widgetOptions = { area: 'main' });
        return browser_1.DiffUris.isDiffUri(uri) ? this.openSideBySide(uri, options) : this.openCustomEditor(uri, options);
    }
    matches(selectors, resource) {
        return selectors.some(selector => this.selectorMatches(selector, resource));
    }
    selectorMatches(selector, resource) {
        if (selector.filenamePattern) {
            if ((0, glob_1.match)(selector.filenamePattern.toLowerCase(), resource.path.name.toLowerCase() + resource.path.ext.toLowerCase())) {
                return true;
            }
        }
        return false;
    }
}
exports.CustomEditorOpener = CustomEditorOpener;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-service.js"
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-service.js ***!
  \*****************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 SAP SE or an SAP affiliate company and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// copied and modified from https://github.com/microsoft/vscode/blob/53eac52308c4611000a171cc7bf1214293473c78/src/vs/workbench/contrib/customEditor/browser/customEditors.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.once = exports.CustomEditorModelManager = exports.CustomEditorService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
let CustomEditorService = class CustomEditorService {
    constructor() {
        this._models = new CustomEditorModelManager();
    }
    get models() { return this._models; }
};
exports.CustomEditorService = CustomEditorService;
exports.CustomEditorService = CustomEditorService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], CustomEditorService);
class CustomEditorModelManager {
    constructor() {
        this.references = new Map();
    }
    add(resource, viewType, model) {
        const key = this.key(resource, viewType);
        const existing = this.references.get(key);
        if (existing) {
            throw new Error('Model already exists');
        }
        this.references.set(key, { viewType, model, counter: 0 });
        return this.tryRetain(resource, viewType);
    }
    async get(resource, viewType) {
        const key = this.key(resource, viewType);
        const entry = this.references.get(key);
        return entry === null || entry === void 0 ? void 0 : entry.model;
    }
    tryRetain(resource, viewType) {
        const key = this.key(resource, viewType);
        const entry = this.references.get(key);
        if (!entry) {
            return undefined;
        }
        entry.counter++;
        return entry.model.then(model => ({
            object: model,
            dispose: once(() => {
                if (--entry.counter <= 0) {
                    entry.model.then(x => x.dispose());
                    this.references.delete(key);
                }
            }),
        }));
    }
    disposeAllModelsForView(viewType) {
        for (const [key, value] of this.references) {
            if (value.viewType === viewType) {
                value.model.then(x => x.dispose());
                this.references.delete(key);
            }
        }
    }
    key(resource, viewType) {
        return `${resource.toString()}@@@${viewType}`;
    }
}
exports.CustomEditorModelManager = CustomEditorModelManager;
function once(fn) {
    const _this = this;
    let didCall = false;
    let result;
    return function () {
        if (didCall) {
            return result;
        }
        didCall = true;
        result = fn.apply(_this, arguments);
        return result;
    };
}
exports.once = once;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-undo-redo-handler.js"
/*!***************************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-undo-redo-handler.js ***!
  \***************************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2024 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CustomEditorUndoRedoHandler = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const custom_editor_widget_1 = __webpack_require__(/*! ./custom-editor-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-widget.js");
let CustomEditorUndoRedoHandler = class CustomEditorUndoRedoHandler {
    constructor() {
        this.priority = 190;
    }
    select() {
        const current = this.applicationShell.currentWidget;
        if (current instanceof custom_editor_widget_1.CustomEditorWidget) {
            return current;
        }
        return undefined;
    }
    undo(item) {
        item.undo();
    }
    redo(item) {
        item.redo();
    }
};
exports.CustomEditorUndoRedoHandler = CustomEditorUndoRedoHandler;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ApplicationShell),
    tslib_1.__metadata("design:type", browser_1.ApplicationShell)
], CustomEditorUndoRedoHandler.prototype, "applicationShell", void 0);
exports.CustomEditorUndoRedoHandler = CustomEditorUndoRedoHandler = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], CustomEditorUndoRedoHandler);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-widget-factory.js"
/*!************************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-widget-factory.js ***!
  \************************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 SAP SE or an SAP affiliate company and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CustomEditorWidgetFactory = void 0;
const custom_editor_widget_1 = __webpack_require__(/*! ../custom-editors/custom-editor-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-widget.js");
const webview_1 = __webpack_require__(/*! ../webview/webview */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview.js");
const webview_environment_1 = __webpack_require__(/*! ../webview/webview-environment */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-environment.js");
class CustomEditorWidgetFactory {
    constructor(container) {
        this.id = custom_editor_widget_1.CustomEditorWidget.FACTORY_ID;
        this.container = container;
    }
    async createWidget(identifier) {
        const externalEndpoint = await this.container.get(webview_environment_1.WebviewEnvironment).externalEndpoint();
        let endpoint = externalEndpoint.replace('{{uuid}}', identifier.id);
        if (endpoint[endpoint.length - 1] === '/') {
            endpoint = endpoint.slice(0, endpoint.length - 1);
        }
        const child = this.container.createChild();
        child.bind(webview_1.WebviewWidgetIdentifier).toConstantValue(identifier);
        child.bind(webview_1.WebviewWidgetExternalEndpoint).toConstantValue(endpoint);
        return child.get(custom_editor_widget_1.CustomEditorWidget);
    }
}
exports.CustomEditorWidgetFactory = CustomEditorWidgetFactory;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-widget.js"
/*!****************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-widget.js ***!
  \****************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 SAP SE or an SAP affiliate company and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var CustomEditorWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CustomEditorWidget = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../../node_modules/@theia/core/lib/common/uri.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const saveable_service_1 = __webpack_require__(/*! @theia/core/lib/browser/saveable-service */ "../../node_modules/@theia/core/lib/browser/saveable-service.js");
const webview_1 = __webpack_require__(/*! ../webview/webview */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview.js");
let CustomEditorWidget = CustomEditorWidget_1 = class CustomEditorWidget extends webview_1.WebviewWidget {
    constructor() {
        super(...arguments);
        this._modelRef = { object: undefined, dispose: () => { } };
        // ensures that saveable is available even if modelRef.object is undefined
        this.delegatingSaveable = new browser_1.DelegatingSaveable();
    }
    get modelRef() {
        return this._modelRef;
    }
    set modelRef(modelRef) {
        this._modelRef.dispose();
        this._modelRef = modelRef;
        this.delegatingSaveable.delegate = modelRef.object;
        this.doUpdateContent();
    }
    get saveable() {
        return this.delegatingSaveable;
    }
    init() {
        super.init();
        this.id = CustomEditorWidget_1.FACTORY_ID + ':' + this.identifier.id;
        this.toDispose.push(this.fileService.onDidRunOperation(e => {
            if (e.isOperation(2 /* FileOperation.MOVE */)) {
                this.doMove(e.target.resource);
            }
        }));
    }
    undo() {
        var _a;
        (_a = this._modelRef.object) === null || _a === void 0 ? void 0 : _a.undo();
    }
    redo() {
        var _a;
        (_a = this._modelRef.object) === null || _a === void 0 ? void 0 : _a.redo();
    }
    getResourceUri() {
        return this.resource;
    }
    createMoveToUri(resourceUri) {
        return this.resource.withPath(resourceUri.path);
    }
    storeState() {
        return {
            ...super.storeState(),
            strResource: this.resource.toString(),
        };
    }
    restoreState(oldState) {
        const { strResource } = oldState;
        this.resource = new uri_1.default(strResource);
        super.restoreState(oldState);
    }
    onMove(handler) {
        this._moveHandler = handler;
    }
    doMove(target) {
        if (this._moveHandler) {
            this._moveHandler(target);
        }
    }
};
exports.CustomEditorWidget = CustomEditorWidget;
CustomEditorWidget.FACTORY_ID = 'plugin-custom-editor';
CustomEditorWidget.SIDE_BY_SIDE_FACTORY_ID = CustomEditorWidget_1.FACTORY_ID + '.side-by-side';
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ApplicationShell),
    tslib_1.__metadata("design:type", browser_1.ApplicationShell)
], CustomEditorWidget.prototype, "shell", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(saveable_service_1.SaveableService),
    tslib_1.__metadata("design:type", saveable_service_1.SaveableService)
], CustomEditorWidget.prototype, "saveService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], CustomEditorWidget.prototype, "init", null);
exports.CustomEditorWidget = CustomEditorWidget = CustomEditorWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], CustomEditorWidget);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editors-main.js"
/*!***************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editors-main.js ***!
  \***************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 SAP SE or an SAP affiliate company and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/53eac52308c4611000a171cc7bf1214293473c78/src/vs/workbench/api/browser/mainThreadCustomEditors.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CustomTextEditorModel = exports.MainCustomEditorModel = exports.CustomEditorsMainImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const hosted_plugin_1 = __webpack_require__(/*! ../../../hosted/browser/hosted-plugin */ "../../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin.js");
const plugin_custom_editor_registry_1 = __webpack_require__(/*! ./plugin-custom-editor-registry */ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/plugin-custom-editor-registry.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../../node_modules/@theia/core/shared/vscode-uri/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../../node_modules/@theia/core/lib/common/uri.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const cancellation_1 = __webpack_require__(/*! @theia/core/lib/common/cancellation */ "../../node_modules/@theia/core/lib/common/cancellation.js");
const text_editor_model_service_1 = __webpack_require__(/*! ../text-editor-model-service */ "../../node_modules/@theia/plugin-ext/lib/main/browser/text-editor-model-service.js");
const custom_editor_service_1 = __webpack_require__(/*! ./custom-editor-service */ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-service.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../../node_modules/@theia/filesystem/lib/browser/file-service.js");
const undo_redo_service_1 = __webpack_require__(/*! @theia/editor/lib/browser/undo-redo-service */ "../../node_modules/@theia/editor/lib/browser/undo-redo-service.js");
const widget_manager_1 = __webpack_require__(/*! @theia/core/lib/browser/widget-manager */ "../../node_modules/@theia/core/lib/browser/widget-manager.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const editor_preferences_1 = __webpack_require__(/*! @theia/editor/lib/common/editor-preferences */ "../../node_modules/@theia/editor/lib/common/editor-preferences.js");
class CustomEditorsMainImpl {
    constructor(rpc, container, webviewsMain) {
        this.webviewsMain = webviewsMain;
        this.editorProviders = new Map();
        this.pluginService = container.get(hosted_plugin_1.HostedPluginSupport);
        this.shell = container.get(browser_1.ApplicationShell);
        this.textModelService = container.get(text_editor_model_service_1.EditorModelService);
        this.fileService = container.get(file_service_1.FileService);
        this.customEditorService = container.get(custom_editor_service_1.CustomEditorService);
        this.undoRedoService = container.get(undo_redo_service_1.UndoRedoService);
        this.customEditorRegistry = container.get(plugin_custom_editor_registry_1.PluginCustomEditorRegistry);
        this.labelProvider = container.get(browser_1.LabelProvider);
        this.editorPreferences = container.get(editor_preferences_1.EditorPreferences);
        this.widgetManager = container.get(widget_manager_1.WidgetManager);
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.CUSTOM_EDITORS_EXT);
    }
    dispose() {
        for (const disposable of this.editorProviders.values()) {
            disposable.dispose();
        }
        this.editorProviders.clear();
    }
    $registerTextEditorProvider(viewType, options, capabilities) {
        this.registerEditorProvider(1 /* CustomEditorModelType.Text */, viewType, options, capabilities, true);
    }
    $registerCustomEditorProvider(viewType, options, supportsMultipleEditorsPerDocument) {
        this.registerEditorProvider(0 /* CustomEditorModelType.Custom */, viewType, options, {}, supportsMultipleEditorsPerDocument);
    }
    async registerEditorProvider(modelType, viewType, options, capabilities, supportsMultipleEditorsPerDocument) {
        if (this.editorProviders.has(viewType)) {
            throw new Error(`Provider for ${viewType} already registered`);
        }
        const disposables = new disposable_1.DisposableCollection();
        disposables.push(this.customEditorRegistry.registerResolver(viewType, async (widget) => {
            const { resource, identifier } = widget;
            widget.options = options;
            const cancellationSource = new cancellation_1.CancellationTokenSource();
            let modelRef = await this.getOrCreateCustomEditorModel(modelType, resource, viewType, cancellationSource.token);
            widget.modelRef = modelRef;
            widget.onDidDispose(() => {
                // If the model is still dirty, make sure we have time to save it
                if (modelRef.object.dirty) {
                    const sub = modelRef.object.onDirtyChanged(() => {
                        if (!modelRef.object.dirty) {
                            sub.dispose();
                            modelRef.dispose();
                        }
                    });
                    return;
                }
                modelRef.dispose();
            });
            if (capabilities.supportsMove) {
                const onMoveCancelTokenSource = new cancellation_1.CancellationTokenSource();
                widget.onMove(async (newResource) => {
                    const oldModel = modelRef;
                    modelRef = await this.getOrCreateCustomEditorModel(modelType, newResource, viewType, onMoveCancelTokenSource.token);
                    this.proxy.$onMoveCustomEditor(identifier.id, newResource.toComponents(), viewType);
                    oldModel.dispose();
                });
            }
            this.webviewsMain.hookWebview(widget);
            widget.title.label = this.labelProvider.getName(resource);
            const _cancellationSource = new cancellation_1.CancellationTokenSource();
            await this.proxy.$resolveWebviewEditor(resource.toComponents(), identifier.id, viewType, widget.title.label, widget.viewState.position, options, _cancellationSource.token);
        }));
        this.editorProviders.set(viewType, disposables);
    }
    $unregisterEditorProvider(viewType) {
        const provider = this.editorProviders.get(viewType);
        if (!provider) {
            throw new Error(`No provider for ${viewType} registered`);
        }
        provider.dispose();
        this.editorProviders.delete(viewType);
        this.customEditorService.models.disposeAllModelsForView(viewType);
    }
    async getOrCreateCustomEditorModel(modelType, resource, viewType, cancellationToken) {
        const existingModel = this.customEditorService.models.tryRetain(resource, viewType);
        if (existingModel) {
            return existingModel;
        }
        switch (modelType) {
            case 1 /* CustomEditorModelType.Text */: {
                const model = CustomTextEditorModel.create(viewType, resource, this.textModelService);
                return this.customEditorService.models.add(resource, viewType, model);
            }
            case 0 /* CustomEditorModelType.Custom */: {
                const model = MainCustomEditorModel.create(this.proxy, viewType, resource, this.undoRedoService, this.fileService, cancellationToken);
                return this.customEditorService.models.add(resource, viewType, model);
            }
        }
    }
    async getCustomEditorModel(resourceComponents, viewType) {
        const resource = vscode_uri_1.URI.revive(resourceComponents);
        const model = await this.customEditorService.models.get(new uri_1.default(resource), viewType);
        if (!model || !(model instanceof MainCustomEditorModel)) {
            throw new Error('Could not find model for custom editor');
        }
        return model;
    }
    async $onDidEdit(resourceComponents, viewType, editId, label) {
        const model = await this.getCustomEditorModel(resourceComponents, viewType);
        model.pushEdit(editId, label);
    }
    async $onContentChange(resourceComponents, viewType) {
        const model = await this.getCustomEditorModel(resourceComponents, viewType);
        model.changeContent();
    }
}
exports.CustomEditorsMainImpl = CustomEditorsMainImpl;
class MainCustomEditorModel {
    static async create(proxy, viewType, resource, undoRedoService, fileService, cancellation) {
        const { editable } = await proxy.$createCustomDocument(resource.toComponents(), viewType, {}, cancellation);
        return new MainCustomEditorModel(proxy, viewType, resource, editable, undoRedoService, fileService);
    }
    constructor(proxy, viewType, editorResource, editable, undoRedoService, fileService) {
        this.proxy = proxy;
        this.viewType = viewType;
        this.editorResource = editorResource;
        this.editable = editable;
        this.undoRedoService = undoRedoService;
        this.fileService = fileService;
        this.currentEditIndex = -1;
        this.savePoint = -1;
        this.isDirtyFromContentChange = false;
        this.edits = [];
        this.toDispose = new disposable_1.DisposableCollection();
        this.onDirtyChangedEmitter = new core_1.Emitter();
        this.onDirtyChanged = this.onDirtyChangedEmitter.event;
        this.onContentChangedEmitter = new core_1.Emitter();
        this.onContentChanged = this.onContentChangedEmitter.event;
        this.toDispose.push(this.onDirtyChangedEmitter);
    }
    get resource() {
        return vscode_uri_1.URI.from(this.editorResource.toComponents());
    }
    get dirty() {
        if (this.isDirtyFromContentChange) {
            return true;
        }
        if (this.edits.length > 0) {
            return this.savePoint !== this.currentEditIndex;
        }
        return false;
    }
    get readonly() {
        return !this.editable;
    }
    setProxy(proxy) {
        this.proxy = proxy;
    }
    dispose() {
        if (this.editable) {
            this.undoRedoService.removeElements(this.editorResource);
        }
        this.proxy.$disposeCustomDocument(this.resource, this.viewType);
    }
    changeContent() {
        this.change(() => {
            this.isDirtyFromContentChange = true;
        });
    }
    pushEdit(editId, label) {
        if (!this.editable) {
            throw new Error('Document is not editable');
        }
        this.change(() => {
            this.spliceEdits(editId);
            this.currentEditIndex = this.edits.length - 1;
        });
        this.undoRedoService.pushElement(this.editorResource, () => this.undo(), () => this.redo());
    }
    async revert(options) {
        if (!this.editable) {
            return;
        }
        if (this.currentEditIndex === this.savePoint && !this.isDirtyFromContentChange) {
            return;
        }
        const cancellationSource = new cancellation_1.CancellationTokenSource();
        await this.proxy.$revert(this.resource, this.viewType, cancellationSource.token);
        this.change(() => {
            this.isDirtyFromContentChange = false;
            this.currentEditIndex = this.savePoint;
            this.spliceEdits();
        });
    }
    async save(options) {
        await this.saveCustomEditor(options);
    }
    async saveCustomEditor(options) {
        var _a;
        if (!this.editable) {
            return;
        }
        const cancelable = new cancellation_1.CancellationTokenSource();
        const savePromise = this.proxy.$save(this.resource, this.viewType, cancelable.token);
        (_a = this.ongoingSave) === null || _a === void 0 ? void 0 : _a.cancel();
        this.ongoingSave = cancelable;
        try {
            await savePromise;
            if (this.ongoingSave === cancelable) { // Make sure we are still doing the same save
                this.change(() => {
                    this.isDirtyFromContentChange = false;
                    this.savePoint = this.currentEditIndex;
                });
            }
        }
        finally {
            if (this.ongoingSave === cancelable) { // Make sure we are still doing the same save
                this.ongoingSave = undefined;
            }
        }
    }
    async saveAs(options) {
        await this.saveCustomEditorAs(new uri_1.default(this.resource), options.target, options);
    }
    async saveCustomEditorAs(resource, targetResource, options) {
        if (this.editable) {
            const source = new cancellation_1.CancellationTokenSource();
            await this.proxy.$saveAs(this.resource, this.viewType, targetResource.toComponents(), source.token);
            this.change(() => {
                this.savePoint = this.currentEditIndex;
            });
        }
        else {
            // Since the editor is readonly, just copy the file over
            await this.fileService.copy(resource, targetResource, { overwrite: false });
        }
    }
    async undo() {
        if (!this.editable) {
            return;
        }
        if (this.currentEditIndex < 0) {
            // nothing to undo
            return;
        }
        const undoneEdit = this.edits[this.currentEditIndex];
        this.change(() => {
            --this.currentEditIndex;
        });
        await this.proxy.$undo(this.resource, this.viewType, undoneEdit, this.dirty);
    }
    async redo() {
        if (!this.editable) {
            return;
        }
        if (this.currentEditIndex >= this.edits.length - 1) {
            // nothing to redo
            return;
        }
        const redoneEdit = this.edits[this.currentEditIndex + 1];
        this.change(() => {
            ++this.currentEditIndex;
        });
        await this.proxy.$redo(this.resource, this.viewType, redoneEdit, this.dirty);
    }
    spliceEdits(editToInsert) {
        const start = this.currentEditIndex + 1;
        const toRemove = this.edits.length - this.currentEditIndex;
        const removedEdits = typeof editToInsert === 'number'
            ? this.edits.splice(start, toRemove, editToInsert)
            : this.edits.splice(start, toRemove);
        if (removedEdits.length) {
            this.proxy.$disposeEdits(this.resource, this.viewType, removedEdits);
        }
    }
    change(makeEdit) {
        const wasDirty = this.dirty;
        makeEdit();
        if (this.dirty !== wasDirty) {
            this.onDirtyChangedEmitter.fire();
        }
        this.onContentChangedEmitter.fire();
    }
}
exports.MainCustomEditorModel = MainCustomEditorModel;
// copied from https://github.com/microsoft/vscode/blob/53eac52308c4611000a171cc7bf1214293473c78/src/vs/workbench/contrib/customEditor/common/customTextEditorModel.ts
class CustomTextEditorModel {
    static async create(viewType, resource, editorModelService) {
        const model = await editorModelService.createModelReference(resource);
        model.object.suppressOpenEditorWhenDirty = true;
        return new CustomTextEditorModel(viewType, resource, model);
    }
    constructor(viewType, editorResource, model) {
        this.viewType = viewType;
        this.editorResource = editorResource;
        this.model = model;
        this.toDispose = new disposable_1.DisposableCollection();
        this.onDirtyChangedEmitter = new core_1.Emitter();
        this.onDirtyChanged = this.onDirtyChangedEmitter.event;
        this.onContentChangedEmitter = new core_1.Emitter();
        this.onContentChanged = this.onContentChangedEmitter.event;
        this.toDispose.push(this.editorTextModel.onDirtyChanged(e => {
            this.onDirtyChangedEmitter.fire();
        }));
        this.toDispose.push(this.editorTextModel.onContentChanged(e => {
            this.onContentChangedEmitter.fire();
        }));
        this.toDispose.push(this.onDirtyChangedEmitter);
        this.toDispose.push(this.onContentChangedEmitter);
    }
    dispose() {
        this.toDispose.dispose();
        this.model.dispose();
    }
    get resource() {
        return vscode_uri_1.URI.from(this.editorResource.toComponents());
    }
    get dirty() {
        return this.editorTextModel.dirty;
    }
    ;
    get readonly() {
        return Boolean(this.editorTextModel.readOnly);
    }
    get editorTextModel() {
        return this.model.object;
    }
    revert(options) {
        return this.editorTextModel.revert(options);
    }
    save(options) {
        return this.saveCustomEditor(options);
    }
    serialize() {
        return this.editorTextModel.serialize();
    }
    saveCustomEditor(options) {
        return this.editorTextModel.save(options);
    }
    undo() {
        this.editorTextModel.undo();
    }
    redo() {
        this.editorTextModel.redo();
    }
}
exports.CustomTextEditorModel = CustomTextEditorModel;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/plugin-custom-editor-registry.js"
/*!*************************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/plugin-custom-editor-registry.js ***!
  \*************************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 SAP SE or an SAP affiliate company and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginCustomEditorRegistry = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../../node_modules/@theia/core/lib/common/promise-util.js");
const custom_editor_opener_1 = __webpack_require__(/*! ./custom-editor-opener */ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-opener.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const custom_editor_widget_1 = __webpack_require__(/*! ./custom-editor-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-widget.js");
let PluginCustomEditorRegistry = class PluginCustomEditorRegistry {
    constructor() {
        this.editors = new Map();
        this.pendingEditors = new Map();
        this.resolvers = new Map();
        this.onWillOpenCustomEditorEmitter = new core_1.Emitter();
        this.onWillOpenCustomEditor = this.onWillOpenCustomEditorEmitter.event;
    }
    init() {
        this.widgetManager.onDidCreateWidget(({ factoryId, widget }) => {
            if (factoryId === custom_editor_widget_1.CustomEditorWidget.FACTORY_ID && widget instanceof custom_editor_widget_1.CustomEditorWidget) {
                const restoreState = widget.restoreState.bind(widget);
                widget.restoreState = state => {
                    if (state.viewType && state.strResource) {
                        restoreState(state);
                        this.resolveWidget(widget);
                    }
                    else {
                        widget.dispose();
                    }
                };
            }
        });
    }
    registerCustomEditor(editor, plugin) {
        if (this.editors.has(editor.viewType)) {
            console.warn('editor with such id already registered: ', JSON.stringify(editor));
            return disposable_1.Disposable.NULL;
        }
        this.editors.set(editor.viewType, editor);
        const toDispose = new disposable_1.DisposableCollection();
        toDispose.push(disposable_1.Disposable.create(() => this.editors.delete(editor.viewType)));
        const editorOpenHandler = new custom_editor_opener_1.CustomEditorOpener(editor, this.shell, this.widgetManager, this, this.preferenceService);
        toDispose.push(this.defaultOpenerService.addHandler(editorOpenHandler));
        toDispose.push(this.openWithService.registerHandler({
            id: editor.viewType,
            label: editorOpenHandler.label,
            providerName: plugin.metadata.model.displayName,
            canHandle: uri => editorOpenHandler.canOpenWith(uri),
            open: uri => editorOpenHandler.open(uri)
        }));
        return toDispose;
    }
    async resolveWidget(widget) {
        const resolver = this.resolvers.get(widget.viewType);
        if (resolver) {
            await resolver(widget);
        }
        else {
            const deferred = new promise_util_1.Deferred();
            const disposable = widget.onDidDispose(() => this.pendingEditors.delete(widget));
            this.pendingEditors.set(widget, { deferred, disposable });
            this.onWillOpenCustomEditorEmitter.fire(widget.viewType);
            return deferred.promise;
        }
    }
    ;
    registerResolver(viewType, resolver) {
        if (this.resolvers.has(viewType)) {
            throw new Error(`Resolver for ${viewType} already registered`);
        }
        for (const [editorWidget, { deferred, disposable }] of this.pendingEditors.entries()) {
            if (editorWidget.viewType === viewType) {
                resolver(editorWidget).then(() => deferred.resolve(), err => deferred.reject(err)).finally(() => disposable.dispose());
                this.pendingEditors.delete(editorWidget);
            }
        }
        this.resolvers.set(viewType, resolver);
        return disposable_1.Disposable.create(() => this.resolvers.delete(viewType));
    }
};
exports.PluginCustomEditorRegistry = PluginCustomEditorRegistry;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.DefaultOpenerService),
    tslib_1.__metadata("design:type", browser_1.DefaultOpenerService)
], PluginCustomEditorRegistry.prototype, "defaultOpenerService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.WidgetManager),
    tslib_1.__metadata("design:type", browser_1.WidgetManager)
], PluginCustomEditorRegistry.prototype, "widgetManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ApplicationShell),
    tslib_1.__metadata("design:type", browser_1.ApplicationShell)
], PluginCustomEditorRegistry.prototype, "shell", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.OpenWithService),
    tslib_1.__metadata("design:type", browser_1.OpenWithService)
], PluginCustomEditorRegistry.prototype, "openWithService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.PreferenceService),
    tslib_1.__metadata("design:type", Object)
], PluginCustomEditorRegistry.prototype, "preferenceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], PluginCustomEditorRegistry.prototype, "init", null);
exports.PluginCustomEditorRegistry = PluginCustomEditorRegistry = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginCustomEditorRegistry);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/debug/debug-main.js"
/*!*********************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/debug/debug-main.js ***!
  \*********************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugMainImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const debug_session_manager_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-session-manager */ "../../node_modules/@theia/debug/lib/browser/debug-session-manager.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "../../node_modules/@theia/editor/lib/browser/index.js");
const breakpoint_manager_1 = __webpack_require__(/*! @theia/debug/lib/browser/breakpoint/breakpoint-manager */ "../../node_modules/@theia/debug/lib/browser/breakpoint/breakpoint-manager.js");
const debug_source_breakpoint_1 = __webpack_require__(/*! @theia/debug/lib/browser/model/debug-source-breakpoint */ "../../node_modules/@theia/debug/lib/browser/model/debug-source-breakpoint.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../../node_modules/@theia/core/shared/vscode-uri/index.js");
const debug_configuration_manager_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-configuration-manager */ "../../node_modules/@theia/debug/lib/browser/debug-configuration-manager.js");
const terminal_service_1 = __webpack_require__(/*! @theia/terminal/lib/browser/base/terminal-service */ "../../node_modules/@theia/terminal/lib/browser/base/terminal-service.js");
const message_service_protocol_1 = __webpack_require__(/*! @theia/core/lib/common/message-service-protocol */ "../../node_modules/@theia/core/lib/common/message-service-protocol.js");
const output_channel_1 = __webpack_require__(/*! @theia/output/lib/browser/output-channel */ "../../node_modules/@theia/output/lib/browser/output-channel.js");
const debug_preferences_1 = __webpack_require__(/*! @theia/debug/lib/common/debug-preferences */ "../../node_modules/@theia/debug/lib/common/debug-preferences.js");
const plugin_debug_adapter_contribution_1 = __webpack_require__(/*! ./plugin-debug-adapter-contribution */ "../../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-adapter-contribution.js");
const plugin_debug_configuration_provider_1 = __webpack_require__(/*! ./plugin-debug-configuration-provider */ "../../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-configuration-provider.js");
const plugin_debug_session_contribution_registry_1 = __webpack_require__(/*! ./plugin-debug-session-contribution-registry */ "../../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-session-contribution-registry.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const plugin_debug_session_factory_1 = __webpack_require__(/*! ./plugin-debug-session-factory */ "../../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-session-factory.js");
const plugin_debug_service_1 = __webpack_require__(/*! ./plugin-debug-service */ "../../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-service.js");
const hosted_plugin_1 = __webpack_require__(/*! ../../../hosted/browser/hosted-plugin */ "../../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin.js");
const debug_function_breakpoint_1 = __webpack_require__(/*! @theia/debug/lib/browser/model/debug-function-breakpoint */ "../../node_modules/@theia/debug/lib/browser/model/debug-function-breakpoint.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../../node_modules/@theia/filesystem/lib/browser/file-service.js");
const console_session_manager_1 = __webpack_require__(/*! @theia/console/lib/browser/console-session-manager */ "../../node_modules/@theia/console/lib/browser/console-session-manager.js");
const debug_console_session_1 = __webpack_require__(/*! @theia/debug/lib/browser/console/debug-console-session */ "../../node_modules/@theia/debug/lib/browser/console/debug-console-session.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../../node_modules/@theia/core/lib/common/index.js");
const debug_contribution_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-contribution */ "../../node_modules/@theia/debug/lib/browser/debug-contribution.js");
const browser_3 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../../node_modules/@theia/workspace/lib/browser/index.js");
const debug_session_options_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-session-options */ "../../node_modules/@theia/debug/lib/browser/debug-session-options.js");
const test_service_1 = __webpack_require__(/*! @theia/test/lib/browser/test-service */ "../../node_modules/@theia/test/lib/browser/test-service.js");
class DebugMainImpl {
    constructor(rpc, connectionMain, container) {
        this.connectionMain = connectionMain;
        this.debuggerContributions = new Map();
        this.configurationProviders = new Map();
        this.toDispose = new disposable_1.DisposableCollection();
        this.debugExt = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.DEBUG_EXT);
        this.sessionManager = container.get(debug_session_manager_1.DebugSessionManager);
        this.labelProvider = container.get(browser_1.LabelProvider);
        this.editorManager = container.get(browser_2.EditorManager);
        this.breakpointsManager = container.get(breakpoint_manager_1.BreakpointManager);
        this.consoleSessionManager = container.get(console_session_manager_1.ConsoleSessionManager);
        this.configurationManager = container.get(debug_configuration_manager_1.DebugConfigurationManager);
        this.terminalService = container.get(terminal_service_1.TerminalService);
        this.messages = container.get(message_service_protocol_1.MessageClient);
        this.outputChannelManager = container.get(output_channel_1.OutputChannelManager);
        this.debugPreferences = container.get(debug_preferences_1.DebugPreferences);
        this.pluginDebugService = container.get(plugin_debug_service_1.PluginDebugService);
        this.sessionContributionRegistrator = container.get(plugin_debug_session_contribution_registry_1.PluginDebugSessionContributionRegistry);
        this.debugContributionProvider = container.getNamed(common_1.ContributionProvider, debug_contribution_1.DebugContribution);
        this.fileService = container.get(file_service_1.FileService);
        this.pluginService = container.get(hosted_plugin_1.HostedPluginSupport);
        this.testService = container.get(test_service_1.TestService);
        this.workspaceService = container.get(browser_3.WorkspaceService);
        this.commandService = container.get(common_1.CommandService);
        const fireDidChangeBreakpoints = ({ added, removed, changed }) => {
            this.debugExt.$breakpointsDidChange(this.toTheiaPluginApiBreakpoints(added), removed.map(b => b.id), this.toTheiaPluginApiBreakpoints(changed));
        };
        this.debugExt.$breakpointsDidChange(this.toTheiaPluginApiBreakpoints(this.breakpointsManager.getBreakpoints()), [], []);
        this.debugExt.$breakpointsDidChange(this.toTheiaPluginApiBreakpoints(this.breakpointsManager.getFunctionBreakpoints()), [], []);
        this.toDispose.pushAll([
            this.breakpointsManager.onDidChangeBreakpoints(fireDidChangeBreakpoints),
            this.breakpointsManager.onDidChangeFunctionBreakpoints(fireDidChangeBreakpoints),
            this.sessionManager.onDidCreateDebugSession(debugSession => this.debugExt.$sessionDidCreate(debugSession.id)),
            this.sessionManager.onDidStartDebugSession(debugSession => this.debugExt.$sessionDidStart(debugSession.id)),
            this.sessionManager.onDidDestroyDebugSession(debugSession => this.debugExt.$sessionDidDestroy(debugSession.id)),
            this.sessionManager.onDidChangeActiveDebugSession(event => this.debugExt.$sessionDidChange(event.current && event.current.id)),
            this.sessionManager.onDidReceiveDebugSessionCustomEvent(event => this.debugExt.$onSessionCustomEvent(event.session.id, event.event, event.body)),
            this.sessionManager.onDidFocusStackFrame(stackFrame => this.debugExt.$onDidChangeActiveFrame(this.toDebugStackFrameDTO(stackFrame))),
            this.sessionManager.onDidFocusThread(debugThread => this.debugExt.$onDidChangeActiveThread(this.toDebugThreadDTO(debugThread))),
        ]);
    }
    dispose() {
        this.toDispose.dispose();
    }
    async $appendToDebugConsole(value) {
        const session = this.consoleSessionManager.selectedSession;
        if (session instanceof debug_console_session_1.DebugConsoleSession) {
            session.append(value);
        }
    }
    async $appendLineToDebugConsole(value) {
        const session = this.consoleSessionManager.selectedSession;
        if (session instanceof debug_console_session_1.DebugConsoleSession) {
            session.appendLine(value);
        }
    }
    async $registerDebuggerContribution(description) {
        const debugType = description.type;
        const terminalOptionsExt = await this.debugExt.$getTerminalCreationOptions(debugType);
        if (this.toDispose.disposed) {
            return;
        }
        const debugSessionFactory = new plugin_debug_session_factory_1.PluginDebugSessionFactory(this.terminalService, this.editorManager, this.breakpointsManager, this.labelProvider, this.messages, this.outputChannelManager, this.debugPreferences, async (sessionId) => {
            const connection = await this.connectionMain.ensureConnection(sessionId);
            return connection;
        }, this.fileService, terminalOptionsExt, this.debugContributionProvider, this.testService, this.workspaceService, this.commandService);
        const toDispose = new disposable_1.DisposableCollection(disposable_1.Disposable.create(() => this.debuggerContributions.delete(debugType)));
        this.debuggerContributions.set(debugType, toDispose);
        toDispose.pushAll([
            this.pluginDebugService.registerDebugAdapterContribution(new plugin_debug_adapter_contribution_1.PluginDebugAdapterContribution(description, this.debugExt, this.pluginService)),
            this.sessionContributionRegistrator.registerDebugSessionContribution({
                debugType: description.type,
                debugSessionFactory: () => debugSessionFactory
            })
        ]);
        this.toDispose.push(disposable_1.Disposable.create(() => this.$unregisterDebuggerConfiguration(debugType)));
    }
    async $unregisterDebuggerConfiguration(debugType) {
        const disposable = this.debuggerContributions.get(debugType);
        if (disposable) {
            disposable.dispose();
        }
    }
    $registerDebugConfigurationProvider(description) {
        const handle = description.handle;
        const toDispose = new disposable_1.DisposableCollection(disposable_1.Disposable.create(() => this.configurationProviders.delete(handle)));
        this.configurationProviders.set(handle, toDispose);
        toDispose.push(this.pluginDebugService.registerDebugConfigurationProvider(new plugin_debug_configuration_provider_1.PluginDebugConfigurationProvider(description, this.debugExt)));
        this.toDispose.push(disposable_1.Disposable.create(() => this.$unregisterDebugConfigurationProvider(handle)));
    }
    async $unregisterDebugConfigurationProvider(handle) {
        const disposable = this.configurationProviders.get(handle);
        if (disposable) {
            disposable.dispose();
        }
    }
    async $addBreakpoints(breakpoints) {
        const newBreakpoints = new Map();
        breakpoints.forEach(b => newBreakpoints.set(b.id, b));
        this.breakpointsManager.findMarkers({
            dataFilter: data => {
                // install only new breakpoints
                if (newBreakpoints.has(data.id)) {
                    newBreakpoints.delete(data.id);
                }
                return false;
            }
        });
        let addedFunctionBreakpoints = false;
        const functionBreakpoints = this.breakpointsManager.getFunctionBreakpoints();
        for (const breakpoint of functionBreakpoints) {
            // install only new breakpoints
            if (newBreakpoints.has(breakpoint.id)) {
                newBreakpoints.delete(breakpoint.id);
            }
        }
        for (const breakpoint of newBreakpoints.values()) {
            if (breakpoint.location) {
                const location = breakpoint.location;
                const column = breakpoint.location.range.startColumn;
                this.breakpointsManager.addBreakpoint({
                    id: breakpoint.id,
                    uri: vscode_uri_1.URI.revive(location.uri).toString(),
                    enabled: breakpoint.enabled,
                    raw: {
                        line: breakpoint.location.range.startLineNumber + 1,
                        column: column > 0 ? column + 1 : undefined,
                        condition: breakpoint.condition,
                        hitCondition: breakpoint.hitCondition,
                        logMessage: breakpoint.logMessage
                    }
                });
            }
            else if (breakpoint.functionName) {
                addedFunctionBreakpoints = true;
                functionBreakpoints.push({
                    id: breakpoint.id,
                    enabled: breakpoint.enabled,
                    raw: {
                        name: breakpoint.functionName
                    }
                });
            }
        }
        if (addedFunctionBreakpoints) {
            this.breakpointsManager.setFunctionBreakpoints(functionBreakpoints);
        }
    }
    async $getDebugProtocolBreakpoint(sessionId, breakpointId) {
        var _a;
        const session = this.sessionManager.getSession(sessionId);
        if (session) {
            return (_a = session.getBreakpoint(breakpointId)) === null || _a === void 0 ? void 0 : _a.raw;
        }
        else {
            throw new Error(`Debug session '${sessionId}' not found`);
        }
    }
    async $removeBreakpoints(breakpoints) {
        const { labelProvider, breakpointsManager, editorManager } = this;
        const session = this.sessionManager.currentSession;
        const ids = new Set(breakpoints);
        for (const origin of this.breakpointsManager.findMarkers({ dataFilter: data => ids.has(data.id) })) {
            const breakpoint = new debug_source_breakpoint_1.DebugSourceBreakpoint(origin.data, { labelProvider, breakpoints: breakpointsManager, editorManager, session }, this.commandService);
            breakpoint.remove();
        }
        for (const origin of this.breakpointsManager.getFunctionBreakpoints()) {
            if (ids.has(origin.id)) {
                const breakpoint = new debug_function_breakpoint_1.DebugFunctionBreakpoint(origin, { labelProvider, breakpoints: breakpointsManager, editorManager, session });
                breakpoint.remove();
            }
        }
    }
    async $customRequest(sessionId, command, args) {
        const session = this.sessionManager.getSession(sessionId);
        if (session) {
            return session.sendCustomRequest(command, args);
        }
        throw new Error(`Debug session '${sessionId}' not found`);
    }
    async $startDebugging(folder, nameOrConfiguration, options) {
        // search for matching options
        let sessionOptions;
        if (typeof nameOrConfiguration === 'string') {
            for (const configOptions of this.configurationManager.all) {
                if (configOptions.name === nameOrConfiguration) {
                    sessionOptions = configOptions;
                }
            }
        }
        else {
            sessionOptions = {
                name: nameOrConfiguration.name,
                configuration: nameOrConfiguration
            };
        }
        if (!sessionOptions) {
            console.error(`There is no debug configuration for ${nameOrConfiguration}`);
            return false;
        }
        // translate given extra data
        const workspaceFolderUri = folder && vscode_uri_1.URI.revive(folder.uri).toString();
        if (debug_session_options_1.DebugSessionOptions.isConfiguration(sessionOptions)) {
            sessionOptions = { ...sessionOptions, configuration: { ...sessionOptions.configuration, ...options }, workspaceFolderUri };
        }
        else {
            sessionOptions = { ...sessionOptions, ...options, workspaceFolderUri };
        }
        sessionOptions.testRun = options.testRun;
        // start options
        const session = await this.sessionManager.start(sessionOptions);
        return !!session;
    }
    async $stopDebugging(sessionId) {
        if (sessionId) {
            const session = this.sessionManager.getSession(sessionId);
            return this.sessionManager.terminateSession(session);
        }
        // Terminate all sessions if no session is provided.
        for (const session of this.sessionManager.sessions) {
            this.sessionManager.terminateSession(session);
        }
    }
    toDebugStackFrameDTO(stackFrame) {
        return stackFrame ? {
            sessionId: stackFrame.session.id,
            frameId: stackFrame.frameId,
            threadId: stackFrame.thread.threadId
        } : undefined;
    }
    toDebugThreadDTO(debugThread) {
        return debugThread ? {
            sessionId: debugThread.session.id,
            threadId: debugThread.threadId
        } : undefined;
    }
    toTheiaPluginApiBreakpoints(breakpoints) {
        return breakpoints.map(b => this.toTheiaPluginApiBreakpoint(b));
    }
    toTheiaPluginApiBreakpoint(breakpoint) {
        if ('uri' in breakpoint) {
            const raw = breakpoint.raw;
            return {
                id: breakpoint.id,
                enabled: breakpoint.enabled,
                condition: breakpoint.raw.condition,
                hitCondition: breakpoint.raw.hitCondition,
                logMessage: raw.logMessage,
                location: {
                    uri: vscode_uri_1.URI.parse(breakpoint.uri),
                    range: {
                        startLineNumber: raw.line - 1,
                        startColumn: (raw.column || 1) - 1,
                        endLineNumber: raw.line - 1,
                        endColumn: (raw.column || 1) - 1
                    }
                }
            };
        }
        return {
            id: breakpoint.id,
            enabled: breakpoint.enabled,
            functionName: breakpoint.raw.name
        };
    }
}
exports.DebugMainImpl = DebugMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-adapter-contribution.js"
/*!********************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-adapter-contribution.js ***!
  \********************************************************************************************************/
(__unused_webpack_module, exports) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginDebugAdapterContribution = void 0;
/**
 * Plugin [DebugAdapterContribution](#DebugAdapterContribution).
 */
class PluginDebugAdapterContribution {
    constructor(description, debugExt, pluginService) {
        this.description = description;
        this.debugExt = debugExt;
        this.pluginService = pluginService;
    }
    get type() {
        return this.description.type;
    }
    get label() {
        return this.description.label;
    }
    async createDebugSession(config, workspaceFolder) {
        await this.pluginService.activateByDebug('onDebugAdapterProtocolTracker', config.type);
        return this.debugExt.$createDebugSession(config, workspaceFolder);
    }
    async terminateDebugSession(sessionId) {
        this.debugExt.$terminateDebugSession(sessionId);
    }
}
exports.PluginDebugAdapterContribution = PluginDebugAdapterContribution;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-configuration-provider.js"
/*!**********************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-configuration-provider.js ***!
  \**********************************************************************************************************/
(__unused_webpack_module, exports) {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginDebugConfigurationProvider = void 0;
class PluginDebugConfigurationProvider {
    constructor(description, debugExt) {
        this.debugExt = debugExt;
        this.handle = description.handle;
        this.originalHandle = this.handle;
        this.type = description.type;
        this.triggerKind = description.trigger;
        if (description.provideDebugConfiguration) {
            this.provideDebugConfigurations = async (folder) => this.debugExt.$provideDebugConfigurationsByHandle(this.originalHandle, folder);
        }
        if (description.resolveDebugConfigurations) {
            this.resolveDebugConfiguration =
                async (folder, debugConfiguration) => this.debugExt.$resolveDebugConfigurationByHandle(this.originalHandle, folder, debugConfiguration);
        }
        if (description.resolveDebugConfigurationWithSubstitutedVariables) {
            this.resolveDebugConfigurationWithSubstitutedVariables =
                async (folder, debugConfiguration) => this.debugExt.$resolveDebugConfigurationWithSubstitutedVariablesByHandle(this.originalHandle, folder, debugConfiguration);
        }
    }
}
exports.PluginDebugConfigurationProvider = PluginDebugConfigurationProvider;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-service.js"
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-service.js ***!
  \*******************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginDebugService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const debug_service_1 = __webpack_require__(/*! @theia/debug/lib/common/debug-service */ "../../node_modules/@theia/debug/lib/common/debug-service.js");
const debounce = __webpack_require__(/*! @theia/core/shared/lodash.debounce */ "../../node_modules/@theia/core/shared/lodash.debounce/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const ws_connection_provider_1 = __webpack_require__(/*! @theia/core/lib/browser/messaging/ws-connection-provider */ "../../node_modules/@theia/core/lib/browser/messaging/ws-connection-provider.js");
const browser_1 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../../node_modules/@theia/workspace/lib/browser/index.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
/**
 * Debug service to work with plugin and extension contributions.
 */
let PluginDebugService = class PluginDebugService {
    constructor() {
        this.onDidChangeDebuggersEmitter = new core_1.Emitter();
        this.debuggers = [];
        this.contributors = new Map();
        this.configurationProviders = new Map();
        this.toDispose = new disposable_1.DisposableCollection(this.onDidChangeDebuggersEmitter);
        this.onDidChangeDebugConfigurationProvidersEmitter = new core_1.Emitter();
        // maps session and contribution
        this.sessionId2contrib = new Map();
        // debouncing to send a single notification for multiple registrations at initialization time
        this.fireOnDidConfigurationProvidersChanged = debounce(() => {
            this.onDidChangeDebugConfigurationProvidersEmitter.fire();
        }, 100);
    }
    get onDidChangeDebuggers() {
        return this.onDidChangeDebuggersEmitter.event;
    }
    get onDidChangeDebugConfigurationProviders() {
        return this.onDidChangeDebugConfigurationProvidersEmitter.event;
    }
    init() {
        this.delegated = this.connectionProvider.createProxy(debug_service_1.DebugPath);
        this.toDispose.pushAll([
            disposable_1.Disposable.create(() => this.delegated.dispose()),
            disposable_1.Disposable.create(() => {
                for (const sessionId of this.sessionId2contrib.keys()) {
                    const contrib = this.sessionId2contrib.get(sessionId);
                    contrib.terminateDebugSession(sessionId);
                }
                this.sessionId2contrib.clear();
            })
        ]);
    }
    registerDebugAdapterContribution(contrib) {
        const { type } = contrib;
        if (this.contributors.has(type)) {
            console.warn(`Debugger with type '${type}' already registered.`);
            return disposable_1.Disposable.NULL;
        }
        this.contributors.set(type, contrib);
        return disposable_1.Disposable.create(() => this.unregisterDebugAdapterContribution(type));
    }
    unregisterDebugAdapterContribution(debugType) {
        this.contributors.delete(debugType);
    }
    registerDebugConfigurationProvider(provider) {
        if (this.configurationProviders.has(provider.handle)) {
            const configuration = this.configurationProviders.get(provider.handle);
            if (configuration && configuration.type !== provider.type) {
                console.warn(`Different debug configuration provider with type '${configuration.type}' already registered.`);
                provider.handle = this.configurationProviders.size;
            }
        }
        const handle = provider.handle;
        this.configurationProviders.set(handle, provider);
        this.fireOnDidConfigurationProvidersChanged();
        return disposable_1.Disposable.create(() => this.unregisterDebugConfigurationProvider(handle));
    }
    unregisterDebugConfigurationProvider(handle) {
        this.configurationProviders.delete(handle);
        this.fireOnDidConfigurationProvidersChanged();
    }
    async debugTypes() {
        const debugTypes = new Set(await this.delegated.debugTypes());
        for (const contribution of this.debuggers) {
            debugTypes.add(contribution.type);
        }
        for (const debugType of this.contributors.keys()) {
            debugTypes.add(debugType);
        }
        return [...debugTypes];
    }
    async provideDebugConfigurations(debugType, workspaceFolderUri) {
        const pluginProviders = Array.from(this.configurationProviders.values()).filter(p => (p.triggerKind === plugin_api_rpc_1.DebugConfigurationProviderTriggerKind.Initial &&
            (p.type === debugType || p.type === '*') &&
            p.provideDebugConfigurations));
        if (pluginProviders.length === 0) {
            return this.delegated.provideDebugConfigurations(debugType, workspaceFolderUri);
        }
        const results = [];
        await Promise.all(pluginProviders.map(async (p) => {
            const result = await p.provideDebugConfigurations(workspaceFolderUri);
            if (result) {
                results.push(...result);
            }
        }));
        return results;
    }
    async fetchDynamicDebugConfiguration(name, providerType, folder) {
        const pluginProviders = Array.from(this.configurationProviders.values()).filter(p => (p.triggerKind === plugin_api_rpc_1.DebugConfigurationProviderTriggerKind.Dynamic &&
            p.type === providerType &&
            p.provideDebugConfigurations));
        for (const provider of pluginProviders) {
            const configurations = await provider.provideDebugConfigurations(folder);
            for (const configuration of configurations) {
                if (configuration.name === name) {
                    return configuration;
                }
            }
        }
    }
    async provideDynamicDebugConfigurations(folder) {
        const pluginProviders = Array.from(this.configurationProviders.values()).filter(p => (p.triggerKind === plugin_api_rpc_1.DebugConfigurationProviderTriggerKind.Dynamic &&
            p.provideDebugConfigurations));
        const configurationsRecord = {};
        await Promise.all(pluginProviders.map(async (provider) => {
            const configurations = await provider.provideDebugConfigurations(folder);
            let configurationsPerType = configurationsRecord[provider.type];
            configurationsPerType = configurationsPerType ? configurationsPerType.concat(configurations) : configurations;
            if (configurationsPerType.length > 0) {
                configurationsRecord[provider.type] = configurationsPerType;
            }
        }));
        return configurationsRecord;
    }
    async resolveDebugConfiguration(config, workspaceFolderUri) {
        const allProviders = Array.from(this.configurationProviders.values());
        const resolvers = allProviders
            .filter(p => p.type === config.type && !!p.resolveDebugConfiguration)
            .map(p => p.resolveDebugConfiguration);
        // Append debug type '*' at the end
        resolvers.push(...allProviders
            .filter(p => p.type === '*' && !!p.resolveDebugConfiguration)
            .map(p => p.resolveDebugConfiguration));
        const resolved = await this.resolveDebugConfigurationByResolversChain(config, workspaceFolderUri, resolvers);
        return resolved ? this.delegated.resolveDebugConfiguration(resolved, workspaceFolderUri) : resolved;
    }
    async resolveDebugConfigurationWithSubstitutedVariables(config, workspaceFolderUri) {
        const allProviders = Array.from(this.configurationProviders.values());
        const resolvers = allProviders
            .filter(p => p.type === config.type && !!p.resolveDebugConfigurationWithSubstitutedVariables)
            .map(p => p.resolveDebugConfigurationWithSubstitutedVariables);
        // Append debug type '*' at the end
        resolvers.push(...allProviders
            .filter(p => p.type === '*' && !!p.resolveDebugConfigurationWithSubstitutedVariables)
            .map(p => p.resolveDebugConfigurationWithSubstitutedVariables));
        const resolved = await this.resolveDebugConfigurationByResolversChain(config, workspaceFolderUri, resolvers);
        return resolved
            ? this.delegated.resolveDebugConfigurationWithSubstitutedVariables(resolved, workspaceFolderUri)
            : resolved;
    }
    async resolveDebugConfigurationByResolversChain(config, workspaceFolderUri, resolvers) {
        let resolved = config;
        for (const resolver of resolvers) {
            try {
                if (!resolved) {
                    // A provider has indicated to stop and process undefined or null as per specified in the vscode API
                    // https://code.visualstudio.com/api/references/vscode-api#DebugConfigurationProvider
                    break;
                }
                resolved = await resolver(workspaceFolderUri, resolved);
            }
            catch (e) {
                console.error(e);
            }
        }
        return resolved;
    }
    registerDebugger(contribution) {
        this.debuggers.push(contribution);
        return disposable_1.Disposable.create(() => {
            const index = this.debuggers.indexOf(contribution);
            if (index !== -1) {
                this.debuggers.splice(index, 1);
            }
        });
    }
    async provideDebuggerVariables(debugType) {
        for (const contribution of this.debuggers) {
            if (contribution.type === debugType) {
                const variables = contribution.variables;
                if (variables && Object.keys(variables).length > 0) {
                    return variables;
                }
            }
        }
        return {};
    }
    async getDebuggersForLanguage(language) {
        const debuggers = await this.delegated.getDebuggersForLanguage(language);
        for (const contributor of this.debuggers) {
            const languages = contributor.languages;
            if (languages && languages.indexOf(language) !== -1) {
                const { label, type } = contributor;
                debuggers.push({ type, label: label || type });
            }
        }
        return debuggers;
    }
    async getSchemaAttributes(debugType) {
        let schemas = await this.delegated.getSchemaAttributes(debugType);
        for (const contribution of this.debuggers) {
            if (contribution.configurationAttributes &&
                (contribution.type === debugType || contribution.type === '*' || debugType === '*')) {
                schemas = schemas.concat(this.resolveSchemaAttributes(contribution.type, contribution.configurationAttributes));
            }
        }
        return schemas;
    }
    resolveSchemaAttributes(type, configurationAttributes) {
        const taskSchema = {};
        return Object.keys(configurationAttributes).map(request => {
            const attributes = (0, core_1.deepClone)(configurationAttributes[request]);
            const defaultRequired = ['name', 'type', 'request'];
            attributes.required = attributes.required && attributes.required.length ? defaultRequired.concat(attributes.required) : defaultRequired;
            attributes.additionalProperties = false;
            attributes.type = 'object';
            if (!attributes.properties) {
                attributes.properties = {};
            }
            const properties = attributes.properties;
            properties['type'] = {
                enum: [type],
                description: core_1.nls.localizeByDefault('Type of configuration.'),
                pattern: '^(?!node2)',
                errorMessage: core_1.nls.localizeByDefault('The debug type is not recognized. Make sure that you have a corresponding debug extension installed and that it is enabled.'),
                patternErrorMessage: core_1.nls.localizeByDefault('"node2" is no longer supported, use "node" instead and set the "protocol" attribute to "inspector".')
            };
            properties['name'] = {
                type: 'string',
                description: core_1.nls.localizeByDefault('Name of configuration; appears in the launch configuration dropdown menu.'),
                default: 'Launch'
            };
            properties['request'] = {
                enum: [request],
                description: core_1.nls.localizeByDefault('Request type of configuration. Can be "launch" or "attach".'),
            };
            properties['debugServer'] = {
                type: 'number',
                description: core_1.nls.localizeByDefault('For debug extension development only: if a port is specified VS Code tries to connect to a debug adapter running in server mode'),
                default: 4711
            };
            properties['preLaunchTask'] = {
                anyOf: [taskSchema, {
                        type: ['string'],
                    }],
                default: '',
                description: core_1.nls.localizeByDefault('Task to run before debug session starts.')
            };
            properties['postDebugTask'] = {
                anyOf: [taskSchema, {
                        type: ['string'],
                    }],
                default: '',
                description: core_1.nls.localizeByDefault('Task to run after debug session ends.')
            };
            properties['internalConsoleOptions'] = {
                enum: ['neverOpen', 'openOnSessionStart', 'openOnFirstSessionStart'],
                default: 'openOnFirstSessionStart',
                description: core_1.nls.localizeByDefault('Controls when the internal Debug Console should open.')
            };
            properties['suppressMultipleSessionWarning'] = {
                type: 'boolean',
                description: core_1.nls.localizeByDefault('Disable the warning when trying to start the same debug configuration more than once.'),
                default: true
            };
            const osProperties = Object.assign({}, properties);
            properties['windows'] = {
                type: 'object',
                description: core_1.nls.localizeByDefault('Windows specific launch configuration attributes.'),
                properties: osProperties
            };
            properties['osx'] = {
                type: 'object',
                description: core_1.nls.localizeByDefault('OS X specific launch configuration attributes.'),
                properties: osProperties
            };
            properties['linux'] = {
                type: 'object',
                description: core_1.nls.localizeByDefault('Linux specific launch configuration attributes.'),
                properties: osProperties
            };
            Object.keys(attributes.properties).forEach(name => {
                // Use schema allOf property to get independent error reporting #21113
                attributes.properties[name].pattern = attributes.properties[name].pattern || '^(?!.*\\$\\{(env|config|command)\\.)';
                attributes.properties[name].patternErrorMessage = attributes.properties[name].patternErrorMessage ||
                    core_1.nls.localizeByDefault("'env.', 'config.' and 'command.' are deprecated, use 'env:', 'config:' and 'command:' instead.");
            });
            return attributes;
        });
    }
    async getConfigurationSnippets() {
        let snippets = await this.delegated.getConfigurationSnippets();
        for (const contribution of this.debuggers) {
            if (contribution.configurationSnippets) {
                snippets = snippets.concat(contribution.configurationSnippets);
            }
        }
        return snippets;
    }
    async createDebugSession(config, workspaceFolder) {
        const contributor = this.contributors.get(config.type);
        if (contributor) {
            const sessionId = await contributor.createDebugSession(config, workspaceFolder);
            this.sessionId2contrib.set(sessionId, contributor);
            return sessionId;
        }
        else {
            return this.delegated.createDebugSession(config, workspaceFolder);
        }
    }
    async terminateDebugSession(sessionId) {
        const contributor = this.sessionId2contrib.get(sessionId);
        if (contributor) {
            this.sessionId2contrib.delete(sessionId);
            return contributor.terminateDebugSession(sessionId);
        }
        else {
            return this.delegated.terminateDebugSession(sessionId);
        }
    }
    dispose() {
        this.toDispose.dispose();
    }
};
exports.PluginDebugService = PluginDebugService;
tslib_1.__decorate([
    (0, inversify_1.inject)(ws_connection_provider_1.WebSocketConnectionProvider),
    tslib_1.__metadata("design:type", ws_connection_provider_1.WebSocketConnectionProvider)
], PluginDebugService.prototype, "connectionProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.WorkspaceService),
    tslib_1.__metadata("design:type", browser_1.WorkspaceService)
], PluginDebugService.prototype, "workspaceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], PluginDebugService.prototype, "init", null);
exports.PluginDebugService = PluginDebugService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginDebugService);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-session-contribution-registry.js"
/*!*****************************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-session-contribution-registry.js ***!
  \*****************************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginDebugSessionContributionRegistry = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const debug_session_contribution_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-session-contribution */ "../../node_modules/@theia/debug/lib/browser/debug-session-contribution.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const contribution_provider_1 = __webpack_require__(/*! @theia/core/lib/common/contribution-provider */ "../../node_modules/@theia/core/lib/common/contribution-provider.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
/**
 * Plugin debug session contribution registry implementation with functionality
 * to register / unregister plugin contributions.
 */
let PluginDebugSessionContributionRegistry = class PluginDebugSessionContributionRegistry {
    constructor() {
        this.contribs = new Map();
    }
    init() {
        for (const contrib of this.contributions.getContributions()) {
            this.contribs.set(contrib.debugType, contrib);
        }
    }
    get(debugType) {
        return this.contribs.get(debugType);
    }
    registerDebugSessionContribution(contrib) {
        const { debugType } = contrib;
        if (this.contribs.has(debugType)) {
            console.warn(`Debug session contribution already registered for ${debugType}`);
            return disposable_1.Disposable.NULL;
        }
        this.contribs.set(debugType, contrib);
        return disposable_1.Disposable.create(() => this.unregisterDebugSessionContribution(debugType));
    }
    unregisterDebugSessionContribution(debugType) {
        this.contribs.delete(debugType);
    }
};
exports.PluginDebugSessionContributionRegistry = PluginDebugSessionContributionRegistry;
tslib_1.__decorate([
    (0, inversify_1.inject)(contribution_provider_1.ContributionProvider),
    (0, inversify_1.named)(debug_session_contribution_1.DebugSessionContribution),
    tslib_1.__metadata("design:type", Object)
], PluginDebugSessionContributionRegistry.prototype, "contributions", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], PluginDebugSessionContributionRegistry.prototype, "init", null);
exports.PluginDebugSessionContributionRegistry = PluginDebugSessionContributionRegistry = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginDebugSessionContributionRegistry);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-session-factory.js"
/*!***************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-session-factory.js ***!
  \***************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginDebugSessionFactory = exports.PluginDebugSession = void 0;
const debug_session_contribution_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-session-contribution */ "../../node_modules/@theia/debug/lib/browser/debug-session-contribution.js");
const debug_session_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-session */ "../../node_modules/@theia/debug/lib/browser/debug-session.js");
const debug_session_connection_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-session-connection */ "../../node_modules/@theia/debug/lib/browser/debug-session-connection.js");
class PluginDebugSession extends debug_session_1.DebugSession {
    constructor(id, options, parentSession, testService, testRun, sessionManager, connection, terminalServer, editorManager, breakpoints, labelProvider, messages, fileService, terminalOptionsExt, debugContributionProvider, workspaceService, debugPreferences, commandService) {
        super(id, options, parentSession, testService, testRun, sessionManager, connection, terminalServer, editorManager, breakpoints, labelProvider, messages, fileService, debugContributionProvider, workspaceService, debugPreferences, commandService);
        this.id = id;
        this.options = options;
        this.parentSession = parentSession;
        this.connection = connection;
        this.terminalServer = terminalServer;
        this.editorManager = editorManager;
        this.breakpoints = breakpoints;
        this.labelProvider = labelProvider;
        this.messages = messages;
        this.fileService = fileService;
        this.terminalOptionsExt = terminalOptionsExt;
        this.debugContributionProvider = debugContributionProvider;
        this.workspaceService = workspaceService;
        this.commandService = commandService;
    }
    async doCreateTerminal(terminalWidgetOptions) {
        terminalWidgetOptions = Object.assign({}, terminalWidgetOptions, this.terminalOptionsExt);
        return super.doCreateTerminal(terminalWidgetOptions);
    }
}
exports.PluginDebugSession = PluginDebugSession;
/**
 * Session factory for a client debug session that communicates with debug adapter contributed as plugin.
 * The main difference is to use a connection factory that creates [Channel](#Channel) over Rpc channel.
 */
class PluginDebugSessionFactory extends debug_session_contribution_1.DefaultDebugSessionFactory {
    constructor(terminalService, editorManager, breakpoints, labelProvider, messages, outputChannelManager, debugPreferences, connectionFactory, fileService, terminalOptionsExt, debugContributionProvider, testService, workspaceService, commandService) {
        super();
        this.terminalService = terminalService;
        this.editorManager = editorManager;
        this.breakpoints = breakpoints;
        this.labelProvider = labelProvider;
        this.messages = messages;
        this.outputChannelManager = outputChannelManager;
        this.debugPreferences = debugPreferences;
        this.connectionFactory = connectionFactory;
        this.fileService = fileService;
        this.terminalOptionsExt = terminalOptionsExt;
        this.debugContributionProvider = debugContributionProvider;
        this.testService = testService;
        this.workspaceService = workspaceService;
        this.commandService = commandService;
    }
    get(manager, sessionId, options, parentSession) {
        const connection = new debug_session_connection_1.DebugSessionConnection(sessionId, this.connectionFactory, this.getTraceOutputChannel());
        return new PluginDebugSession(sessionId, options, parentSession, this.testService, options.testRun, manager, connection, this.terminalService, this.editorManager, this.breakpoints, this.labelProvider, this.messages, this.fileService, this.terminalOptionsExt, this.debugContributionProvider, this.workspaceService, this.debugPreferences, this.commandService);
    }
}
exports.PluginDebugSessionFactory = PluginDebugSessionFactory;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/decorations/decorations-main.js"
/*!*********************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/decorations/decorations-main.js ***!
  \*********************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DecorationsMainImpl = void 0;
// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const plugin_api_rpc_1 = __webpack_require__(/*! ../../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../node_modules/@theia/core/lib/common/event.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../../node_modules/@theia/core/shared/vscode-uri/index.js");
const cancellation_1 = __webpack_require__(/*! @theia/core/lib/common/cancellation */ "../../node_modules/@theia/core/lib/common/cancellation.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../../node_modules/@theia/core/lib/common/uri.js");
const decorations_service_1 = __webpack_require__(/*! @theia/core/lib/browser/decorations-service */ "../../node_modules/@theia/core/lib/browser/decorations-service.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/1.52.1/src/vs/workbench/api/browser/mainThreadDecorations.ts#L85
class DecorationRequestsQueue {
    constructor(proxy, handle) {
        this.proxy = proxy;
        this.handle = handle;
        this.idPool = 0;
        this.requests = new Map();
        this.resolver = new Map();
    }
    enqueue(uri, token) {
        const id = ++this.idPool;
        const result = new Promise(resolve => {
            this.requests.set(id, { id, uri: vscode_uri_1.URI.parse(uri.toString()) });
            this.resolver.set(id, resolve);
            this.processQueue();
        });
        token.onCancellationRequested(() => {
            this.requests.delete(id);
            this.resolver.delete(id);
        });
        return result;
    }
    processQueue() {
        if (typeof this.timer === 'number') {
            // already queued
            return;
        }
        this.timer = setTimeout(() => {
            // make request
            const requests = this.requests;
            const resolver = this.resolver;
            this.proxy.$provideDecorations(this.handle, [...requests.values()], cancellation_1.CancellationToken.None).then(data => {
                for (const [id, resolve] of resolver) {
                    resolve(data[id]);
                }
            });
            // reset
            this.requests = new Map();
            this.resolver = new Map();
            this.timer = undefined;
        }, 0);
    }
}
class DecorationsMainImpl {
    constructor(rpc, container) {
        this.providers = new Map();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.DECORATIONS_EXT);
        this.decorationsService = container.get(decorations_service_1.DecorationsService);
    }
    dispose() {
        this.providers.forEach(value => value.forEach(v => v.dispose()));
        this.providers.clear();
    }
    async $registerDecorationProvider(handle) {
        const emitter = new event_1.Emitter();
        const queue = new DecorationRequestsQueue(this.proxy, handle);
        const registration = this.decorationsService.registerDecorationsProvider({
            onDidChange: emitter.event,
            provideDecorations: async (uri, token) => {
                const data = await queue.enqueue(uri, token);
                if (!data) {
                    return undefined;
                }
                const [bubble, tooltip, letter, themeColor] = data;
                return {
                    weight: 10,
                    bubble: bubble !== null && bubble !== void 0 ? bubble : false,
                    colorId: themeColor === null || themeColor === void 0 ? void 0 : themeColor.id,
                    tooltip,
                    letter
                };
            }
        });
        this.providers.set(handle, [emitter, registration]);
    }
    $onDidChange(handle, resources) {
        const providerSet = this.providers.get(handle);
        if (providerSet) {
            const [emitter] = providerSet;
            emitter.fire(resources && resources.map(r => new uri_1.default(vscode_uri_1.URI.revive(r).toString())));
        }
    }
    $unregisterDecorationProvider(handle) {
        const provider = this.providers.get(handle);
        if (provider) {
            provider.forEach(p => p.dispose());
            this.providers.delete(handle);
        }
    }
}
exports.DecorationsMainImpl = DecorationsMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/dialogs-main.js"
/*!*****************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/dialogs-main.js ***!
  \*****************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DialogsMainImpl = void 0;
const browser_1 = __webpack_require__(/*! @theia/filesystem/lib/browser */ "../../node_modules/@theia/filesystem/lib/browser/index.js");
const browser_2 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../../node_modules/@theia/workspace/lib/browser/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../../node_modules/@theia/core/lib/common/uri.js");
const file_upload_1 = __webpack_require__(/*! @theia/filesystem/lib/common/upload/file-upload */ "../../node_modules/@theia/filesystem/lib/common/upload/file-upload.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../../node_modules/@theia/filesystem/lib/browser/file-service.js");
const env_variables_1 = __webpack_require__(/*! @theia/core/lib/common/env-variables */ "../../node_modules/@theia/core/lib/common/env-variables/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
class DialogsMainImpl {
    constructor(rpc, container) {
        this.workspaceService = container.get(browser_2.WorkspaceService);
        this.fileService = container.get(file_service_1.FileService);
        this.environments = container.get(env_variables_1.EnvVariablesServer);
        this.fileDialogService = container.get(browser_1.FileDialogService);
        this.uploadService = container.get(file_upload_1.FileUploadService);
    }
    async getRootStat(defaultUri) {
        let rootStat;
        // Try to use default URI as root
        if (defaultUri) {
            try {
                rootStat = await this.fileService.resolve(new uri_1.default(defaultUri));
            }
            catch {
                rootStat = undefined;
            }
            // Try to use as root the parent folder of existing file URI/non existing URI
            if (rootStat && !rootStat.isDirectory || !rootStat) {
                try {
                    rootStat = await this.fileService.resolve(new uri_1.default(defaultUri).parent);
                }
                catch {
                    rootStat = undefined;
                }
            }
        }
        // Try to use workspace service root if there is no pre-configured URI
        if (!rootStat) {
            rootStat = (await this.workspaceService.roots)[0];
        }
        // Try to use current user home if root folder is still not taken
        if (!rootStat) {
            const homeDirUri = await this.environments.getHomeDirUri();
            try {
                rootStat = await this.fileService.resolve(new uri_1.default(homeDirUri));
            }
            catch { }
        }
        return rootStat;
    }
    async $showOpenDialog(options) {
        const rootStat = await this.getRootStat(options.defaultUri ? options.defaultUri : undefined);
        if (!rootStat) {
            throw new Error('Unable to find the rootStat');
        }
        try {
            const canSelectFiles = typeof options.canSelectFiles === 'boolean' ? options.canSelectFiles : true;
            const canSelectFolders = typeof options.canSelectFolders === 'boolean' ? options.canSelectFolders : true;
            let title = options.title;
            if (!title) {
                if (canSelectFiles && canSelectFolders) {
                    title = 'Open';
                }
                else {
                    if (canSelectFiles) {
                        title = 'Open File';
                    }
                    else {
                        title = 'Open Folder';
                    }
                    if (options.canSelectMany) {
                        title += '(s)';
                    }
                }
            }
            // Create open file dialog props
            const dialogProps = {
                title: title,
                openLabel: options.openLabel,
                canSelectFiles: options.canSelectFiles,
                canSelectFolders: options.canSelectFolders,
                canSelectMany: options.canSelectMany,
                filters: options.filters
            };
            const result = await this.fileDialogService.showOpenDialog(dialogProps, rootStat);
            if (Array.isArray(result)) {
                return result.map(uri => uri.path.toString());
            }
            else {
                return result ? [result].map(uri => uri.path.toString()) : undefined;
            }
        }
        catch (error) {
            console.error(error);
        }
        return undefined;
    }
    async $showSaveDialog(options) {
        var _a;
        const rootStat = await this.getRootStat(options.defaultUri ? options.defaultUri : undefined);
        // File name field should be empty unless the URI is a file
        let fileNameValue = '';
        if (options.defaultUri) {
            let defaultURIStat;
            try {
                defaultURIStat = await this.fileService.resolve(new uri_1.default(options.defaultUri));
            }
            catch { }
            if (defaultURIStat && !defaultURIStat.isDirectory || !defaultURIStat) {
                fileNameValue = new uri_1.default(options.defaultUri).path.base;
            }
        }
        try {
            // Create save file dialog props
            const dialogProps = {
                title: (_a = options.title) !== null && _a !== void 0 ? _a : core_1.nls.localizeByDefault('Save'),
                saveLabel: options.saveLabel,
                filters: options.filters,
                inputValue: fileNameValue
            };
            const result = await this.fileDialogService.showSaveDialog(dialogProps, rootStat);
            if (result) {
                return result.path.toString();
            }
            return undefined;
        }
        catch (error) {
            console.error(error);
        }
        return undefined;
    }
    async $showUploadDialog(options) {
        const rootStat = await this.getRootStat(options.defaultUri);
        // Fail if root not fount
        if (!rootStat) {
            throw new Error('Failed to resolve base directory where files should be uploaded');
        }
        const uploadResult = await this.uploadService.upload(rootStat.resource.toString());
        if (uploadResult) {
            return uploadResult.uploaded;
        }
        return undefined;
    }
}
exports.DialogsMainImpl = DialogsMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/dialogs/modal-notification.js"
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/dialogs/modal-notification.js ***!
  \*******************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ModalNotification = exports.MessageType = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const dialogs_1 = __webpack_require__(/*! @theia/core/lib/browser/dialogs */ "../../node_modules/@theia/core/lib/browser/dialogs.js");
__webpack_require__(/*! ../../../../src/main/browser/dialogs/style/modal-notification.css */ "../../node_modules/@theia/plugin-ext/src/main/browser/dialogs/style/modal-notification.css");
const frontend_application_config_provider_1 = __webpack_require__(/*! @theia/core/lib/browser/frontend-application-config-provider */ "../../node_modules/@theia/core/lib/browser/frontend-application-config-provider.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../../node_modules/@theia/core/lib/common/nls.js");
var MessageType;
(function (MessageType) {
    MessageType["Error"] = "error";
    MessageType["Warning"] = "warning";
    MessageType["Info"] = "info";
})(MessageType || (exports.MessageType = MessageType = {}));
const NOTIFICATION = 'modal-Notification';
const ICON = 'icon';
const TEXT = 'text';
const DETAIL = 'detail';
let ModalNotification = class ModalNotification extends dialogs_1.AbstractDialog {
    constructor() {
        super({ title: frontend_application_config_provider_1.FrontendApplicationConfigProvider.get().applicationName });
    }
    onCloseRequest(msg) {
        this.actionTitle = undefined;
        this.accept();
    }
    get value() {
        return this.actionTitle;
    }
    showDialog(messageType, text, options, actions) {
        this.contentNode.appendChild(this.createMessageNode(messageType, text, options, actions));
        return this.open();
    }
    createMessageNode(messageType, text, options, actions) {
        const messageNode = document.createElement('div');
        messageNode.classList.add(NOTIFICATION);
        const iconContainer = messageNode.appendChild(document.createElement('div'));
        iconContainer.classList.add(ICON);
        const iconElement = iconContainer.appendChild(document.createElement('i'));
        iconElement.classList.add(...this.toIconClass(messageType), messageType.toString());
        const textContainer = messageNode.appendChild(document.createElement('div'));
        textContainer.classList.add(TEXT);
        const textElement = textContainer.appendChild(document.createElement('p'));
        textElement.textContent = text;
        if (options.detail) {
            const detailContainer = textContainer.appendChild(document.createElement('div'));
            detailContainer.classList.add(DETAIL);
            const detailElement = detailContainer.appendChild(document.createElement('p'));
            detailElement.textContent = options.detail;
        }
        actions.forEach((action, index) => {
            const button = index === 0
                ? this.appendAcceptButton(action.title)
                : this.createButton(action.title);
            button.classList.add('main');
            this.controlPanel.appendChild(button);
            this.addKeyListener(button, browser_1.Key.ENTER, () => {
                this.actionTitle = action.title;
                this.accept();
            }, 'click');
        });
        if (actions.length <= 0) {
            this.appendAcceptButton();
        }
        else if (!actions.some(action => action.isCloseAffordance === true)) {
            this.appendCloseButton(nls_1.nls.localizeByDefault('Close'));
        }
        return messageNode;
    }
    toIconClass(icon) {
        if (icon === MessageType.Error) {
            return (0, browser_1.codiconArray)('error');
        }
        if (icon === MessageType.Warning) {
            return (0, browser_1.codiconArray)('warning');
        }
        return (0, browser_1.codiconArray)('info');
    }
};
exports.ModalNotification = ModalNotification;
exports.ModalNotification = ModalNotification = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], ModalNotification);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/documents-main.js"
/*!*******************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/documents-main.js ***!
  \*******************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentsMainImpl = exports.ModelReferenceCollection = void 0;
// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../../node_modules/@theia/core/lib/common/uri.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../../node_modules/@theia/core/shared/vscode-uri/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const disposable_util_1 = __webpack_require__(/*! ../../common/disposable-util */ "../../node_modules/@theia/plugin-ext/lib/common/disposable-util.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const types_impl_1 = __webpack_require__(/*! ../../plugin/types-impl */ "../../node_modules/@theia/plugin-ext/lib/plugin/types-impl.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
class ModelReferenceCollection {
    constructor(maxAge = 1000 * 60 * 3, maxLength = 1024 * 1024 * 80) {
        this.maxAge = maxAge;
        this.maxLength = maxLength;
        this.data = new Array();
        this.length = 0;
    }
    dispose() {
        this.data = (0, disposable_util_1.dispose)(this.data) || [];
    }
    add(ref) {
        const length = ref.object.textEditorModel.getValueLength();
        const handle = setTimeout(_dispose, this.maxAge);
        const entry = { length, dispose: _dispose };
        const self = this;
        function _dispose() {
            const idx = self.data.indexOf(entry);
            if (idx >= 0) {
                self.length -= length;
                ref.dispose();
                clearTimeout(handle);
                self.data.splice(idx, 1);
            }
        }
        ;
        this.data.push(entry);
        this.length += length;
        this.cleanup();
    }
    cleanup() {
        while (this.length > this.maxLength) {
            this.data[0].dispose();
        }
    }
}
exports.ModelReferenceCollection = ModelReferenceCollection;
class DocumentsMainImpl {
    constructor(editorsAndDocuments, notebookDocuments, modelService, rpc, openerService, shell, untitledResourceResolver, languageService) {
        this.modelService = modelService;
        this.openerService = openerService;
        this.shell = shell;
        this.untitledResourceResolver = untitledResourceResolver;
        this.languageService = languageService;
        this.syncedModels = new Map();
        this.modelReferenceCache = new ModelReferenceCollection();
        this.saveTimeout = 1750;
        this.toDispose = new core_1.DisposableCollection(this.modelReferenceCache);
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.DOCUMENTS_EXT);
        this.toDispose.push(editorsAndDocuments);
        this.toDispose.push(editorsAndDocuments.onDocumentAdd(documents => documents.forEach(this.onModelAdded, this)));
        this.toDispose.push(editorsAndDocuments.onDocumentRemove(documents => documents.forEach(this.onModelRemoved, this)));
        this.toDispose.push(modelService.onModelModeChanged(this.onModelChanged, this));
        this.toDispose.push(notebookDocuments.onDidAddNotebookCellModel(this.onModelAdded, this));
        this.toDispose.push(modelService.onModelSaved(m => {
            this.proxy.$acceptModelSaved(m.textEditorModel.uri);
        }));
        this.toDispose.push(modelService.onModelWillSave(async (e) => {
            var _a, _b;
            const saveReason = (_b = (_a = e.options) === null || _a === void 0 ? void 0 : _a.saveReason) !== null && _b !== void 0 ? _b : browser_1.SaveReason.Manual;
            const edits = await this.proxy.$acceptModelWillSave(new uri_1.default(e.model.uri).toComponents(), saveReason.valueOf(), this.saveTimeout);
            const editOperations = [];
            for (const edit of edits) {
                const { range, text } = edit;
                if (!range && !text) {
                    continue;
                }
                if (range && range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn && !edit.text) {
                    continue;
                }
                editOperations.push({
                    range: range ? monaco.Range.lift(range) : e.model.textEditorModel.getFullModelRange(),
                    /* eslint-disable-next-line no-null/no-null */
                    text: text || null,
                    forceMoveMarkers: edit.forceMoveMarkers
                });
            }
            e.model.textEditorModel.applyEdits(editOperations);
        }));
        this.toDispose.push(modelService.onModelDirtyChanged(m => {
            this.proxy.$acceptDirtyStateChanged(m.textEditorModel.uri, m.dirty);
        }));
        this.toDispose.push(modelService.onModelEncodingChanged(e => {
            this.proxy.$acceptEncodingChanged(e.model.textEditorModel.uri, e.encoding);
        }));
    }
    dispose() {
        this.toDispose.dispose();
    }
    onModelChanged(event) {
        const modelUrl = event.model.textEditorModel.uri;
        if (this.syncedModels.has(modelUrl.toString())) {
            this.proxy.$acceptModelModeChanged(modelUrl, event.oldModeId, event.model.languageId);
        }
    }
    onModelAdded(model) {
        const modelUri = model.textEditorModel.uri;
        const key = modelUri.toString();
        const toDispose = new core_1.DisposableCollection(model.textEditorModel.onDidChangeContent(e => this.proxy.$acceptModelChanged(modelUri, {
            eol: e.eol,
            versionId: e.versionId,
            reason: e.isRedoing ? types_impl_1.TextDocumentChangeReason.Redo : e.isUndoing ? types_impl_1.TextDocumentChangeReason.Undo : undefined,
            changes: e.changes.map(c => ({
                text: c.text,
                range: c.range,
                rangeLength: c.rangeLength,
                rangeOffset: c.rangeOffset
            }))
        }, model.dirty)), core_1.Disposable.create(() => this.syncedModels.delete(key)));
        this.syncedModels.set(key, toDispose);
        this.toDispose.push(toDispose);
    }
    onModelRemoved(url) {
        const model = this.syncedModels.get(url.toString());
        if (model) {
            model.dispose();
        }
    }
    async $tryCreateDocument(options) {
        const language = (options === null || options === void 0 ? void 0 : options.language) && this.languageService.getExtension(options.language);
        const content = options === null || options === void 0 ? void 0 : options.content;
        const encoding = options === null || options === void 0 ? void 0 : options.encoding;
        const resource = await this.untitledResourceResolver.createUntitledResource(content, language, undefined, encoding);
        return monaco.Uri.parse(resource.uri.toString());
    }
    async $tryShowDocument(uri, options) {
        // Removing try-catch block here makes it not possible to handle errors.
        // Following message is appeared in browser console
        //   - Uncaught (in promise) Error: Cannot read property 'message' of undefined.
        try {
            const editorOptions = DocumentsMainImpl.toEditorOpenerOptions(this.shell, options);
            const uriArg = new uri_1.default(vscode_uri_1.URI.revive(uri));
            const opener = await this.openerService.getOpener(uriArg, editorOptions);
            await opener.open(uriArg, editorOptions);
        }
        catch (err) {
            throw new Error(err);
        }
    }
    async $trySaveDocument(uri) {
        return this.modelService.save(new uri_1.default(vscode_uri_1.URI.revive(uri)));
    }
    async $tryOpenDocument(uri, encoding) {
        // Convert URI to Theia URI
        const theiaUri = new uri_1.default(vscode_uri_1.URI.revive(uri));
        // Create model reference
        const ref = await this.modelService.createModelReference(theiaUri);
        if (ref.object) {
            // If we have encoding option, make sure to apply it
            if (encoding && ref.object.setEncoding) {
                try {
                    await ref.object.setEncoding(encoding, 1 /* EncodingMode.Decode */);
                }
                catch (e) {
                    // If encoding fails, log error but continue
                    console.error(`Failed to set encoding ${encoding} for ${theiaUri.toString()}`, e);
                }
            }
            this.modelReferenceCache.add(ref);
            return true;
        }
        else {
            ref.dispose();
            return false;
        }
    }
    static toEditorOpenerOptions(shell, options) {
        if (!options) {
            return undefined;
        }
        let range;
        if (options.selection) {
            const selection = options.selection;
            range = {
                start: { line: selection.startLineNumber - 1, character: selection.startColumn - 1 },
                end: { line: selection.endLineNumber - 1, character: selection.endColumn - 1 }
            };
        }
        /* fall back to side group -> split relative to the active widget */
        let widgetOptions = { mode: 'split-right' };
        let viewColumn = options.viewColumn;
        if (viewColumn === -2) {
            /* show besides -> compute current column and adjust viewColumn accordingly */
            const tabBars = shell.mainAreaTabBars;
            const currentTabBar = shell.currentTabBar;
            if (currentTabBar) {
                const currentColumn = tabBars.indexOf(currentTabBar);
                if (currentColumn > -1) {
                    // +2 because conversion from 0-based to 1-based index and increase of 1
                    viewColumn = currentColumn + 2;
                }
            }
        }
        if (viewColumn === undefined || viewColumn === -1) {
            /* active group -> skip (default behaviour) */
            widgetOptions = undefined;
        }
        else if (viewColumn > 0 && shell.mainAreaTabBars.length > 0) {
            const tabBars = shell.mainAreaTabBars;
            if (viewColumn <= tabBars.length) {
                // convert to zero-based index
                const tabBar = tabBars[viewColumn - 1];
                if (tabBar === null || tabBar === void 0 ? void 0 : tabBar.currentTitle) {
                    widgetOptions = { ref: tabBar.currentTitle.owner };
                }
            }
            else {
                const tabBar = tabBars[tabBars.length - 1];
                if (tabBar === null || tabBar === void 0 ? void 0 : tabBar.currentTitle) {
                    widgetOptions.ref = tabBar.currentTitle.owner;
                }
            }
        }
        return {
            selection: range,
            mode: options.preserveFocus ? 'reveal' : 'activate',
            preview: options.preview,
            widgetOptions
        };
    }
}
exports.DocumentsMainImpl = DocumentsMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/editors-and-documents-main.js"
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/editors-and-documents-main.js ***!
  \*******************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EditorsAndDocumentsMain = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const text_editor_model_service_1 = __webpack_require__(/*! ./text-editor-model-service */ "../../node_modules/@theia/plugin-ext/lib/main/browser/text-editor-model-service.js");
const monaco_editor_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor */ "../../node_modules/@theia/monaco/lib/browser/monaco-editor.js");
const text_editor_main_1 = __webpack_require__(/*! ./text-editor-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/text-editor-main.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/editor/lib/browser */ "../../node_modules/@theia/editor/lib/browser/index.js");
const saveable_service_1 = __webpack_require__(/*! @theia/core/lib/browser/saveable-service */ "../../node_modules/@theia/core/lib/browser/saveable-service.js");
const browser_2 = __webpack_require__(/*! @theia/notebook/lib/browser */ "../../node_modules/@theia/notebook/lib/browser/index.js");
const encoding_registry_1 = __webpack_require__(/*! @theia/core/lib/browser/encoding-registry */ "../../node_modules/@theia/core/lib/browser/encoding-registry.js");
class EditorsAndDocumentsMain {
    constructor(rpc, container, tabsMain) {
        this.textEditors = new Map();
        this.onTextEditorAddEmitter = new core_1.Emitter();
        this.onTextEditorRemoveEmitter = new core_1.Emitter();
        this.onDocumentAddEmitter = new core_1.Emitter();
        this.onDocumentRemoveEmitter = new core_1.Emitter();
        this.onTextEditorAdd = this.onTextEditorAddEmitter.event;
        this.onTextEditorRemove = this.onTextEditorRemoveEmitter.event;
        this.onDocumentAdd = this.onDocumentAddEmitter.event;
        this.onDocumentRemove = this.onDocumentRemoveEmitter.event;
        this.toDispose = new core_1.DisposableCollection(disposable_1.Disposable.create(() => this.textEditors.clear()));
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.EDITORS_AND_DOCUMENTS_EXT);
        this.editorManager = container.get(browser_1.EditorManager);
        this.modelService = container.get(text_editor_model_service_1.EditorModelService);
        this.saveResourceService = container.get(saveable_service_1.SaveableService);
        this.encodingRegistry = container.get(encoding_registry_1.EncodingRegistry);
        this.stateComputer = new EditorAndDocumentStateComputer(d => this.onDelta(d), this.editorManager, container.get(browser_2.NotebookCellEditorService), container.get(browser_2.NotebookEditorWidgetService), this.modelService, tabsMain);
        this.toDispose.push(this.stateComputer);
        this.toDispose.push(this.onTextEditorAddEmitter);
        this.toDispose.push(this.onTextEditorRemoveEmitter);
        this.toDispose.push(this.onDocumentAddEmitter);
        this.toDispose.push(this.onDocumentRemoveEmitter);
    }
    listen() {
        this.stateComputer.listen();
    }
    dispose() {
        this.toDispose.dispose();
    }
    onDelta(delta) {
        const removedEditors = new Array();
        const addedEditors = new Array();
        const removedDocuments = delta.removedDocuments.map(d => d.textEditorModel.uri);
        for (const editor of delta.addedEditors) {
            const textEditorMain = new text_editor_main_1.TextEditorMain(editor.id, editor.editor.getControl().getModel(), editor.editor);
            this.textEditors.set(editor.id, textEditorMain);
            this.toDispose.push(textEditorMain);
            addedEditors.push(textEditorMain);
        }
        for (const { id } of delta.removedEditors) {
            const textEditorMain = this.textEditors.get(id);
            if (textEditorMain) {
                textEditorMain.dispose();
                this.textEditors.delete(id);
                removedEditors.push(id);
            }
        }
        const deltaExt = {};
        let empty = true;
        if (delta.newActiveEditor !== undefined) {
            empty = false;
            deltaExt.newActiveEditor = delta.newActiveEditor;
        }
        if (removedDocuments.length > 0) {
            empty = false;
            deltaExt.removedDocuments = removedDocuments;
        }
        if (removedEditors.length > 0) {
            empty = false;
            deltaExt.removedEditors = removedEditors;
        }
        if (delta.addedDocuments.length > 0) {
            empty = false;
            deltaExt.addedDocuments = delta.addedDocuments.map(d => this.toModelAddData(d));
        }
        if (delta.addedEditors.length > 0) {
            empty = false;
            deltaExt.addedEditors = addedEditors.map(e => this.toTextEditorAddData(e));
        }
        if (!empty) {
            this.proxy.$acceptEditorsAndDocumentsDelta(deltaExt);
            this.onDocumentRemoveEmitter.fire(removedDocuments);
            this.onDocumentAddEmitter.fire(delta.addedDocuments);
            this.onTextEditorRemoveEmitter.fire(removedEditors);
            this.onTextEditorAddEmitter.fire(addedEditors);
        }
    }
    toModelAddData(model) {
        return {
            uri: model.textEditorModel.uri,
            versionId: model.textEditorModel.getVersionId(),
            lines: model.textEditorModel.getLinesContent(),
            languageId: model.getLanguageId(),
            EOL: model.textEditorModel.getEOL(),
            modeId: model.languageId,
            isDirty: model.dirty,
            encoding: this.encodingRegistry.getEncodingForResource(core_1.URI.fromComponents(model.textEditorModel.uri), model.getEncoding())
        };
    }
    toTextEditorAddData(textEditor) {
        const properties = textEditor.getProperties();
        return {
            id: textEditor.getId(),
            documentUri: textEditor.getModel().uri,
            options: properties.options,
            selections: properties.selections,
            visibleRanges: properties.visibleRanges,
            editorPosition: this.findEditorPosition(textEditor)
        };
    }
    findEditorPosition(editor) {
        return plugin_api_rpc_1.EditorPosition.ONE; // TODO: fix this when Theia has support splitting editors
    }
    getEditor(id) {
        return this.textEditors.get(id);
    }
    async save(uri) {
        const editor = await this.editorManager.getByUri(uri);
        if (!editor) {
            return undefined;
        }
        return this.saveResourceService.save(editor);
    }
    async saveAs(uri) {
        const editor = await this.editorManager.getByUri(uri);
        if (!editor) {
            return undefined;
        }
        if (!this.saveResourceService.canSaveAs(editor)) {
            return undefined;
        }
        return this.saveResourceService.saveAs(editor);
    }
    saveAll(includeUntitled) {
        return this.modelService.saveAll(includeUntitled);
    }
    hideEditor(id) {
        for (const editorWidget of this.editorManager.all) {
            const monacoEditor = monaco_editor_1.MonacoEditor.get(editorWidget);
            if (monacoEditor) {
                if (id === new EditorSnapshot(monacoEditor).id) {
                    editorWidget.close();
                    break;
                }
            }
        }
        return Promise.resolve();
    }
    getDiffInformation(id) {
        const editor = this.getEditor(id);
        return (editor === null || editor === void 0 ? void 0 : editor.diffInformation) || [];
    }
}
exports.EditorsAndDocumentsMain = EditorsAndDocumentsMain;
class EditorAndDocumentStateComputer {
    constructor(callback, editorService, cellEditorService, notebookWidgetService, modelService, tabsMain) {
        this.callback = callback;
        this.editorService = editorService;
        this.cellEditorService = cellEditorService;
        this.notebookWidgetService = notebookWidgetService;
        this.modelService = modelService;
        this.tabsMain = tabsMain;
        this.editors = new Map();
        this.toDispose = new core_1.DisposableCollection(disposable_1.Disposable.create(() => this.currentState = undefined));
    }
    listen() {
        if (this.toDispose.disposed) {
            return;
        }
        this.toDispose.push(this.editorService.onCreated(async (widget) => {
            await this.tabsMain.waitForWidget(widget);
            this.onTextEditorAdd(widget);
            this.update();
        }));
        this.toDispose.push(this.editorService.onCurrentEditorChanged(async (widget) => {
            if (widget) {
                await this.tabsMain.waitForWidget(widget);
            }
            this.update();
        }));
        this.toDispose.push(this.modelService.onModelAdded(this.onModelAdded, this));
        this.toDispose.push(this.modelService.onModelRemoved(() => this.update()));
        this.toDispose.push(this.cellEditorService.onDidChangeCellEditors(() => this.update()));
        this.toDispose.push(this.notebookWidgetService.onDidChangeCurrentEditor(() => {
            this.currentState = this.currentState && new EditorAndDocumentState(this.currentState.documents, this.currentState.editors, undefined);
        }));
        for (const widget of this.editorService.all) {
            this.onTextEditorAdd(widget);
        }
        this.update();
    }
    dispose() {
        this.toDispose.dispose();
    }
    onModelAdded(model) {
        if (!this.currentState) {
            this.update();
            return;
        }
        this.currentState = new EditorAndDocumentState(this.currentState.documents.add(model), this.currentState.editors, this.currentState.activeEditor);
        this.callback(new EditorAndDocumentStateDelta([], [model], [], [], undefined, undefined));
    }
    onTextEditorAdd(widget) {
        if (widget.isDisposed) {
            return;
        }
        const editor = monaco_editor_1.MonacoEditor.get(widget);
        if (!editor) {
            return;
        }
        const id = editor.getControl().getId();
        const toDispose = new core_1.DisposableCollection(editor.onDispose(() => this.onTextEditorRemove(editor)), disposable_1.Disposable.create(() => this.editors.delete(id)));
        this.editors.set(id, toDispose);
        this.toDispose.push(toDispose);
    }
    onTextEditorRemove(e) {
        const toDispose = this.editors.get(e.getControl().getId());
        if (toDispose) {
            toDispose.dispose();
            this.update();
        }
    }
    update() {
        var _a, _b;
        const models = new Set();
        for (const model of this.modelService.getModels()) {
            models.add(model);
        }
        let activeId = null;
        const activeEditor = (_a = monaco_editor_1.MonacoEditor.getCurrent(this.editorService)) !== null && _a !== void 0 ? _a : this.cellEditorService.getActiveCell();
        const editors = new Map();
        for (const widget of this.editorService.all) {
            const editor = monaco_editor_1.MonacoEditor.get(widget);
            // VS Code tracks only visible widgets
            if (!editor || !widget.isVisible) {
                continue;
            }
            const model = editor.getControl().getModel();
            if (model && !model.isDisposed()) {
                const editorSnapshot = new EditorSnapshot(editor);
                editors.set(editorSnapshot.id, editorSnapshot);
                if (activeEditor === editor) {
                    activeId = editorSnapshot.id;
                }
            }
        }
        for (const editor of this.cellEditorService.allCellEditors) {
            if ((_b = editor.getControl()) === null || _b === void 0 ? void 0 : _b.getModel()) {
                const editorSnapshot = new EditorSnapshot(editor);
                editors.set(editorSnapshot.id, editorSnapshot);
                if (activeEditor === editor) {
                    activeId = editorSnapshot.id;
                }
            }
        }
        ;
        const newState = new EditorAndDocumentState(models, editors, activeId);
        const delta = EditorAndDocumentState.compute(this.currentState, newState);
        if (!delta.isEmpty) {
            this.currentState = newState;
            this.callback(delta);
        }
    }
}
class EditorAndDocumentStateDelta {
    constructor(removedDocuments, addedDocuments, removedEditors, addedEditors, oldActiveEditor, newActiveEditor) {
        this.removedDocuments = removedDocuments;
        this.addedDocuments = addedDocuments;
        this.removedEditors = removedEditors;
        this.addedEditors = addedEditors;
        this.oldActiveEditor = oldActiveEditor;
        this.newActiveEditor = newActiveEditor;
        this.isEmpty = this.removedDocuments.length === 0
            && this.addedDocuments.length === 0
            && this.addedEditors.length === 0
            && this.removedEditors.length === 0
            && this.newActiveEditor === this.oldActiveEditor;
    }
}
class EditorAndDocumentState {
    constructor(documents, editors, activeEditor) {
        this.documents = documents;
        this.editors = editors;
        this.activeEditor = activeEditor;
    }
    static compute(before, after) {
        if (!before) {
            return new EditorAndDocumentStateDelta([], Array.from(after.documents), [], Array.from(after.editors.values()), undefined, after.activeEditor);
        }
        const documentDelta = Delta.ofSets(before.documents, after.documents);
        const editorDelta = Delta.ofMaps(before.editors, after.editors);
        const oldActiveEditor = before.activeEditor !== after.activeEditor ? before.activeEditor : undefined;
        const newActiveEditor = before.activeEditor !== after.activeEditor ? after.activeEditor : undefined;
        return new EditorAndDocumentStateDelta(documentDelta.removed, documentDelta.added, editorDelta.removed, editorDelta.added, oldActiveEditor, newActiveEditor);
    }
}
class EditorSnapshot {
    constructor(editor) {
        this.editor = editor;
        this.id = `${editor.getControl().getId()},${editor.getControl().getModel().id}`;
    }
}
var Delta;
(function (Delta) {
    function ofSets(before, after) {
        const removed = [];
        const added = [];
        before.forEach(element => {
            if (!after.has(element)) {
                removed.push(element);
            }
        });
        after.forEach(element => {
            if (!before.has(element)) {
                added.push(element);
            }
        });
        return { removed, added };
    }
    Delta.ofSets = ofSets;
    function ofMaps(before, after) {
        const removed = [];
        const added = [];
        before.forEach((value, index) => {
            if (!after.has(index)) {
                removed.push(value);
            }
        });
        after.forEach((value, index) => {
            if (!before.has(index)) {
                added.push(value);
            }
        });
        return { removed, added };
    }
    Delta.ofMaps = ofMaps;
})(Delta || (Delta = {}));


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/env-main.js"
/*!*************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/env-main.js ***!
  \*************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getQueryParameters = exports.EnvMainImpl = void 0;
var env_main_1 = __webpack_require__(/*! ../common/env-main */ "../../node_modules/@theia/plugin-ext/lib/main/common/env-main.js");
Object.defineProperty(exports, "EnvMainImpl", ({ enumerable: true, get: function () { return env_main_1.EnvMainImpl; } }));
/**
 * Returns query parameters from current page.
 */
function getQueryParameters() {
    const queryParameters = {};
    if (window.location.search !== '') {
        const queryParametersString = window.location.search.substring(1); // remove question mark
        const params = queryParametersString.split('&');
        for (const pair of params) {
            if (pair === '') {
                continue;
            }
            const keyValue = pair.split('=');
            let key = keyValue[0];
            let value = keyValue[1] ? keyValue[1] : '';
            try {
                key = decodeURIComponent(key);
                if (value !== '') {
                    value = decodeURIComponent(value);
                }
            }
            catch (error) {
                // skip malformed URI sequence
                continue;
            }
            const existedValue = queryParameters[key];
            if (existedValue) {
                if (existedValue instanceof Array) {
                    existedValue.push(value);
                }
                else {
                    // existed value is string
                    queryParameters[key] = [existedValue, value];
                }
            }
            else {
                queryParameters[key] = value;
            }
        }
    }
    return queryParameters;
}
exports.getQueryParameters = getQueryParameters;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/file-system-main-impl.js"
/*!**************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/file-system-main-impl.js ***!
  \**************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/workbench/api/browser/mainThreadFileSystem.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileSystemMainImpl = void 0;
/* eslint-disable max-len */
/* eslint-disable @typescript-eslint/tslint/config */
/* eslint-disable @typescript-eslint/no-explicit-any */
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../../node_modules/@theia/core/shared/vscode-uri/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../../node_modules/@theia/core/lib/common/uri.js");
const buffer_1 = __webpack_require__(/*! @theia/core/lib/common/buffer */ "../../node_modules/@theia/core/lib/common/buffer.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../node_modules/@theia/core/lib/common/event.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const files_1 = __webpack_require__(/*! @theia/filesystem/lib/common/files */ "../../node_modules/@theia/filesystem/lib/common/files.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../../node_modules/@theia/filesystem/lib/browser/file-service.js");
class FileSystemMainImpl {
    constructor(rpc, container) {
        this._fileProvider = new Map();
        this._disposables = new disposable_1.DisposableCollection();
        this._proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.FILE_SYSTEM_EXT);
        this._fileService = container.get(file_service_1.FileService);
        for (const { scheme, capabilities } of this._fileService.listCapabilities()) {
            this._proxy.$acceptProviderInfos(scheme, capabilities);
        }
        this._disposables.push(this._fileService.onDidChangeFileSystemProviderRegistrations(e => { var _a; return this._proxy.$acceptProviderInfos(e.scheme, (_a = e.provider) === null || _a === void 0 ? void 0 : _a.capabilities); }));
        this._disposables.push(this._fileService.onDidChangeFileSystemProviderCapabilities(e => this._proxy.$acceptProviderInfos(e.scheme, e.provider.capabilities)));
        this._disposables.push(disposable_1.Disposable.create(() => this._fileProvider.forEach(value => value.dispose())));
        this._disposables.push(disposable_1.Disposable.create(() => this._fileProvider.clear()));
    }
    dispose() {
        this._disposables.dispose();
    }
    $registerFileSystemProvider(handle, scheme, capabilities, readonlyMessage) {
        this._fileProvider.set(handle, new RemoteFileSystemProvider(this._fileService, scheme, capabilities, handle, this._proxy, readonlyMessage));
    }
    $unregisterProvider(handle) {
        const provider = this._fileProvider.get(handle);
        if (provider) {
            provider.dispose();
            this._fileProvider.delete(handle);
        }
    }
    $onFileSystemChange(handle, changes) {
        const fileProvider = this._fileProvider.get(handle);
        if (!fileProvider) {
            throw new Error('Unknown file provider');
        }
        fileProvider.$onFileSystemChange(changes);
    }
    // --- consumer fs, vscode.workspace.fs
    $stat(uri) {
        return this._fileService.resolve(new uri_1.default(vscode_uri_1.URI.revive(uri)), { resolveMetadata: true }).then(stat => ({
            ctime: stat.ctime,
            mtime: stat.mtime,
            size: stat.size,
            type: files_1.FileStat.asFileType(stat)
        })).catch(FileSystemMainImpl._handleError);
    }
    $readdir(uri) {
        return this._fileService.resolve(new uri_1.default(vscode_uri_1.URI.revive(uri)), { resolveMetadata: false }).then(stat => {
            if (!stat.isDirectory) {
                const err = new Error(stat.name);
                err.name = files_1.FileSystemProviderErrorCode.FileNotADirectory;
                throw err;
            }
            return !stat.children ? [] : stat.children.map(child => [child.name, files_1.FileStat.asFileType(child)]);
        }).catch(FileSystemMainImpl._handleError);
    }
    $readFile(uri) {
        return this._fileService.readFile(new uri_1.default(vscode_uri_1.URI.revive(uri))).then(file => file.value).catch(FileSystemMainImpl._handleError);
    }
    $writeFile(uri, content) {
        return this._fileService.writeFile(new uri_1.default(vscode_uri_1.URI.revive(uri)), content)
            .then(() => undefined).catch(FileSystemMainImpl._handleError);
    }
    $rename(source, target, opts) {
        return this._fileService.move(new uri_1.default(vscode_uri_1.URI.revive(source)), new uri_1.default(vscode_uri_1.URI.revive(target)), {
            ...opts,
            fromUserGesture: false
        }).then(() => undefined).catch(FileSystemMainImpl._handleError);
    }
    $copy(source, target, opts) {
        return this._fileService.copy(new uri_1.default(vscode_uri_1.URI.revive(source)), new uri_1.default(vscode_uri_1.URI.revive(target)), {
            ...opts,
            fromUserGesture: false
        }).then(() => undefined).catch(FileSystemMainImpl._handleError);
    }
    $mkdir(uri) {
        return this._fileService.createFolder(new uri_1.default(vscode_uri_1.URI.revive(uri)), { fromUserGesture: false })
            .then(() => undefined).catch(FileSystemMainImpl._handleError);
    }
    $delete(uri, opts) {
        return this._fileService.delete(new uri_1.default(vscode_uri_1.URI.revive(uri)), opts).catch(FileSystemMainImpl._handleError);
    }
    static _handleError(err) {
        if (err instanceof files_1.FileOperationError) {
            switch (err.fileOperationResult) {
                case 1 /* FileOperationResult.FILE_NOT_FOUND */:
                    err.name = files_1.FileSystemProviderErrorCode.FileNotFound;
                    break;
                case 0 /* FileOperationResult.FILE_IS_DIRECTORY */:
                    err.name = files_1.FileSystemProviderErrorCode.FileIsADirectory;
                    break;
                case 6 /* FileOperationResult.FILE_PERMISSION_DENIED */:
                    err.name = files_1.FileSystemProviderErrorCode.NoPermissions;
                    break;
                case 4 /* FileOperationResult.FILE_MOVE_CONFLICT */:
                    err.name = files_1.FileSystemProviderErrorCode.FileExists;
                    break;
            }
        }
        throw err;
    }
}
exports.FileSystemMainImpl = FileSystemMainImpl;
class RemoteFileSystemProvider {
    constructor(fileService, scheme, capabilities, _handle, _proxy, readOnlyMessage = undefined) {
        this._handle = _handle;
        this._proxy = _proxy;
        this.readOnlyMessage = readOnlyMessage;
        this._onDidChange = new event_1.Emitter();
        this.onDidChangeFile = this._onDidChange.event;
        this.onFileWatchError = new event_1.Emitter().event; // dummy, never fired
        this.onDidChangeCapabilities = event_1.Event.None;
        this.onDidChangeReadOnlyMessage = event_1.Event.None;
        this.capabilities = capabilities;
        this._registration = fileService.registerProvider(scheme, this);
    }
    dispose() {
        this._registration.dispose();
        this._onDidChange.dispose();
    }
    watch(resource, opts) {
        const session = Math.random();
        this._proxy.$watch(this._handle, session, resource['codeUri'], opts);
        return disposable_1.Disposable.create(() => {
            this._proxy.$unwatch(this._handle, session);
        });
    }
    $onFileSystemChange(changes) {
        this._onDidChange.fire(changes.map(RemoteFileSystemProvider._createFileChange));
    }
    static _createFileChange(dto) {
        return { resource: new uri_1.default(vscode_uri_1.URI.revive(dto.resource)), type: dto.type };
    }
    // --- forwarding calls
    stat(resource) {
        return this._proxy.$stat(this._handle, resource['codeUri']).then(undefined, err => {
            throw err;
        });
    }
    readFile(resource) {
        return this._proxy.$readFile(this._handle, resource['codeUri']).then(buffer => buffer.buffer);
    }
    writeFile(resource, content, opts) {
        return this._proxy.$writeFile(this._handle, resource['codeUri'], buffer_1.BinaryBuffer.wrap(content), opts);
    }
    delete(resource, opts) {
        return this._proxy.$delete(this._handle, resource['codeUri'], opts);
    }
    mkdir(resource) {
        return this._proxy.$mkdir(this._handle, resource['codeUri']);
    }
    readdir(resource) {
        return this._proxy.$readdir(this._handle, resource['codeUri']);
    }
    rename(resource, target, opts) {
        return this._proxy.$rename(this._handle, resource['codeUri'], target['codeUri'], opts);
    }
    copy(resource, target, opts) {
        return this._proxy.$copy(this._handle, resource['codeUri'], target['codeUri'], opts);
    }
    open(resource, opts) {
        return this._proxy.$open(this._handle, resource['codeUri'], opts);
    }
    close(fd) {
        return this._proxy.$close(this._handle, fd);
    }
    read(fd, pos, data, offset, length) {
        return this._proxy.$read(this._handle, fd, pos, length).then(readData => {
            data.set(readData.buffer, offset);
            return readData.byteLength;
        });
    }
    write(fd, pos, data, offset, length) {
        return this._proxy.$write(this._handle, fd, pos, buffer_1.BinaryBuffer.wrap(data).slice(offset, offset + length));
    }
}


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/keybindings/keybindings-contribution-handler.js"
/*!*************************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/keybindings/keybindings-contribution-handler.js ***!
  \*************************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeybindingsContributionPointHandler = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const keybinding_1 = __webpack_require__(/*! @theia/core/lib/browser/keybinding */ "../../node_modules/@theia/core/lib/browser/keybinding.js");
const os_1 = __webpack_require__(/*! @theia/core/lib/common/os */ "../../node_modules/@theia/core/lib/common/os.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
let KeybindingsContributionPointHandler = class KeybindingsContributionPointHandler {
    handle(contributions) {
        if (!contributions || !contributions.keybindings) {
            return disposable_1.Disposable.NULL;
        }
        const toDispose = new core_1.DisposableCollection();
        for (const raw of contributions.keybindings) {
            const keybinding = this.toKeybinding(raw);
            if (keybinding) {
                toDispose.push(this.keybindingRegistry.registerKeybinding(keybinding));
            }
        }
        return toDispose;
    }
    toKeybinding(pluginKeybinding) {
        const keybinding = this.toOSKeybinding(pluginKeybinding);
        if (!keybinding) {
            return undefined;
        }
        const { command, when, args } = pluginKeybinding;
        return { keybinding, command, when, args };
    }
    toOSKeybinding(pluginKeybinding) {
        let keybinding;
        const os = os_1.OS.type();
        if (os === os_1.OS.Type.Windows) {
            keybinding = pluginKeybinding.win;
        }
        else if (os === os_1.OS.Type.OSX) {
            keybinding = pluginKeybinding.mac;
        }
        else {
            keybinding = pluginKeybinding.linux;
        }
        return keybinding || pluginKeybinding.keybinding;
    }
};
exports.KeybindingsContributionPointHandler = KeybindingsContributionPointHandler;
tslib_1.__decorate([
    (0, inversify_1.inject)(keybinding_1.KeybindingRegistry),
    tslib_1.__metadata("design:type", keybinding_1.KeybindingRegistry)
], KeybindingsContributionPointHandler.prototype, "keybindingRegistry", void 0);
exports.KeybindingsContributionPointHandler = KeybindingsContributionPointHandler = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], KeybindingsContributionPointHandler);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/label-service-main.js"
/*!***********************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/label-service-main.js ***!
  \***********************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LabelServiceMainImpl = void 0;
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../../node_modules/@theia/core/lib/common/index.js");
class LabelServiceMainImpl {
    constructor(container) {
        this.resourceLabelFormatters = new Map();
        this.contributionProvider = container.getNamed(common_1.ContributionProvider, browser_1.LabelProviderContribution);
    }
    $registerResourceLabelFormatter(handle, formatter) {
        // Dynamically registered formatters should have priority over those contributed via package.json
        formatter.priority = true;
        const disposables = new disposable_1.DisposableCollection();
        for (const contribution of this.contributionProvider.getContributions()) {
            if (contribution instanceof browser_1.DefaultUriLabelProviderContribution) {
                disposables.push(contribution.registerFormatter(formatter));
            }
        }
        this.resourceLabelFormatters.set(handle, disposables);
    }
    $unregisterResourceLabelFormatter(handle) {
        const toDispose = this.resourceLabelFormatters.get(handle);
        if (toDispose) {
            toDispose.dispose();
        }
        this.resourceLabelFormatters.delete(handle);
    }
}
exports.LabelServiceMainImpl = LabelServiceMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/languages-main.js"
/*!*******************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/languages-main.js ***!
  \*******************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toMonacoWorkspaceEdit = exports.LanguagesMainImpl = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Method `$changeLanguage` copied and modified
// from https://github.com/microsoft/vscode/blob/e9c50663154c369a06355ce752b447af5b580dc3/src/vs/workbench/api/browser/mainThreadLanguages.ts#L30-L42
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const plugin_api_rpc_model_1 = __webpack_require__(/*! ../../common/plugin-api-rpc-model */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc-model.js");
const rpc_protocol_1 = __webpack_require__(/*! ../../common/rpc-protocol */ "../../node_modules/@theia/plugin-ext/lib/common/rpc-protocol.js");
const monaco_languages_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-languages */ "../../node_modules/@theia/monaco/lib/browser/monaco-languages.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../../node_modules/@theia/core/lib/common/uri.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../node_modules/@theia/core/lib/common/event.js");
const browser_1 = __webpack_require__(/*! @theia/markers/lib/browser */ "../../node_modules/@theia/markers/lib/browser/index.js");
const vst = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "../../node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
const browser_2 = __webpack_require__(/*! @theia/callhierarchy/lib/browser */ "../../node_modules/@theia/callhierarchy/lib/browser/index.js");
const hierarchy_types_converters_1 = __webpack_require__(/*! ./hierarchy/hierarchy-types-converters */ "../../node_modules/@theia/plugin-ext/lib/main/browser/hierarchy/hierarchy-types-converters.js");
const browser_3 = __webpack_require__(/*! @theia/typehierarchy/lib/browser */ "../../node_modules/@theia/typehierarchy/lib/browser/index.js");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "../../node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
const object_identifier_1 = __webpack_require__(/*! ../../common/object-identifier */ "../../node_modules/@theia/plugin-ext/lib/common/object-identifier.js");
const types_1 = __webpack_require__(/*! ../../common/types */ "../../node_modules/@theia/plugin-ext/lib/common/types.js");
const paths_util_1 = __webpack_require__(/*! ../../common/paths-util */ "../../node_modules/@theia/plugin-ext/lib/common/paths-util.js");
const semantic_tokens_dto_1 = __webpack_require__(/*! ../../common/semantic-tokens-dto */ "../../node_modules/@theia/plugin-ext/lib/common/semantic-tokens-dto.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const extensions_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/platform/extensions/common/extensions */ "../../node_modules/@theia/monaco-editor-core/esm/vs/platform/extensions/common/extensions.js");
const standaloneServices_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices */ "../../node_modules/@theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices.js");
const markers_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/platform/markers/common/markers */ "../../node_modules/@theia/monaco-editor-core/esm/vs/platform/markers/common/markers.js");
const MonacoPath = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/base/common/path */ "../../node_modules/@theia/monaco-editor-core/esm/vs/base/common/path.js");
const editor_language_status_service_1 = __webpack_require__(/*! @theia/editor/lib/browser/language-status/editor-language-status-service */ "../../node_modules/@theia/editor/lib/browser/language-status/editor-language-status-service.js");
const languageFeatures_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/common/services/languageFeatures */ "../../node_modules/@theia/monaco-editor-core/esm/vs/editor/common/services/languageFeatures.js");
const types_impl_1 = __webpack_require__(/*! ../../plugin/types-impl */ "../../node_modules/@theia/plugin-ext/lib/plugin/types-impl.js");
const file_upload_1 = __webpack_require__(/*! @theia/filesystem/lib/common/upload/file-upload */ "../../node_modules/@theia/filesystem/lib/common/upload/file-upload.js");
let LanguagesMainImpl = class LanguagesMainImpl {
    constructor(rpc) {
        this.services = new Map();
        this.toDispose = new disposable_1.DisposableCollection();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.LANGUAGES_EXT);
    }
    dispose() {
        this.toDispose.dispose();
    }
    $getLanguages() {
        return Promise.resolve(monaco.languages.getLanguages().map(l => l.id));
    }
    $changeLanguage(resource, languageId) {
        const uri = monaco.Uri.revive(resource);
        const model = monaco.editor.getModel(uri);
        if (!model) {
            return Promise.reject(new Error('Invalid uri'));
        }
        const langId = monaco.languages.getEncodedLanguageId(languageId);
        if (!langId) {
            return Promise.reject(new Error(`Unknown language ID: ${languageId}`));
        }
        monaco.editor.setModelLanguage(model, languageId);
        return Promise.resolve(undefined);
    }
    register(handle, service) {
        this.services.set(handle, service);
        this.toDispose.push(disposable_1.Disposable.create(() => this.$unregister(handle)));
    }
    $unregister(handle) {
        const disposable = this.services.get(handle);
        if (disposable) {
            this.services.delete(handle);
            disposable.dispose();
        }
    }
    $setLanguageConfiguration(handle, languageId, configuration) {
        const config = {
            comments: configuration.comments,
            brackets: configuration.brackets,
            wordPattern: reviveRegExp(configuration.wordPattern),
            indentationRules: reviveIndentationRule(configuration.indentationRules),
            onEnterRules: reviveOnEnterRules(configuration.onEnterRules),
            autoClosingPairs: configuration.autoClosingPairs
        };
        this.register(handle, monaco.languages.setLanguageConfiguration(languageId, config));
    }
    $registerCompletionSupport(handle, pluginInfo, selector, triggerCharacters, supportsResolveDetails) {
        this.register(handle, monaco.languages.registerCompletionItemProvider(this.toLanguageSelector(selector), {
            triggerCharacters,
            provideCompletionItems: (model, position, context, token) => this.provideCompletionItems(handle, model, position, context, token),
            resolveCompletionItem: supportsResolveDetails
                ? (suggestion, token) => Promise.resolve(this.resolveCompletionItem(handle, suggestion, token))
                : undefined
        }));
    }
    provideCompletionItems(handle, model, position, context, token) {
        return this.proxy.$provideCompletionItems(handle, model.uri, position, context, token).then(result => {
            if (!result) {
                return undefined;
            }
            return {
                suggestions: result.completions.map(c => Object.assign(c, {
                    range: c.range || result.defaultRange
                })),
                incomplete: result.incomplete,
                dispose: () => this.proxy.$releaseCompletionItems(handle, result.id)
            };
        });
    }
    resolveCompletionItem(handle, item, token) {
        const { parentId, id } = item;
        return this.proxy.$resolveCompletionItem(handle, [parentId, id], token).then(resolved => {
            if (resolved) {
                (0, types_1.mixin)(item, resolved, true);
            }
            return item;
        });
    }
    $registerDefinitionProvider(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const definitionProvider = this.createDefinitionProvider(handle);
        this.register(handle, monaco.languages.registerDefinitionProvider(languageSelector, definitionProvider));
    }
    $registerDeclarationProvider(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const declarationProvider = this.createDeclarationProvider(handle);
        this.register(handle, monaco.languages.registerDeclarationProvider(languageSelector, declarationProvider));
    }
    $registerReferenceProvider(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const referenceProvider = this.createReferenceProvider(handle);
        this.register(handle, monaco.languages.registerReferenceProvider(languageSelector, referenceProvider));
    }
    createReferenceProvider(handle) {
        return {
            provideReferences: (model, position, context, token) => this.provideReferences(handle, model, position, context, token)
        };
    }
    provideReferences(handle, model, position, context, token) {
        return this.proxy.$provideReferences(handle, model.uri, position, context, token).then(result => {
            if (!result) {
                return undefined;
            }
            if (Array.isArray(result)) {
                const references = [];
                for (const item of result) {
                    references.push({ ...item, uri: monaco.Uri.revive(item.uri) });
                }
                return references;
            }
            return undefined;
        });
    }
    $registerSignatureHelpProvider(handle, pluginInfo, selector, metadata) {
        const languageSelector = this.toLanguageSelector(selector);
        const signatureHelpProvider = this.createSignatureHelpProvider(handle, metadata);
        this.register(handle, monaco.languages.registerSignatureHelpProvider(languageSelector, signatureHelpProvider));
    }
    $clearDiagnostics(id) {
        for (const uri of this.problemManager.getUris()) {
            this.problemManager.setMarkers(new uri_1.URI(uri), id, []);
        }
    }
    $changeDiagnostics(id, delta) {
        for (const [uriString, markers] of delta) {
            const uri = new uri_1.URI(uriString);
            this.problemManager.setMarkers(uri, id, markers.map(reviveMarker));
        }
    }
    $registerImplementationProvider(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const implementationProvider = this.createImplementationProvider(handle);
        this.register(handle, monaco.languages.registerImplementationProvider(languageSelector, implementationProvider));
    }
    createImplementationProvider(handle) {
        return {
            provideImplementation: (model, position, token) => this.provideImplementation(handle, model, position, token)
        };
    }
    provideImplementation(handle, model, position, token) {
        return this.proxy.$provideImplementation(handle, model.uri, position, token).then(result => {
            if (!result) {
                return undefined;
            }
            if (Array.isArray(result)) {
                // using DefinitionLink because Location is mandatory part of DefinitionLink
                const definitionLinks = [];
                for (const item of result) {
                    definitionLinks.push({ ...item, uri: monaco.Uri.revive(item.uri) });
                }
                return definitionLinks;
            }
            else {
                // single Location
                return {
                    uri: monaco.Uri.revive(result.uri),
                    range: result.range
                };
            }
        });
    }
    $registerTypeDefinitionProvider(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const typeDefinitionProvider = this.createTypeDefinitionProvider(handle);
        this.register(handle, monaco.languages.registerTypeDefinitionProvider(languageSelector, typeDefinitionProvider));
    }
    createTypeDefinitionProvider(handle) {
        return {
            provideTypeDefinition: (model, position, token) => this.provideTypeDefinition(handle, model, position, token)
        };
    }
    provideTypeDefinition(handle, model, position, token) {
        return this.proxy.$provideTypeDefinition(handle, model.uri, position, token).then(result => {
            if (!result) {
                return undefined;
            }
            if (Array.isArray(result)) {
                // using DefinitionLink because Location is mandatory part of DefinitionLink
                const definitionLinks = [];
                for (const item of result) {
                    definitionLinks.push({ ...item, uri: monaco.Uri.revive(item.uri) });
                }
                return definitionLinks;
            }
            else {
                // single Location
                return {
                    uri: monaco.Uri.revive(result.uri),
                    range: result.range
                };
            }
        });
    }
    $registerHoverProvider(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const hoverProvider = this.createHoverProvider(handle);
        this.register(handle, monaco.languages.registerHoverProvider(languageSelector, hoverProvider));
    }
    createHoverProvider(handle) {
        return {
            provideHover: (model, position, token) => this.provideHover(handle, model, position, token)
        };
    }
    provideHover(handle, model, position, token) {
        return this.proxy.$provideHover(handle, model.uri, position, token);
    }
    $registerEvaluatableExpressionProvider(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const evaluatableExpressionProvider = this.createEvaluatableExpressionProvider(handle);
        this.register(handle, standaloneServices_1.StandaloneServices.get(languageFeatures_1.ILanguageFeaturesService).evaluatableExpressionProvider.register(languageSelector, evaluatableExpressionProvider));
    }
    createEvaluatableExpressionProvider(handle) {
        return {
            provideEvaluatableExpression: (model, position, token) => this.provideEvaluatableExpression(handle, model, position, token)
        };
    }
    provideEvaluatableExpression(handle, model, position, token) {
        return this.proxy.$provideEvaluatableExpression(handle, model.uri, position, token);
    }
    $registerInlineValuesProvider(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const inlineValuesProvider = this.createInlineValuesProvider(handle);
        this.register(handle, standaloneServices_1.StandaloneServices.get(languageFeatures_1.ILanguageFeaturesService).inlineValuesProvider.register(languageSelector, inlineValuesProvider));
    }
    createInlineValuesProvider(handle) {
        return {
            provideInlineValues: (model, range, context, token) => this.provideInlineValues(handle, model, range, context, token)
        };
    }
    provideInlineValues(handle, model, range, context, token) {
        return this.proxy.$provideInlineValues(handle, model.uri, range, context, token);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    $emitInlineValuesEvent(eventHandle, event) {
        const obj = this.services.get(eventHandle);
        if (obj instanceof event_1.Emitter) {
            obj.fire(event);
        }
    }
    $registerDocumentHighlightProvider(handle, _pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const documentHighlightProvider = this.createDocumentHighlightProvider(handle);
        this.register(handle, monaco.languages.registerDocumentHighlightProvider(languageSelector, documentHighlightProvider));
    }
    createDocumentHighlightProvider(handle) {
        return {
            provideDocumentHighlights: (model, position, token) => this.provideDocumentHighlights(handle, model, position, token)
        };
    }
    provideDocumentHighlights(handle, model, position, token) {
        return this.proxy.$provideDocumentHighlights(handle, model.uri, position, token).then(result => {
            if (!result) {
                return undefined;
            }
            if (Array.isArray(result)) {
                const highlights = [];
                for (const item of result) {
                    highlights.push({
                        ...item,
                        kind: (item.kind ? item.kind : monaco.languages.DocumentHighlightKind.Text)
                    });
                }
                return highlights;
            }
            return undefined;
        });
    }
    $registerWorkspaceSymbolProvider(handle, pluginInfo) {
        const workspaceSymbolProvider = this.createWorkspaceSymbolProvider(handle);
        this.register(handle, this.monacoLanguages.registerWorkspaceSymbolProvider(workspaceSymbolProvider));
    }
    createWorkspaceSymbolProvider(handle) {
        return {
            provideWorkspaceSymbols: (params, token) => this.provideWorkspaceSymbols(handle, params, token),
            resolveWorkspaceSymbol: (symbol, token) => this.resolveWorkspaceSymbol(handle, symbol, token)
        };
    }
    provideWorkspaceSymbols(handle, params, token) {
        return this.proxy.$provideWorkspaceSymbols(handle, params.query, token);
    }
    resolveWorkspaceSymbol(handle, symbol, token) {
        return this.proxy.$resolveWorkspaceSymbol(handle, symbol, token);
    }
    $registerDocumentLinkProvider(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const linkProvider = this.createLinkProvider(handle);
        this.register(handle, monaco.languages.registerLinkProvider(languageSelector, linkProvider));
    }
    createLinkProvider(handle) {
        return {
            provideLinks: async (model, token) => this.provideLinks(handle, model, token),
            resolveLink: async (link, token) => this.resolveLink(handle, link, token)
        };
    }
    async provideLinks(handle, model, token) {
        const links = await this.proxy.$provideDocumentLinks(handle, model.uri, token);
        if (!links) {
            return undefined;
        }
        return {
            links: links.map(link => this.toMonacoLink(link)),
            dispose: () => {
                if (links && Array.isArray(links)) {
                    this.proxy.$releaseDocumentLinks(handle, links.map(link => object_identifier_1.ObjectIdentifier.of(link)));
                }
            }
        };
    }
    async resolveLink(handle, link, token) {
        const resolved = await this.proxy.$resolveDocumentLink(handle, link, token);
        return resolved && this.toMonacoLink(resolved);
    }
    toMonacoLink(link) {
        return {
            ...link,
            url: !!link.url && typeof link.url !== 'string' ? monaco.Uri.revive(link.url) : link.url
        };
    }
    $registerCodeLensSupport(handle, pluginInfo, selector, eventHandle) {
        const languageSelector = this.toLanguageSelector(selector);
        const lensProvider = this.createCodeLensProvider(handle);
        if (typeof eventHandle === 'number') {
            const emitter = new event_1.Emitter();
            this.register(eventHandle, emitter);
            lensProvider.onDidChange = emitter.event;
        }
        this.register(handle, monaco.languages.registerCodeLensProvider(languageSelector, lensProvider));
    }
    createCodeLensProvider(handle) {
        return {
            provideCodeLenses: async (model, token) => this.provideCodeLenses(handle, model, token),
            resolveCodeLens: (model, codeLens, token) => this.resolveCodeLens(handle, model, codeLens, token)
        };
    }
    async provideCodeLenses(handle, model, token) {
        const lenses = await this.proxy.$provideCodeLenses(handle, model.uri, token);
        if (!lenses) {
            return undefined;
        }
        return {
            lenses,
            dispose: () => {
                if (lenses && Array.isArray(lenses)) {
                    this.proxy.$releaseCodeLenses(handle, lenses.map(symbol => object_identifier_1.ObjectIdentifier.of(symbol)));
                }
            }
        };
    }
    resolveCodeLens(handle, model, codeLens, token) {
        return this.proxy.$resolveCodeLens(handle, model.uri, codeLens, token);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    $emitCodeLensEvent(eventHandle, event) {
        const obj = this.services.get(eventHandle);
        if (obj instanceof event_1.Emitter) {
            obj.fire(event);
        }
    }
    $registerOutlineSupport(handle, pluginInfo, selector, displayName) {
        const languageSelector = this.toLanguageSelector(selector);
        const symbolProvider = this.createDocumentSymbolProvider(handle, displayName);
        this.register(handle, monaco.languages.registerDocumentSymbolProvider(languageSelector, symbolProvider));
    }
    createDocumentSymbolProvider(handle, displayName) {
        return {
            displayName,
            provideDocumentSymbols: (model, token) => this.provideDocumentSymbols(handle, model, token)
        };
    }
    provideDocumentSymbols(handle, model, token) {
        return this.proxy.$provideDocumentSymbols(handle, model.uri, token);
    }
    createDefinitionProvider(handle) {
        return {
            provideDefinition: (model, position, token) => this.provideDefinition(handle, model, position, token)
        };
    }
    createDeclarationProvider(handle) {
        return {
            provideDeclaration: (model, position, token) => this.provideDeclaration(handle, model, position, token)
        };
    }
    provideDeclaration(handle, model, position, token) {
        return this.proxy.$provideDeclaration(handle, model.uri, position, token).then(result => {
            if (!result) {
                return undefined;
            }
            if (Array.isArray(result)) {
                // using DefinitionLink because Location is mandatory part of DefinitionLink
                const definitionLinks = [];
                for (const item of result) {
                    definitionLinks.push({ ...item, uri: monaco.Uri.revive(item.uri) });
                }
                return definitionLinks;
            }
            else {
                // single Location
                return {
                    uri: monaco.Uri.revive(result.uri),
                    range: result.range
                };
            }
        });
    }
    provideDefinition(handle, model, position, token) {
        return this.proxy.$provideDefinition(handle, model.uri, position, token).then(result => {
            if (!result) {
                return undefined;
            }
            if (Array.isArray(result)) {
                // using DefinitionLink because Location is mandatory part of DefinitionLink
                const definitionLinks = [];
                for (const item of result) {
                    definitionLinks.push({ ...item, uri: monaco.Uri.revive(item.uri) });
                }
                return definitionLinks;
            }
            else {
                // single Location
                return {
                    uri: monaco.Uri.revive(result.uri),
                    range: result.range
                };
            }
        });
    }
    createSignatureHelpProvider(handle, metadata) {
        return {
            signatureHelpTriggerCharacters: metadata.triggerCharacters,
            signatureHelpRetriggerCharacters: metadata.retriggerCharacters,
            provideSignatureHelp: async (model, position, token, context) => this.provideSignatureHelp(handle, model, position, token, context)
        };
    }
    async provideSignatureHelp(handle, model, position, token, context) {
        // need to cast because of vscode issue https://github.com/microsoft/vscode/issues/190584
        const value = await this.proxy.$provideSignatureHelp(handle, model.uri, position, context, token);
        if (!value) {
            return undefined;
        }
        return {
            value,
            dispose: () => {
                if (typeof value.id === 'number') {
                    this.proxy.$releaseSignatureHelp(handle, value.id);
                }
            }
        };
    }
    $registerDocumentFormattingSupport(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const documentFormattingEditSupport = this.createDocumentFormattingSupport(handle, pluginInfo);
        this.register(handle, monaco.languages.registerDocumentFormattingEditProvider(languageSelector, documentFormattingEditSupport));
    }
    createDocumentFormattingSupport(handle, pluginInfo) {
        const provider = {
            extensionId: new extensions_1.ExtensionIdentifier(pluginInfo.id),
            displayName: pluginInfo.name,
            provideDocumentFormattingEdits: (model, options, token) => this.provideDocumentFormattingEdits(handle, model, options, token)
        };
        return provider;
    }
    provideDocumentFormattingEdits(handle, model, options, token) {
        return this.proxy.$provideDocumentFormattingEdits(handle, model.uri, options, token);
    }
    $registerRangeFormattingSupport(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const rangeFormattingEditProvider = this.createRangeFormattingSupport(handle, pluginInfo);
        this.register(handle, monaco.languages.registerDocumentRangeFormattingEditProvider(languageSelector, rangeFormattingEditProvider));
    }
    createRangeFormattingSupport(handle, pluginInfo) {
        const provider = {
            extensionId: new extensions_1.ExtensionIdentifier(pluginInfo.id),
            displayName: pluginInfo.name,
            provideDocumentRangeFormattingEdits: (model, range, options, token) => this.provideDocumentRangeFormattingEdits(handle, model, range, options, token)
        };
        return provider;
    }
    provideDocumentRangeFormattingEdits(handle, model, range, options, token) {
        return this.proxy.$provideDocumentRangeFormattingEdits(handle, model.uri, range, options, token);
    }
    $registerOnTypeFormattingProvider(handle, pluginInfo, selector, autoFormatTriggerCharacters) {
        const languageSelector = this.toLanguageSelector(selector);
        const onTypeFormattingProvider = this.createOnTypeFormattingProvider(handle, autoFormatTriggerCharacters);
        this.register(handle, monaco.languages.registerOnTypeFormattingEditProvider(languageSelector, onTypeFormattingProvider));
    }
    createOnTypeFormattingProvider(handle, autoFormatTriggerCharacters) {
        return {
            autoFormatTriggerCharacters,
            provideOnTypeFormattingEdits: (model, position, ch, options, token) => this.provideOnTypeFormattingEdits(handle, model, position, ch, options, token)
        };
    }
    provideOnTypeFormattingEdits(handle, model, position, ch, options, token) {
        return this.proxy.$provideOnTypeFormattingEdits(handle, model.uri, position, ch, options, token);
    }
    $registerDocumentDropEditProvider(handle, selector, metadata) {
        this.register(handle, standaloneServices_1.StandaloneServices
            .get(languageFeatures_1.ILanguageFeaturesService)
            .documentDropEditProvider
            .register(selector, this.createDocumentDropEditProvider(handle, metadata)));
    }
    createDocumentDropEditProvider(handle, _metadata) {
        return {
            // @monaco-uplift id and dropMimeTypes should be supported by the monaco drop editor provider after 1.82.0
            // id?: string;
            // dropMimeTypes: metadata?.dropMimeTypes ?? ['*/*'],
            provideDocumentDropEdits: async (model, position, dataTransfer, token) => this.provideDocumentDropEdits(handle, model, position, dataTransfer, token)
        };
    }
    async provideDocumentDropEdits(handle, model, position, dataTransfer, token) {
        await this.fileUploadService.upload(new uri_1.URI(), { source: dataTransfer, leaveInTemp: true });
        return undefined;
    }
    $registerFoldingRangeProvider(handle, pluginInfo, selector, eventHandle) {
        const languageSelector = this.toLanguageSelector(selector);
        const provider = this.createFoldingRangeProvider(handle);
        if (typeof eventHandle === 'number') {
            const emitter = new event_1.Emitter();
            this.services.set(eventHandle, emitter);
            provider.onDidChange = emitter.event;
        }
        this.register(handle, monaco.languages.registerFoldingRangeProvider(languageSelector, provider));
    }
    createFoldingRangeProvider(handle) {
        return {
            provideFoldingRanges: (model, context, token) => this.provideFoldingRanges(handle, model, context, token)
        };
    }
    $emitFoldingRangeEvent(eventHandle, event) {
        const obj = this.services.get(eventHandle);
        if (obj instanceof event_1.Emitter) {
            obj.fire(event);
        }
    }
    provideFoldingRanges(handle, model, context, token) {
        return this.proxy.$provideFoldingRange(handle, model.uri, context, token);
    }
    $registerSelectionRangeProvider(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const provider = this.createSelectionRangeProvider(handle);
        this.register(handle, monaco.languages.registerSelectionRangeProvider(languageSelector, provider));
    }
    createSelectionRangeProvider(handle) {
        return {
            provideSelectionRanges: (model, positions, token) => this.provideSelectionRanges(handle, model, positions, token)
        };
    }
    provideSelectionRanges(handle, model, positions, token) {
        return this.proxy.$provideSelectionRanges(handle, model.uri, positions, token);
    }
    $registerDocumentColorProvider(handle, pluginInfo, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const colorProvider = this.createColorProvider(handle);
        this.register(handle, monaco.languages.registerColorProvider(languageSelector, colorProvider));
    }
    createColorProvider(handle) {
        return {
            provideDocumentColors: (model, token) => this.provideDocumentColors(handle, model, token),
            provideColorPresentations: (model, colorInfo, token) => this.provideColorPresentations(handle, model, colorInfo, token)
        };
    }
    provideDocumentColors(handle, model, token) {
        return this.proxy.$provideDocumentColors(handle, model.uri, token).then(documentColors => documentColors.map(documentColor => {
            const [red, green, blue, alpha] = documentColor.color;
            const color = {
                red: red,
                green: green,
                blue: blue,
                alpha: alpha
            };
            return {
                color,
                range: documentColor.range
            };
        }));
    }
    provideColorPresentations(handle, model, colorInfo, token) {
        return this.proxy.$provideColorPresentations(handle, model.uri, {
            color: [
                colorInfo.color.red,
                colorInfo.color.green,
                colorInfo.color.blue,
                colorInfo.color.alpha
            ],
            range: colorInfo.range
        }, token);
    }
    $registerInlayHintsProvider(handle, pluginInfo, selector, displayName, eventHandle) {
        const languageSelector = this.toLanguageSelector(selector);
        const inlayHintsProvider = this.createInlayHintsProvider(handle);
        if (typeof eventHandle === 'number') {
            const emitter = new event_1.Emitter();
            this.register(eventHandle, emitter);
            inlayHintsProvider.onDidChangeInlayHints = emitter.event;
        }
        this.register(handle, monaco.languages.registerInlayHintsProvider(languageSelector, inlayHintsProvider));
    }
    createInlayHintsProvider(handle) {
        return {
            provideInlayHints: async (model, range, token) => {
                const result = await this.proxy.$provideInlayHints(handle, model.uri, range, token);
                if (!result) {
                    return;
                }
                return {
                    hints: result.hints.map(hint => reviveHint(hint)),
                    dispose: () => {
                        if (typeof result.cacheId === 'number') {
                            this.proxy.$releaseInlayHints(handle, result.cacheId);
                        }
                    }
                };
            },
            resolveInlayHint: async (hint, token) => {
                // need to cast because of vscode issue https://github.com/microsoft/vscode/issues/190584
                const dto = hint;
                if (typeof dto.cacheId !== 'number') {
                    return hint;
                }
                const result = await this.proxy.$resolveInlayHint(handle, dto.cacheId, token);
                if (token.isCancellationRequested) {
                    return undefined;
                }
                if (!result) {
                    return hint;
                }
                return {
                    ...hint,
                    tooltip: result.tooltip,
                    label: reviveInlayLabel(result.label)
                };
            },
        };
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    $emitInlayHintsEvent(eventHandle, event) {
        const obj = this.services.get(eventHandle);
        if (obj instanceof event_1.Emitter) {
            obj.fire(event);
        }
    }
    $registerInlineCompletionsSupport(handle, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const provider = {
            provideInlineCompletions: async (model, position, context, token) => this.proxy.$provideInlineCompletions(handle, model.uri, position, context, token),
            freeInlineCompletions: (completions) => {
                this.proxy.$freeInlineCompletionsList(handle, completions.pid);
            }
        };
        this.register(handle, monaco.languages.registerInlineCompletionsProvider(languageSelector, provider));
    }
    $registerQuickFixProvider(handle, pluginInfo, selector, providedCodeActionKinds, documentation) {
        const languageSelector = this.toLanguageSelector(selector);
        const quickFixProvider = {
            provideCodeActions: (model, range, context, token) => {
                const markers = standaloneServices_1.StandaloneServices.get(markers_1.IMarkerService)
                    .read({ resource: model.uri })
                    .filter(m => monaco.Range.areIntersectingOrTouching(m, range));
                return this.provideCodeActions(handle, model, range, { ...context, markers }, token);
            },
            resolveCodeAction: (codeAction, token) => this.resolveCodeAction(handle, codeAction, token)
        };
        this.register(handle, monaco.languages.registerCodeActionProvider(languageSelector, quickFixProvider, {
            documentation: documentation,
            providedCodeActionKinds
        }));
    }
    async provideCodeActions(handle, model, rangeOrSelection, context, token) {
        try {
            const actions = await this.proxy.$provideCodeActions(handle, model.uri, rangeOrSelection, this.toModelCodeActionContext(context), token);
            if (!actions) {
                return undefined;
            }
            return {
                actions: actions.map(a => toMonacoAction(a)),
                dispose: () => this.proxy.$releaseCodeActions(handle, actions.map(a => a.cacheId))
            };
        }
        catch (e) {
            console.error(e);
            return undefined;
        }
    }
    toModelCodeActionContext(context) {
        return {
            ...context,
            trigger: this.toCodeActionTriggerKind(context.trigger)
        };
    }
    toCodeActionTriggerKind(type) {
        switch (type) {
            case monaco.languages.CodeActionTriggerType.Auto:
                return types_impl_1.CodeActionTriggerKind.Automatic;
            case monaco.languages.CodeActionTriggerType.Invoke:
                return types_impl_1.CodeActionTriggerKind.Invoke;
        }
    }
    async resolveCodeAction(handle, codeAction, token) {
        // The cacheId is kept in toMonacoAction when converting a received CodeAction DTO to a monaco code action
        const cacheId = codeAction.cacheId;
        if (cacheId !== undefined) {
            const resolvedEdit = await this.proxy.$resolveCodeAction(handle, cacheId, token);
            codeAction.edit = resolvedEdit && toMonacoWorkspaceEdit(resolvedEdit);
        }
        return codeAction;
    }
    $registerRenameProvider(handle, pluginInfo, selector, supportsResolveLocation) {
        const languageSelector = this.toLanguageSelector(selector);
        const renameProvider = this.createRenameProvider(handle, supportsResolveLocation);
        this.register(handle, monaco.languages.registerRenameProvider(languageSelector, renameProvider));
    }
    createRenameProvider(handle, supportsResolveLocation) {
        return {
            provideRenameEdits: (model, position, newName, token) => this.provideRenameEdits(handle, model, position, newName, token),
            resolveRenameLocation: supportsResolveLocation
                ? (model, position, token) => this.resolveRenameLocation(handle, model, position, token)
                : undefined
        };
    }
    provideRenameEdits(handle, model, position, newName, token) {
        return this.proxy.$provideRenameEdits(handle, model.uri, position, newName, token).then(toMonacoWorkspaceEdit);
    }
    $registerCallHierarchyProvider(handle, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const callHierarchyService = this.createCallHierarchyService(handle, languageSelector);
        this.register(handle, this.callHierarchyServiceContributionRegistry.add(callHierarchyService));
    }
    createCallHierarchyService(handle, language) {
        return {
            selector: language,
            getRootDefinition: (uri, position, cancellationToken) => this.proxy.$provideRootDefinition(handle, (0, hierarchy_types_converters_1.toUriComponents)(uri), (0, hierarchy_types_converters_1.fromPosition)(position), cancellationToken)
                .then(def => {
                if (!def) {
                    return undefined;
                }
                const defs = Array.isArray(def) ? def : [def];
                return { dispose: () => { var _a; return this.proxy.$releaseCallHierarchy(handle, (_a = defs[0]) === null || _a === void 0 ? void 0 : _a._sessionId); }, items: defs.map(item => (0, hierarchy_types_converters_1.toItemHierarchyDefinition)(item)) };
            }),
            getCallers: (definition, cancellationToken) => this.proxy.$provideCallers(handle, (0, hierarchy_types_converters_1.fromItemHierarchyDefinition)(definition), cancellationToken)
                .then(result => {
                if (!result) {
                    return undefined;
                }
                if (Array.isArray(result)) {
                    return result.map(hierarchy_types_converters_1.toCaller);
                }
                return undefined;
            }),
            getCallees: (definition, cancellationToken) => this.proxy.$provideCallees(handle, (0, hierarchy_types_converters_1.fromItemHierarchyDefinition)(definition), cancellationToken)
                .then(result => {
                if (!result) {
                    return undefined;
                }
                if (Array.isArray(result)) {
                    return result.map(hierarchy_types_converters_1.toCallee);
                }
                return undefined;
            })
        };
    }
    resolveRenameLocation(handle, model, position, token) {
        return this.proxy.$resolveRenameLocation(handle, model.uri, position, token);
    }
    // --- type hierarchy
    $registerTypeHierarchyProvider(handle, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const typeHierarchyService = this.createTypeHierarchyService(handle, languageSelector);
        this.register(handle, this.typeHierarchyServiceContributionRegistry.add(typeHierarchyService));
    }
    createTypeHierarchyService(handle, language) {
        return {
            selector: language,
            prepareSession: (uri, position, cancellationToken) => this.proxy.$prepareTypeHierarchy(handle, (0, hierarchy_types_converters_1.toUriComponents)(uri), (0, hierarchy_types_converters_1.fromPosition)(position), cancellationToken)
                .then(result => {
                if (!result) {
                    return undefined;
                }
                const items = Array.isArray(result) ? result : [result];
                return {
                    dispose: () => { var _a; return this.proxy.$releaseTypeHierarchy(handle, (_a = items[0]) === null || _a === void 0 ? void 0 : _a._sessionId); },
                    items: items.map(item => (0, hierarchy_types_converters_1.toItemHierarchyDefinition)(item))
                };
            }),
            provideSuperTypes: (sessionId, itemId, cancellationToken) => this.proxy.$provideSuperTypes(handle, sessionId, itemId, cancellationToken)
                .then(results => {
                if (!results) {
                    return undefined;
                }
                if (Array.isArray(results)) {
                    return results.map(hierarchy_types_converters_1.toItemHierarchyDefinition);
                }
                return undefined;
            }),
            provideSubTypes: async (sessionId, itemId, cancellationToken) => this.proxy.$provideSubTypes(handle, sessionId, itemId, cancellationToken)
                .then(results => {
                if (!results) {
                    return undefined;
                }
                if (Array.isArray(results)) {
                    return results.map(hierarchy_types_converters_1.toItemHierarchyDefinition);
                }
                return undefined;
            })
        };
    }
    // --- semantic tokens
    $registerDocumentSemanticTokensProvider(handle, pluginInfo, selector, legend, eventHandle) {
        const languageSelector = this.toLanguageSelector(selector);
        let event = undefined;
        if (typeof eventHandle === 'number') {
            const emitter = new event_1.Emitter();
            this.register(eventHandle, emitter);
            event = emitter.event;
        }
        const provider = this.createDocumentSemanticTokensProvider(handle, legend, event);
        this.register(handle, monaco.languages.registerDocumentSemanticTokensProvider(languageSelector, provider));
    }
    createDocumentSemanticTokensProvider(handle, legend, event) {
        return {
            releaseDocumentSemanticTokens: resultId => {
                if (resultId) {
                    this.proxy.$releaseDocumentSemanticTokens(handle, parseInt(resultId, 10));
                }
            },
            getLegend: () => legend,
            provideDocumentSemanticTokens: async (model, lastResultId, token) => {
                const nLastResultId = lastResultId ? parseInt(lastResultId, 10) : 0;
                const encodedDto = await this.proxy.$provideDocumentSemanticTokens(handle, model.uri, nLastResultId, token);
                if (!encodedDto) {
                    return null;
                }
                if (token.isCancellationRequested) {
                    return null;
                }
                const dto = (0, semantic_tokens_dto_1.decodeSemanticTokensDto)(encodedDto);
                if (dto.type === 'full') {
                    return {
                        resultId: String(dto.id),
                        data: dto.data
                    };
                }
                return {
                    resultId: String(dto.id),
                    edits: dto.deltas
                };
            }
        };
    }
    $emitDocumentSemanticTokensEvent(eventHandle) {
        const obj = this.services.get(eventHandle);
        if (obj instanceof event_1.Emitter) {
            obj.fire(undefined);
        }
    }
    $registerDocumentRangeSemanticTokensProvider(handle, pluginInfo, selector, legend, eventHandle) {
        const languageSelector = this.toLanguageSelector(selector);
        let event = undefined;
        if (typeof eventHandle === 'number') {
            const emitter = new event_1.Emitter();
            this.register(eventHandle, emitter);
            event = emitter.event;
        }
        const provider = this.createDocumentRangeSemanticTokensProvider(handle, legend, event);
        this.register(handle, monaco.languages.registerDocumentRangeSemanticTokensProvider(languageSelector, provider));
    }
    createDocumentRangeSemanticTokensProvider(handle, legend, _onDidChangeEvent) {
        return {
            getLegend: () => legend,
            provideDocumentRangeSemanticTokens: async (model, range, token) => {
                const encodedDto = await this.proxy.$provideDocumentRangeSemanticTokens(handle, model.uri, range, token);
                if (!encodedDto) {
                    return null;
                }
                if (token.isCancellationRequested) {
                    return null;
                }
                const dto = (0, semantic_tokens_dto_1.decodeSemanticTokensDto)(encodedDto);
                if (dto.type === 'full') {
                    return {
                        resultId: String(dto.id),
                        data: dto.data
                    };
                }
                throw new Error('Unexpected');
            },
            // @monaco-uplift onDidChange property is not yet available with the current monaco version, probably with the next monaco update then
        };
    }
    // --- suggest
    toLanguageSelector(filters) {
        return filters.map(filter => {
            let pattern;
            if (typeof filter.pattern === 'string') {
                pattern = filter.pattern;
            }
            else if (filter.pattern) {
                pattern = {
                    base: MonacoPath.normalize(filter.pattern.baseUri.toString()),
                    pattern: filter.pattern.pattern,
                    pathToRelative: paths_util_1.relative
                };
            }
            return {
                language: filter.language,
                scheme: filter.scheme,
                pattern
            };
        });
    }
    // --- linked editing range
    $registerLinkedEditingRangeProvider(handle, selector) {
        const languageSelector = this.toLanguageSelector(selector);
        const linkedEditingRangeProvider = this.createLinkedEditingRangeProvider(handle);
        this.register(handle, monaco.languages.registerLinkedEditingRangeProvider(languageSelector, linkedEditingRangeProvider));
    }
    createLinkedEditingRangeProvider(handle) {
        return {
            provideLinkedEditingRanges: async (model, position, token) => {
                const res = await this.proxy.$provideLinkedEditingRanges(handle, model.uri, position, token);
                if (res) {
                    return {
                        ranges: res.ranges,
                        wordPattern: reviveRegExp(res.wordPattern)
                    };
                }
                return undefined;
            }
        };
    }
    ;
    // -- Language status
    $setLanguageStatus(handle, status) {
        const internal = { ...status, selector: this.toLanguageSelector(status.selector) };
        this.languageStatusService.setLanguageStatusItem(handle, internal);
    }
    ;
    $removeLanguageStatus(handle) {
        this.languageStatusService.removeLanguageStatusItem(handle);
    }
    ;
};
exports.LanguagesMainImpl = LanguagesMainImpl;
tslib_1.__decorate([
    (0, inversify_1.inject)(monaco_languages_1.MonacoLanguages),
    tslib_1.__metadata("design:type", monaco_languages_1.MonacoLanguages)
], LanguagesMainImpl.prototype, "monacoLanguages", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ProblemManager),
    tslib_1.__metadata("design:type", browser_1.ProblemManager)
], LanguagesMainImpl.prototype, "problemManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.CallHierarchyServiceProvider),
    tslib_1.__metadata("design:type", browser_2.CallHierarchyServiceProvider)
], LanguagesMainImpl.prototype, "callHierarchyServiceContributionRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_3.TypeHierarchyServiceProvider),
    tslib_1.__metadata("design:type", browser_3.TypeHierarchyServiceProvider)
], LanguagesMainImpl.prototype, "typeHierarchyServiceContributionRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(editor_language_status_service_1.EditorLanguageStatusService),
    tslib_1.__metadata("design:type", editor_language_status_service_1.EditorLanguageStatusService)
], LanguagesMainImpl.prototype, "languageStatusService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(file_upload_1.FileUploadService),
    tslib_1.__metadata("design:type", Object)
], LanguagesMainImpl.prototype, "fileUploadService", void 0);
exports.LanguagesMainImpl = LanguagesMainImpl = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(rpc_protocol_1.RPCProtocol)),
    tslib_1.__metadata("design:paramtypes", [Object])
], LanguagesMainImpl);
function reviveMarker(marker) {
    const monacoMarker = {
        code: marker.code,
        severity: reviveSeverity(marker.severity),
        range: reviveRange(marker.startLineNumber, marker.startColumn, marker.endLineNumber, marker.endColumn),
        message: marker.message,
        source: marker.source,
        relatedInformation: undefined
    };
    if (marker.relatedInformation) {
        monacoMarker.relatedInformation = marker.relatedInformation.map(reviveRelated);
    }
    if (marker.tags) {
        monacoMarker.tags = marker.tags.map(reviveTag);
    }
    return monacoMarker;
}
function reviveSeverity(severity) {
    switch (severity) {
        case plugin_api_rpc_model_1.MarkerSeverity.Error: return vst.DiagnosticSeverity.Error;
        case plugin_api_rpc_model_1.MarkerSeverity.Warning: return vst.DiagnosticSeverity.Warning;
        case plugin_api_rpc_model_1.MarkerSeverity.Info: return vst.DiagnosticSeverity.Information;
        case plugin_api_rpc_model_1.MarkerSeverity.Hint: return vst.DiagnosticSeverity.Hint;
    }
}
function reviveRange(startLine, startColumn, endLine, endColumn) {
    // note: language server range is 0-based, marker is 1-based, so need to deduct 1 here
    return {
        start: {
            line: startLine - 1,
            character: startColumn - 1
        },
        end: {
            line: endLine - 1,
            character: endColumn - 1
        }
    };
}
function reviveRelated(related) {
    return {
        message: related.message,
        location: {
            uri: related.resource,
            range: reviveRange(related.startLineNumber, related.startColumn, related.endLineNumber, related.endColumn)
        }
    };
}
function reviveTag(tag) {
    switch (tag) {
        case 1: return vscode_languageserver_protocol_1.DiagnosticTag.Unnecessary;
        case 2: return vscode_languageserver_protocol_1.DiagnosticTag.Deprecated;
    }
}
function reviveRegExp(regExp) {
    if (typeof regExp === 'undefined' || regExp === null) {
        return undefined;
    }
    return new RegExp(regExp.pattern, regExp.flags);
}
function reviveIndentationRule(indentationRule) {
    if (typeof indentationRule === 'undefined' || indentationRule === null) {
        return undefined;
    }
    return {
        increaseIndentPattern: reviveRegExp(indentationRule.increaseIndentPattern),
        decreaseIndentPattern: reviveRegExp(indentationRule.decreaseIndentPattern),
        indentNextLinePattern: reviveRegExp(indentationRule.indentNextLinePattern),
        unIndentedLinePattern: reviveRegExp(indentationRule.unIndentedLinePattern),
    };
}
function reviveOnEnterRule(onEnterRule) {
    return {
        beforeText: reviveRegExp(onEnterRule.beforeText),
        afterText: reviveRegExp(onEnterRule.afterText),
        previousLineText: reviveRegExp(onEnterRule.previousLineText),
        action: onEnterRule.action,
    };
}
function reviveOnEnterRules(onEnterRules) {
    if (typeof onEnterRules === 'undefined' || onEnterRules === null) {
        return undefined;
    }
    return onEnterRules.map(reviveOnEnterRule);
}
function reviveInlayLabel(label) {
    var _a;
    let monacoLabel;
    if (typeof label === 'string') {
        monacoLabel = label;
    }
    else {
        const parts = [];
        for (const part of label) {
            const result = {
                ...part,
                location: !!part.location ? { range: (_a = part.location) === null || _a === void 0 ? void 0 : _a.range, uri: monaco.Uri.revive(part.location.uri) } : undefined
            };
            parts.push(result);
        }
        monacoLabel = parts;
    }
    return monacoLabel;
}
function reviveHint(hint) {
    return {
        ...hint,
        label: reviveInlayLabel(hint.label)
    };
}
function toMonacoAction(action) {
    var _a;
    return {
        ...action,
        diagnostics: action.diagnostics ? action.diagnostics.map(m => toMonacoMarkerData(m)) : undefined,
        disabled: (_a = action.disabled) === null || _a === void 0 ? void 0 : _a.reason,
        edit: action.edit ? toMonacoWorkspaceEdit(action.edit) : undefined
    };
}
function toMonacoMarkerData(marker) {
    return {
        ...marker,
        relatedInformation: marker.relatedInformation
            ? marker.relatedInformation.map(i => toMonacoRelatedInformation(i))
            : undefined
    };
}
function toMonacoRelatedInformation(relatedInfo) {
    return {
        ...relatedInfo,
        resource: monaco.Uri.parse(relatedInfo.resource)
    };
}
function toMonacoWorkspaceEdit(data) {
    return {
        edits: (data && data.edits || []).map(edit => {
            if (plugin_api_rpc_1.WorkspaceTextEditDto.is(edit)) {
                return {
                    resource: monaco.Uri.revive(edit.resource),
                    textEdit: edit.textEdit,
                    metadata: edit.metadata
                };
            }
            else {
                const fileEdit = edit;
                return {
                    newResource: monaco.Uri.revive(fileEdit.newResource),
                    oldResource: monaco.Uri.revive(fileEdit.oldResource),
                    options: fileEdit.options,
                    metadata: fileEdit.metadata
                };
            }
        })
    };
}
exports.toMonacoWorkspaceEdit = toMonacoWorkspaceEdit;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/lm-main.js"
/*!************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/lm-main.js ***!
  \************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2025 EclipseSource
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.McpServerDefinitionRegistryMainImpl = void 0;
const lm_protocol_1 = __webpack_require__(/*! ../../common/lm-protocol */ "../../node_modules/@theia/plugin-ext/lib/common/lm-protocol.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const common_1 = __webpack_require__(/*! @theia/ai-mcp/lib/common */ "../../node_modules/@theia/ai-mcp/lib/common/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
class McpServerDefinitionRegistryMainImpl {
    constructor(rpc, container) {
        this.providers = new Map();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.MCP_SERVER_DEFINITION_REGISTRY_EXT);
        try {
            this.mcpServerManager = container.get(common_1.MCPServerManager);
        }
        catch {
            // MCP Server Manager is optional
            this.mcpServerManager = undefined;
        }
    }
    $registerMcpServerDefinitionProvider(handle, name) {
        this.providers.set(handle, name);
        this.loadServerDefinitions(handle);
    }
    async $unregisterMcpServerDefinitionProvider(handle) {
        if (!this.mcpServerManager) {
            console.warn('MCP Server Manager not available - MCP server definitions will not be loaded');
            return;
        }
        const provider = this.providers.get(handle);
        if (!provider) {
            console.warn(`No MCP Server provider found for handle '${handle}' - MCP server definitions will not be loaded`);
            return;
        }
        // Get all servers provided by this provider and remove them server by server
        try {
            const definitions = await this.$getServerDefinitions(handle);
            for (const definition of definitions) {
                this.mcpServerManager.removeServer(definition.label);
            }
        }
        catch (error) {
            console.error('Error getting server definitions for removal:', error);
        }
        this.providers.delete(handle);
    }
    $onDidChangeMcpServerDefinitions(handle) {
        // Reload server definitions when provider reports changes
        this.loadServerDefinitions(handle);
    }
    async $getServerDefinitions(handle) {
        try {
            return await this.proxy.$provideServerDefinitions(handle);
        }
        catch (error) {
            console.error('Error getting MCP server definitions:', error);
            return [];
        }
    }
    async $resolveServerDefinition(handle, server) {
        try {
            return await this.proxy.$resolveServerDefinition(handle, server);
        }
        catch (error) {
            console.error('Error resolving MCP server definition:', error);
            return server;
        }
    }
    async loadServerDefinitions(handle) {
        if (!this.mcpServerManager) {
            console.warn('MCP Server Manager not available - MCP server definitions will not be loaded');
            return;
        }
        try {
            const definitions = await this.$getServerDefinitions(handle);
            for (const definition of definitions) {
                const mcpServerDescription = this.convertToMcpServerDescription(handle, definition);
                this.mcpServerManager.addOrUpdateServer(mcpServerDescription);
            }
        }
        catch (error) {
            console.error('Error loading MCP server definitions:', error);
        }
    }
    convertToMcpServerDescription(handle, definition) {
        const self = this;
        if ((0, lm_protocol_1.isMcpHttpServerDefinitionDto)(definition)) {
            // Convert headers values to strings, filtering out null values
            let convertedHeaders;
            if (definition.headers) {
                convertedHeaders = {};
                for (const [key, value] of Object.entries(definition.headers)) {
                    if (value !== null) {
                        convertedHeaders[key] = String(value);
                    }
                }
            }
            const serverDescription = {
                name: definition.label,
                serverUrl: core_1.URI.fromComponents(definition.uri).toString(),
                headers: convertedHeaders,
                autostart: false,
                async resolve(description) {
                    const resolved = await self.$resolveServerDefinition(handle, definition);
                    if (resolved) {
                        return self.convertToMcpServerDescription(handle, resolved);
                    }
                    return description;
                }
            };
            return serverDescription;
        }
        // Convert env values to strings, filtering out null values
        let convertedEnv;
        if (definition.env) {
            convertedEnv = {};
            for (const [key, value] of Object.entries(definition.env)) {
                if (value !== null) {
                    convertedEnv[key] = String(value);
                }
            }
        }
        return {
            name: definition.label,
            command: definition.command,
            args: definition.args,
            env: convertedEnv,
            autostart: false, // Extensions should manage their own server lifecycle
            async resolve(serverDescription) {
                const resolved = await self.$resolveServerDefinition(handle, definition);
                if (resolved) {
                    return self.convertToMcpServerDescription(handle, resolved);
                }
                return serverDescription;
            }
        };
    }
}
exports.McpServerDefinitionRegistryMainImpl = McpServerDefinitionRegistryMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/localization-main.js"
/*!**********************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/localization-main.js ***!
  \**********************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocalizationMainImpl = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const language_pack_service_1 = __webpack_require__(/*! ../../common/language-pack-service */ "../../node_modules/@theia/plugin-ext/lib/common/language-pack-service.js");
class LocalizationMainImpl {
    constructor(container) {
        this.languagePackService = container.get(language_pack_service_1.LanguagePackService);
    }
    async $fetchBundle(id) {
        var _a;
        const bundle = await this.languagePackService.getBundle(id, (_a = core_1.nls.locale) !== null && _a !== void 0 ? _a : core_1.nls.defaultLocale);
        return bundle;
    }
}
exports.LocalizationMainImpl = LocalizationMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/logger-main.js"
/*!****************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/logger-main.js ***!
  \****************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2025 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoggerMainImpl = void 0;
const common_1 = __webpack_require__(/*! ../../common */ "../../node_modules/@theia/plugin-ext/lib/common/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
class LoggerMainImpl {
    constructor(container) {
        this.container = container;
    }
    $log(level, name, message, params) {
        let logger;
        if (name) {
            logger = this.container.getNamed(core_1.ILogger, name);
        }
        else {
            logger = this.container.get(core_1.ILogger);
        }
        switch (level) {
            case common_1.LogLevel.Trace:
                logger.trace(message, ...params);
                break;
            case common_1.LogLevel.Debug:
                logger.debug(message, ...params);
                break;
            case common_1.LogLevel.Info:
                logger.info(message, ...params);
                break;
            case common_1.LogLevel.Warn:
                logger.warn(message, ...params);
                break;
            case common_1.LogLevel.Error:
                logger.error(message, ...params);
                break;
        }
    }
}
exports.LoggerMainImpl = LoggerMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/main-context.js"
/*!*****************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/main-context.js ***!
  \*****************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setUpPluginApi = void 0;
const command_registry_main_1 = __webpack_require__(/*! ./command-registry-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/command-registry-main.js");
const preference_registry_main_1 = __webpack_require__(/*! ./preference-registry-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/preference-registry-main.js");
const quick_open_main_1 = __webpack_require__(/*! ./quick-open-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/quick-open-main.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const message_registry_main_1 = __webpack_require__(/*! ./message-registry-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/message-registry-main.js");
const window_state_main_1 = __webpack_require__(/*! ./window-state-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/window-state-main.js");
const workspace_main_1 = __webpack_require__(/*! ./workspace-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/workspace-main.js");
const status_bar_message_registry_main_1 = __webpack_require__(/*! ./status-bar-message-registry-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/status-bar-message-registry-main.js");
const env_main_1 = __webpack_require__(/*! ./env-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/env-main.js");
const editors_and_documents_main_1 = __webpack_require__(/*! ./editors-and-documents-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/editors-and-documents-main.js");
const terminal_main_1 = __webpack_require__(/*! ./terminal-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/terminal-main.js");
const dialogs_main_1 = __webpack_require__(/*! ./dialogs-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/dialogs-main.js");
const tree_views_main_1 = __webpack_require__(/*! ./view/tree-views-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/tree-views-main.js");
const notification_main_1 = __webpack_require__(/*! ./notification-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/notification-main.js");
const connection_1 = __webpack_require__(/*! ../../common/connection */ "../../node_modules/@theia/plugin-ext/lib/common/connection.js");
const webviews_main_1 = __webpack_require__(/*! ./webviews-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webviews-main.js");
const tasks_main_1 = __webpack_require__(/*! ./tasks-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/tasks-main.js");
const plugin_storage_1 = __webpack_require__(/*! ./plugin-storage */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-storage.js");
const debug_main_1 = __webpack_require__(/*! ./debug/debug-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/debug/debug-main.js");
const file_system_main_impl_1 = __webpack_require__(/*! ./file-system-main-impl */ "../../node_modules/@theia/plugin-ext/lib/main/browser/file-system-main-impl.js");
const scm_main_1 = __webpack_require__(/*! ./scm-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/scm-main.js");
const decorations_main_1 = __webpack_require__(/*! ./decorations/decorations-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/decorations/decorations-main.js");
const clipboard_main_1 = __webpack_require__(/*! ./clipboard-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/clipboard-main.js");
const documents_main_1 = __webpack_require__(/*! ./documents-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/documents-main.js");
const text_editors_main_1 = __webpack_require__(/*! ./text-editors-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/text-editors-main.js");
const text_editor_model_service_1 = __webpack_require__(/*! ./text-editor-model-service */ "../../node_modules/@theia/plugin-ext/lib/main/browser/text-editor-model-service.js");
const opener_service_1 = __webpack_require__(/*! @theia/core/lib/browser/opener-service */ "../../node_modules/@theia/core/lib/browser/opener-service.js");
const application_shell_1 = __webpack_require__(/*! @theia/core/lib/browser/shell/application-shell */ "../../node_modules/@theia/core/lib/browser/shell/application-shell.js");
const main_file_system_event_service_1 = __webpack_require__(/*! ./main-file-system-event-service */ "../../node_modules/@theia/plugin-ext/lib/main/browser/main-file-system-event-service.js");
const label_service_main_1 = __webpack_require__(/*! ./label-service-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/label-service-main.js");
const timeline_main_1 = __webpack_require__(/*! ./timeline-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/timeline-main.js");
const authentication_main_1 = __webpack_require__(/*! ./authentication-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/authentication-main.js");
const theming_main_1 = __webpack_require__(/*! ./theming-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/theming-main.js");
const comments_main_1 = __webpack_require__(/*! ./comments/comments-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-main.js");
const custom_editors_main_1 = __webpack_require__(/*! ./custom-editors/custom-editors-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editors-main.js");
const secrets_main_1 = __webpack_require__(/*! ./secrets-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/secrets-main.js");
const webview_views_main_1 = __webpack_require__(/*! ./webview-views/webview-views-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview-views/webview-views-main.js");
const monaco_languages_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-languages */ "../../node_modules/@theia/monaco/lib/browser/monaco-languages.js");
const resource_1 = __webpack_require__(/*! @theia/core/lib/common/resource */ "../../node_modules/@theia/core/lib/common/resource.js");
const theming_1 = __webpack_require__(/*! @theia/core/lib/browser/theming */ "../../node_modules/@theia/core/lib/browser/theming.js");
const tabs_main_1 = __webpack_require__(/*! ./tabs/tabs-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/tabs/tabs-main.js");
const notebooks_main_1 = __webpack_require__(/*! ./notebooks/notebooks-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebooks-main.js");
const localization_main_1 = __webpack_require__(/*! ./localization-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/localization-main.js");
const notebook_renderers_main_1 = __webpack_require__(/*! ./notebooks/notebook-renderers-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-renderers-main.js");
const notebook_editors_main_1 = __webpack_require__(/*! ./notebooks/notebook-editors-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-editors-main.js");
const notebook_documents_main_1 = __webpack_require__(/*! ./notebooks/notebook-documents-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-documents-main.js");
const notebook_kernels_main_1 = __webpack_require__(/*! ./notebooks/notebook-kernels-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-kernels-main.js");
const notebook_documents_and_editors_main_1 = __webpack_require__(/*! ./notebooks/notebook-documents-and-editors-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-documents-and-editors-main.js");
const test_main_1 = __webpack_require__(/*! ./test-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/test-main.js");
const uri_main_1 = __webpack_require__(/*! ./uri-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/uri-main.js");
const logger_main_1 = __webpack_require__(/*! ./logger-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/logger-main.js");
const lm_main_1 = __webpack_require__(/*! ./lm-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/lm-main.js");
function setUpPluginApi(rpc, container) {
    const loggerMain = new logger_main_1.LoggerMainImpl(container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.LOGGER_MAIN, loggerMain);
    const authenticationMain = new authentication_main_1.AuthenticationMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.AUTHENTICATION_MAIN, authenticationMain);
    const commandRegistryMain = new command_registry_main_1.CommandRegistryMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.COMMAND_REGISTRY_MAIN, commandRegistryMain);
    const quickOpenMain = new quick_open_main_1.QuickOpenMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.QUICK_OPEN_MAIN, quickOpenMain);
    const workspaceMain = new workspace_main_1.WorkspaceMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.WORKSPACE_MAIN, workspaceMain);
    const dialogsMain = new dialogs_main_1.DialogsMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.DIALOGS_MAIN, dialogsMain);
    const messageRegistryMain = new message_registry_main_1.MessageRegistryMainImpl(container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.MESSAGE_REGISTRY_MAIN, messageRegistryMain);
    const preferenceRegistryMain = new preference_registry_main_1.PreferenceRegistryMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.PREFERENCE_REGISTRY_MAIN, preferenceRegistryMain);
    const tabsMain = new tabs_main_1.TabsMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.TABS_MAIN, tabsMain);
    const editorsAndDocuments = new editors_and_documents_main_1.EditorsAndDocumentsMain(rpc, container, tabsMain);
    const notebookDocumentsMain = new notebook_documents_main_1.NotebookDocumentsMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.NOTEBOOK_DOCUMENTS_MAIN, notebookDocumentsMain);
    const modelService = container.get(text_editor_model_service_1.EditorModelService);
    const openerService = container.get(opener_service_1.OpenerService);
    const shell = container.get(application_shell_1.ApplicationShell);
    const untitledResourceResolver = container.get(resource_1.UntitledResourceResolver);
    const languageService = container.get(monaco_languages_1.MonacoLanguages);
    const documentsMain = new documents_main_1.DocumentsMainImpl(editorsAndDocuments, notebookDocumentsMain, modelService, rpc, openerService, shell, untitledResourceResolver, languageService);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.DOCUMENTS_MAIN, documentsMain);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.NOTEBOOKS_MAIN, new notebooks_main_1.NotebooksMainImpl(rpc, container, commandRegistryMain));
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.NOTEBOOK_RENDERERS_MAIN, new notebook_renderers_main_1.NotebookRenderersMainImpl(rpc, container));
    const notebookEditorsMain = new notebook_editors_main_1.NotebookEditorsMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.NOTEBOOK_EDITORS_MAIN, notebookEditorsMain);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.NOTEBOOK_DOCUMENTS_AND_EDITORS_MAIN, new notebook_documents_and_editors_main_1.NotebooksAndEditorsMain(rpc, container, tabsMain, notebookDocumentsMain, notebookEditorsMain));
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.NOTEBOOK_KERNELS_MAIN, new notebook_kernels_main_1.NotebookKernelsMainImpl(rpc, container));
    const editorsMain = new text_editors_main_1.TextEditorsMainImpl(editorsAndDocuments, documentsMain, rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.TEXT_EDITORS_MAIN, editorsMain);
    // start listening only after all clients are subscribed to events
    editorsAndDocuments.listen();
    const statusBarMessageRegistryMain = new status_bar_message_registry_main_1.StatusBarMessageRegistryMainImpl(container, rpc);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.STATUS_BAR_MESSAGE_REGISTRY_MAIN, statusBarMessageRegistryMain);
    const envMain = new env_main_1.EnvMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.ENV_MAIN, envMain);
    const notificationMain = new notification_main_1.NotificationMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.NOTIFICATION_MAIN, notificationMain);
    const testingMain = new test_main_1.TestingMainImpl(rpc, container, commandRegistryMain);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.TESTING_MAIN, testingMain);
    const terminalMain = new terminal_main_1.TerminalServiceMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.TERMINAL_MAIN, terminalMain);
    const treeViewsMain = new tree_views_main_1.TreeViewsMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.TREE_VIEWS_MAIN, treeViewsMain);
    const outputChannelRegistryFactory = container.get(plugin_api_rpc_1.OutputChannelRegistryFactory);
    const outputChannelRegistryMain = outputChannelRegistryFactory();
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.OUTPUT_CHANNEL_REGISTRY_MAIN, outputChannelRegistryMain);
    const languagesMainFactory = container.get(plugin_api_rpc_1.LanguagesMainFactory);
    const languagesMain = languagesMainFactory(rpc);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.LANGUAGES_MAIN, languagesMain);
    const webviewsMain = new webviews_main_1.WebviewsMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.WEBVIEWS_MAIN, webviewsMain);
    const customEditorsMain = new custom_editors_main_1.CustomEditorsMainImpl(rpc, container, webviewsMain);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.CUSTOM_EDITORS_MAIN, customEditorsMain);
    const webviewViewsMain = new webview_views_main_1.WebviewViewsMainImpl(rpc, container, webviewsMain);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.WEBVIEW_VIEWS_MAIN, webviewViewsMain);
    const storageMain = new plugin_storage_1.StorageMainImpl(container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.STORAGE_MAIN, storageMain);
    const connectionMain = new connection_1.ConnectionImpl(rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.CONNECTION_EXT));
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.CONNECTION_MAIN, connectionMain);
    const tasksMain = new tasks_main_1.TasksMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.TASKS_MAIN, tasksMain);
    const debugMain = new debug_main_1.DebugMainImpl(rpc, connectionMain, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.DEBUG_MAIN, debugMain);
    const fs = new file_system_main_impl_1.FileSystemMainImpl(rpc, container);
    const fsEventService = new main_file_system_event_service_1.MainFileSystemEventService(rpc, container);
    const disposeFS = fs.dispose.bind(fs);
    fs.dispose = () => {
        fsEventService.dispose();
        disposeFS();
    };
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.FILE_SYSTEM_MAIN, fs);
    const scmMain = new scm_main_1.ScmMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.SCM_MAIN, scmMain);
    const secretsMain = new secrets_main_1.SecretsMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.SECRETS_MAIN, secretsMain);
    const decorationsMain = new decorations_main_1.DecorationsMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.DECORATIONS_MAIN, decorationsMain);
    const windowMain = new window_state_main_1.WindowStateMain(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.WINDOW_MAIN, windowMain);
    const clipboardMain = new clipboard_main_1.ClipboardMainImpl(container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.CLIPBOARD_MAIN, clipboardMain);
    const labelServiceMain = new label_service_main_1.LabelServiceMainImpl(container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.LABEL_SERVICE_MAIN, labelServiceMain);
    const timelineMain = new timeline_main_1.TimelineMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.TIMELINE_MAIN, timelineMain);
    const themingMain = new theming_main_1.ThemingMainImpl(rpc, container.get(theming_1.ThemeService));
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.THEMING_MAIN, themingMain);
    const commentsMain = new comments_main_1.CommentsMainImp(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.COMMENTS_MAIN, commentsMain);
    const localizationMain = new localization_main_1.LocalizationMainImpl(container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.LOCALIZATION_MAIN, localizationMain);
    const uriMain = new uri_main_1.UriMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.URI_MAIN, uriMain);
    const mcpServerDefinitionRegistryMain = new lm_main_1.McpServerDefinitionRegistryMainImpl(rpc, container);
    rpc.set(plugin_api_rpc_1.PLUGIN_RPC_CONTEXT.MCP_SERVER_DEFINITION_REGISTRY_MAIN, mcpServerDefinitionRegistryMain);
}
exports.setUpPluginApi = setUpPluginApi;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/main-file-system-event-service.js"
/*!***********************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/main-file-system-event-service.js ***!
  \***********************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/workbench/api/browser/mainThreadFileSystemEventService.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MainFileSystemEventService = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../../node_modules/@theia/filesystem/lib/browser/file-service.js");
class MainFileSystemEventService {
    constructor(rpc, container) {
        this.toDispose = new disposable_1.DisposableCollection();
        const proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.ExtHostFileSystemEventService);
        const fileService = container.get(file_service_1.FileService);
        this.toDispose.push(fileService.onDidFilesChange(event => {
            // file system events - (changes the editor and others make)
            const events = {
                created: [],
                changed: [],
                deleted: []
            };
            for (const change of event.changes) {
                switch (change.type) {
                    case 1 /* FileChangeType.ADDED */:
                        events.created.push(change.resource['codeUri']);
                        break;
                    case 0 /* FileChangeType.UPDATED */:
                        events.changed.push(change.resource['codeUri']);
                        break;
                    case 2 /* FileChangeType.DELETED */:
                        events.deleted.push(change.resource['codeUri']);
                        break;
                }
            }
            proxy.$onFileEvent(events);
        }));
        // BEFORE file operation
        fileService.addFileOperationParticipant({
            participate: (target, source, operation, timeout, token) => proxy.$onWillRunFileOperation(operation, target['codeUri'], source === null || source === void 0 ? void 0 : source['codeUri'], timeout, token)
        });
        // AFTER file operation
        this.toDispose.push(fileService.onDidRunUserOperation(e => { var _a; return proxy.$onDidRunFileOperation(e.operation, e.target['codeUri'], (_a = e.source) === null || _a === void 0 ? void 0 : _a['codeUri']); }));
    }
    dispose() {
        this.toDispose.dispose();
    }
}
exports.MainFileSystemEventService = MainFileSystemEventService;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/menus/menus-contribution-handler.js"
/*!*************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/menus/menus-contribution-handler.js ***!
  \*************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MenusContributionPointHandler = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
/* eslint-disable @typescript-eslint/no-explicit-any */
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../../node_modules/@theia/core/lib/common/index.js");
const tab_bar_toolbar_1 = __webpack_require__(/*! @theia/core/lib/browser/shell/tab-bar-toolbar */ "../../node_modules/@theia/core/lib/browser/shell/tab-bar-toolbar/index.js");
const scm_widget_1 = __webpack_require__(/*! @theia/scm/lib/browser/scm-widget */ "../../node_modules/@theia/scm/lib/browser/scm-widget.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const vscode_theia_menu_mappings_1 = __webpack_require__(/*! ./vscode-theia-menu-mappings */ "../../node_modules/@theia/plugin-ext/lib/main/browser/menus/vscode-theia-menu-mappings.js");
const plugin_menu_command_adapter_1 = __webpack_require__(/*! ./plugin-menu-command-adapter */ "../../node_modules/@theia/plugin-ext/lib/main/browser/menus/plugin-menu-command-adapter.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../../node_modules/@theia/core/lib/browser/context-key-service.js");
const plugin_shared_style_1 = __webpack_require__(/*! ../plugin-shared-style */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-shared-style.js");
const themables_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/base/common/themables */ "../../node_modules/@theia/monaco-editor-core/esm/vs/base/common/themables.js");
let MenusContributionPointHandler = class MenusContributionPointHandler {
    constructor() {
        this.initialized = false;
    }
    initialize() {
        this.initialized = true;
        this.tabBarToolbar.registerMenuDelegate(vscode_theia_menu_mappings_1.PLUGIN_EDITOR_TITLE_MENU, widget => vscode_theia_menu_mappings_1.CodeEditorWidgetUtil.is(widget));
        this.menuRegistry.registerSubmenu(vscode_theia_menu_mappings_1.PLUGIN_EDITOR_TITLE_RUN_MENU, 'EditorTitleRunMenu');
        this.tabBarToolbar.registerItem({
            id: this.tabBarToolbar.toElementId(vscode_theia_menu_mappings_1.PLUGIN_EDITOR_TITLE_RUN_MENU),
            menuPath: vscode_theia_menu_mappings_1.PLUGIN_EDITOR_TITLE_RUN_MENU,
            icon: (0, browser_1.codicon)('debug-alt'),
            text: core_1.nls.localizeByDefault('Run or Debug...'),
            command: '',
            group: 'navigation',
            isVisible: widget => vscode_theia_menu_mappings_1.CodeEditorWidgetUtil.is(widget)
        });
        this.tabBarToolbar.registerMenuDelegate(vscode_theia_menu_mappings_1.PLUGIN_SCM_TITLE_MENU, widget => widget instanceof scm_widget_1.ScmWidget);
        this.tabBarToolbar.registerMenuDelegate(vscode_theia_menu_mappings_1.PLUGIN_VIEW_TITLE_MENU, widget => !vscode_theia_menu_mappings_1.CodeEditorWidgetUtil.is(widget));
    }
    getMatchingTheiaMenuPaths(contributionPoint) {
        return vscode_theia_menu_mappings_1.codeToTheiaMappings.get(contributionPoint);
    }
    handle(plugin) {
        var _a, _b, _c;
        const allMenus = (_a = plugin.contributes) === null || _a === void 0 ? void 0 : _a.menus;
        if (!allMenus) {
            return core_1.Disposable.NULL;
        }
        if (!this.initialized) {
            this.initialize();
        }
        const toDispose = new core_1.DisposableCollection();
        const submenus = (_c = (_b = plugin.contributes) === null || _b === void 0 ? void 0 : _b.submenus) !== null && _c !== void 0 ? _c : [];
        for (const submenu of submenus) {
            const iconClass = submenu.icon && this.toIconClass(submenu.icon, toDispose);
            this.menuRegistry.registerSubmenu([submenu.id], submenu.label, { icon: iconClass });
        }
        for (const [contributionPoint, items] of Object.entries(allMenus)) {
            for (const item of items) {
                try {
                    if (contributionPoint === 'commandPalette') {
                        toDispose.push(this.registerCommandPaletteAction(item));
                    }
                    else {
                        let targets = this.getMatchingTheiaMenuPaths(contributionPoint);
                        if (!targets) {
                            targets = [[contributionPoint]];
                        }
                        const { group, order } = this.parseGroup(item.group);
                        const { submenu, command } = item;
                        if (submenu && command) {
                            console.warn(`Menu item ${command} from plugin ${plugin.metadata.model.id} contributed both submenu and command. Only command will be registered.`);
                        }
                        if (command) {
                            targets.forEach(target => {
                                const menuPath = group ? [...target, group] : target;
                                const cmd = this.commandRegistry.getCommand(command);
                                if (!cmd) {
                                    console.debug(`No label for action menu node: No command "${command}" exists.`);
                                    return;
                                }
                                const label = cmd.label || cmd.id;
                                const icon = cmd.iconClass;
                                const action = {
                                    id: command,
                                    sortString: order || '',
                                    isVisible: (effectiveMenuPath, contextMatcher, context, ...args) => {
                                        if (item.when && !contextMatcher.match(item.when, context)) {
                                            return false;
                                        }
                                        return this.commandRegistry.isVisible(command, ...this.pluginMenuCommandAdapter.getArgumentAdapter(effectiveMenuPath)(...args));
                                    },
                                    icon: icon,
                                    label: label,
                                    isEnabled: (effeciveMenuPath, ...args) => this.commandRegistry.isEnabled(command, ...this.pluginMenuCommandAdapter.getArgumentAdapter(effeciveMenuPath)(...args)),
                                    run: (effeciveMenuPath, ...args) => this.commandRegistry.executeCommand(command, ...this.pluginMenuCommandAdapter.getArgumentAdapter(effeciveMenuPath)(...args)),
                                    isToggled: (effectiveMenuPath) => false,
                                    getAccelerator: (context) => {
                                        const bindings = this.keybindingRegistry.getKeybindingsForCommand(command);
                                        // Only consider the first active keybinding.
                                        if (bindings.length) {
                                            const binding = bindings.find(b => this.keybindingRegistry.isEnabledInScope(b, context));
                                            if (binding) {
                                                return this.keybindingRegistry.acceleratorFor(binding, '+', true);
                                            }
                                        }
                                        return [];
                                    }
                                };
                                toDispose.push(this.menuRegistry.registerCommandMenu(menuPath, action));
                            });
                        }
                        else if (submenu) {
                            targets.forEach(target => toDispose.push(this.menuRegistry.linkCompoundMenuNode({
                                newParentPath: group ? [...target, group] : target,
                                submenuPath: [submenu],
                                order: order,
                                when: item.when
                            })));
                        }
                    }
                }
                catch (error) {
                    console.warn(`Failed to register a menu item for plugin ${plugin.metadata.model.id} contributed to ${contributionPoint}`, item);
                    console.debug(error);
                }
            }
        }
        return toDispose;
    }
    parseGroup(rawGroup) {
        if (!rawGroup) {
            return {};
        }
        const separatorIndex = rawGroup.lastIndexOf('@');
        if (separatorIndex > -1) {
            return { group: rawGroup.substring(0, separatorIndex), order: rawGroup.substring(separatorIndex + 1) || undefined };
        }
        return { group: rawGroup };
    }
    registerCommandPaletteAction(menu) {
        if (menu.command && menu.when) {
            return this.quickCommandService.pushCommandContext(menu.command, menu.when);
        }
        return core_1.Disposable.NULL;
    }
    toIconClass(url, toDispose) {
        if (typeof url === 'string') {
            const asThemeIcon = themables_1.ThemeIcon.fromString(url);
            if (asThemeIcon) {
                return themables_1.ThemeIcon.asClassName(asThemeIcon);
            }
        }
        const reference = this.style.toIconClass(url);
        toDispose.push(reference);
        return reference.object.iconClass;
    }
};
exports.MenusContributionPointHandler = MenusContributionPointHandler;
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.MenuModelRegistry),
    tslib_1.__metadata("design:type", common_1.MenuModelRegistry)
], MenusContributionPointHandler.prototype, "menuRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.CommandRegistry),
    tslib_1.__metadata("design:type", core_1.CommandRegistry)
], MenusContributionPointHandler.prototype, "commandRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(tab_bar_toolbar_1.TabBarToolbarRegistry),
    tslib_1.__metadata("design:type", tab_bar_toolbar_1.TabBarToolbarRegistry)
], MenusContributionPointHandler.prototype, "tabBarToolbar", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_menu_command_adapter_1.PluginMenuCommandAdapter),
    tslib_1.__metadata("design:type", plugin_menu_command_adapter_1.PluginMenuCommandAdapter)
], MenusContributionPointHandler.prototype, "pluginMenuCommandAdapter", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], MenusContributionPointHandler.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_shared_style_1.PluginSharedStyle),
    tslib_1.__metadata("design:type", plugin_shared_style_1.PluginSharedStyle)
], MenusContributionPointHandler.prototype, "style", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.KeybindingRegistry),
    tslib_1.__metadata("design:type", browser_1.KeybindingRegistry)
], MenusContributionPointHandler.prototype, "keybindingRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.QuickCommandService),
    (0, inversify_1.optional)(),
    tslib_1.__metadata("design:type", browser_1.QuickCommandService)
], MenusContributionPointHandler.prototype, "quickCommandService", void 0);
exports.MenusContributionPointHandler = MenusContributionPointHandler = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], MenusContributionPointHandler);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/menus/plugin-menu-command-adapter.js"
/*!**************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/menus/plugin-menu-command-adapter.js ***!
  \**************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginMenuCommandAdapter = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const resource_context_key_1 = __webpack_require__(/*! @theia/core/lib/browser/resource-context-key */ "../../node_modules/@theia/core/lib/browser/resource-context-key.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../../node_modules/@theia/core/shared/vscode-uri/index.js");
const tree_widget_selection_1 = __webpack_require__(/*! @theia/core/lib/browser/tree/tree-widget-selection */ "../../node_modules/@theia/core/lib/browser/tree/tree-widget-selection.js");
const scm_repository_1 = __webpack_require__(/*! @theia/scm/lib/browser/scm-repository */ "../../node_modules/@theia/scm/lib/browser/scm-repository.js");
const scm_service_1 = __webpack_require__(/*! @theia/scm/lib/browser/scm-service */ "../../node_modules/@theia/scm/lib/browser/scm-service.js");
const dirty_diff_widget_1 = __webpack_require__(/*! @theia/scm/lib/browser/dirty-diff/dirty-diff-widget */ "../../node_modules/@theia/scm/lib/browser/dirty-diff/dirty-diff-widget.js");
const diff_computer_1 = __webpack_require__(/*! @theia/scm/lib/browser/dirty-diff/diff-computer */ "../../node_modules/@theia/scm/lib/browser/dirty-diff/diff-computer.js");
const common_1 = __webpack_require__(/*! ../../../common */ "../../node_modules/@theia/plugin-ext/lib/common/index.js");
const test_types_1 = __webpack_require__(/*! ../../../common/test-types */ "../../node_modules/@theia/plugin-ext/lib/common/test-types.js");
const scm_main_1 = __webpack_require__(/*! ../scm-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/scm-main.js");
const tree_view_widget_1 = __webpack_require__(/*! ../view/tree-view-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/tree-view-widget.js");
const vscode_theia_menu_mappings_1 = __webpack_require__(/*! ./vscode-theia-menu-mappings */ "../../node_modules/@theia/plugin-ext/lib/main/browser/menus/vscode-theia-menu-mappings.js");
const test_service_1 = __webpack_require__(/*! @theia/test/lib/browser/test-service */ "../../node_modules/@theia/test/lib/browser/test-service.js");
function identity(...args) {
    return args;
}
let PluginMenuCommandAdapter = class PluginMenuCommandAdapter {
    constructor() {
        this.argumentAdapters = new Map();
        /* eslint-enable @typescript-eslint/no-explicit-any */
    }
    init() {
        const toCommentArgs = (...args) => this.toCommentArgs(...args);
        const toTestMessageArgs = (...args) => this.toTestMessageArgs(...args);
        const firstArgOnly = (...args) => [args[0]];
        const noArgs = () => [];
        const toScmArgs = (...args) => this.toScmArgs(...args);
        const selectedResource = () => this.getSelectedResources();
        const widgetURI = widget => vscode_theia_menu_mappings_1.CodeEditorWidgetUtil.is(widget) ? [vscode_theia_menu_mappings_1.CodeEditorWidgetUtil.getResourceUri(widget)] : [];
        [
            ['comments/comment/context', toCommentArgs],
            ['comments/comment/title', toCommentArgs],
            ['comments/commentThread/context', toCommentArgs],
            ['debug/callstack/context', firstArgOnly],
            ['debug/variables/context', firstArgOnly],
            ['debug/toolBar', noArgs],
            ['editor/context', selectedResource],
            ['editor/content', widgetURI],
            ['editor/title', widgetURI],
            ['editor/title/context', selectedResource],
            ['editor/title/run', widgetURI],
            ['explorer/context', selectedResource],
            ['scm/resourceFolder/context', toScmArgs],
            ['scm/resourceGroup/context', toScmArgs],
            ['scm/resourceState/context', toScmArgs],
            ['scm/title', () => [this.toScmArg(this.scmService.selectedRepository)]],
            ['testing/message/context', toTestMessageArgs],
            ['testing/profiles/context', noArgs],
            ['scm/change/title', (...args) => this.toScmChangeArgs(...args)],
            ['timeline/item/context', (...args) => this.toTimelineArgs(...args)],
            ['view/item/context', (...args) => this.toTreeArgs(...args)],
            ['view/title', noArgs],
            ['webview/context', firstArgOnly],
            ['extension/context', noArgs],
            ['terminal/context', noArgs],
            ['terminal/title/context', noArgs],
        ].forEach(([contributionPoint, adapter]) => {
            this.argumentAdapters.set(contributionPoint, adapter);
        });
    }
    getArgumentAdapter(menuPath) {
        for (const [contributionPoint, menuPaths] of vscode_theia_menu_mappings_1.codeToTheiaMappings) {
            for (const theiaPath of menuPaths) {
                if (this.isPrefixOf(theiaPath, menuPath)) {
                    return this.argumentAdapters.get(contributionPoint) || identity;
                }
            }
        }
        return identity;
    }
    isPrefixOf(candidate, menuPath) {
        if (candidate.length > menuPath.length) {
            return false;
        }
        for (let i = 0; i < candidate.length; i++) {
            if (candidate[i] !== menuPath[i]) {
                return false;
            }
        }
        return true;
    }
    /* eslint-disable @typescript-eslint/no-explicit-any */
    toCommentArgs(...args) {
        const arg = args[0];
        if ('text' in arg) {
            if ('commentUniqueId' in arg) {
                return [{
                        commentControlHandle: arg.thread.controllerHandle,
                        commentThreadHandle: arg.thread.commentThreadHandle,
                        text: arg.text,
                        commentUniqueId: arg.commentUniqueId
                    }];
            }
            return [{
                    commentControlHandle: arg.thread.controllerHandle,
                    commentThreadHandle: arg.thread.commentThreadHandle,
                    text: arg.text
                }];
        }
        return [{
                commentControlHandle: arg.thread.controllerHandle,
                commentThreadHandle: arg.thread.commentThreadHandle,
                commentUniqueId: arg.commentUniqueId
            }];
    }
    toScmArgs(...args) {
        const scmArgs = [];
        for (const arg of args) {
            const scmArg = this.toScmArg(arg);
            if (scmArg) {
                scmArgs.push(scmArg);
            }
        }
        return scmArgs;
    }
    toScmArg(arg) {
        if (arg instanceof scm_repository_1.ScmRepository && arg.provider instanceof scm_main_1.PluginScmProvider) {
            return {
                sourceControlHandle: arg.provider.handle
            };
        }
        if (arg instanceof scm_main_1.PluginScmResourceGroup) {
            return {
                sourceControlHandle: arg.provider.handle,
                resourceGroupHandle: arg.handle
            };
        }
        if (arg instanceof scm_main_1.PluginScmResource) {
            return {
                sourceControlHandle: arg.group.provider.handle,
                resourceGroupHandle: arg.group.handle,
                resourceStateHandle: arg.handle
            };
        }
    }
    toScmChangeArgs(...args) {
        const arg = args[0];
        if (arg instanceof dirty_diff_widget_1.DirtyDiffWidget) {
            const toIChange = (change) => {
                const convert = (range) => {
                    let startLineNumber;
                    let endLineNumber;
                    if (!diff_computer_1.LineRange.isEmpty(range)) {
                        startLineNumber = range.start + 1;
                        endLineNumber = range.end;
                    }
                    else {
                        startLineNumber = range.start;
                        endLineNumber = 0;
                    }
                    return [startLineNumber, endLineNumber];
                };
                const { previousRange, currentRange } = change;
                const [originalStartLineNumber, originalEndLineNumber] = convert(previousRange);
                const [modifiedStartLineNumber, modifiedEndLineNumber] = convert(currentRange);
                return {
                    originalStartLineNumber,
                    originalEndLineNumber,
                    modifiedStartLineNumber,
                    modifiedEndLineNumber
                };
            };
            return [
                arg.uri['codeUri'],
                arg.changes.map(toIChange),
                arg.currentChangeIndex
            ];
        }
        return [];
    }
    toTimelineArgs(...args) {
        var _a;
        const timelineArgs = [];
        const arg = args[0];
        timelineArgs.push(this.toTimelineArg(arg));
        timelineArgs.push(vscode_uri_1.URI.parse(arg.uri));
        timelineArgs.push((_a = arg.source) !== null && _a !== void 0 ? _a : '');
        return timelineArgs;
    }
    toTestMessageArgs(...args) {
        let testItem;
        let testMessage;
        for (const arg of args) {
            if (test_service_1.TestItem.is(arg)) {
                testItem = arg;
            }
            else if (Array.isArray(arg) && test_service_1.TestMessage.is(arg[0])) {
                testMessage = arg[0];
            }
        }
        if (testMessage) {
            const testItemReference = (testItem && testItem.controller) ? test_types_1.TestItemReference.create(testItem.controller.id, testItem.path) : undefined;
            const testMessageDTO = {
                message: testMessage.message,
                actual: testMessage.actual,
                expected: testMessage.expected,
                contextValue: testMessage.contextValue,
                location: testMessage.location,
                stackTrace: testMessage.stackTrace
            };
            return [test_types_1.TestMessageArg.create(testItemReference, testMessageDTO)];
        }
        return [];
    }
    toTimelineArg(arg) {
        return {
            timelineHandle: arg.handle,
            source: arg.source,
            uri: arg.uri
        };
    }
    toTreeArgs(...args) {
        const treeArgs = [];
        for (const arg of args) {
            if (common_1.TreeViewItemReference.is(arg)) {
                treeArgs.push(arg);
            }
            else if (Array.isArray(arg)) {
                treeArgs.push(arg.filter(common_1.TreeViewItemReference.is));
            }
        }
        return treeArgs;
    }
    getSelectedResources() {
        var _a, _b;
        const selection = this.selectionService.selection;
        const resourceKey = this.resourceContextKey.get();
        const resourceUri = resourceKey ? vscode_uri_1.URI.parse(resourceKey) : undefined;
        const firstMember = tree_widget_selection_1.TreeWidgetSelection.is(selection) && selection.source instanceof tree_view_widget_1.TreeViewWidget && selection[0]
            ? selection.source.toTreeViewItemReference(selection[0])
            : (_b = (_a = core_1.UriSelection.getUri(selection)) === null || _a === void 0 ? void 0 : _a['codeUri']) !== null && _b !== void 0 ? _b : resourceUri;
        const secondMember = tree_widget_selection_1.TreeWidgetSelection.is(selection)
            ? core_1.UriSelection.getUris(selection).map(uri => uri['codeUri'])
            : undefined;
        return [firstMember, secondMember];
    }
};
exports.PluginMenuCommandAdapter = PluginMenuCommandAdapter;
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_service_1.ScmService),
    tslib_1.__metadata("design:type", scm_service_1.ScmService)
], PluginMenuCommandAdapter.prototype, "scmService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.SelectionService),
    tslib_1.__metadata("design:type", core_1.SelectionService)
], PluginMenuCommandAdapter.prototype, "selectionService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(resource_context_key_1.ResourceContextKey),
    tslib_1.__metadata("design:type", resource_context_key_1.ResourceContextKey)
], PluginMenuCommandAdapter.prototype, "resourceContextKey", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], PluginMenuCommandAdapter.prototype, "init", null);
exports.PluginMenuCommandAdapter = PluginMenuCommandAdapter = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginMenuCommandAdapter);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/menus/vscode-theia-menu-mappings.js"
/*!*************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/menus/vscode-theia-menu-mappings.js ***!
  \*************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CodeEditorWidgetUtil = exports.codeToTheiaMappings = exports.implementedVSCodeContributionPoints = exports.PLUGIN_VIEW_TITLE_MENU = exports.PLUGIN_SCM_TITLE_MENU = exports.PLUGIN_EDITOR_TITLE_RUN_MENU = exports.PLUGIN_EDITOR_TITLE_MENU = void 0;
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const navigatable_1 = __webpack_require__(/*! @theia/core/lib/browser/navigatable */ "../../node_modules/@theia/core/lib/browser/navigatable.js");
const debug_stack_frames_widget_1 = __webpack_require__(/*! @theia/debug/lib/browser/view/debug-stack-frames-widget */ "../../node_modules/@theia/debug/lib/browser/view/debug-stack-frames-widget.js");
const debug_threads_widget_1 = __webpack_require__(/*! @theia/debug/lib/browser/view/debug-threads-widget */ "../../node_modules/@theia/debug/lib/browser/view/debug-threads-widget.js");
const debug_toolbar_widget_1 = __webpack_require__(/*! @theia/debug/lib/browser/view/debug-toolbar-widget */ "../../node_modules/@theia/debug/lib/browser/view/debug-toolbar-widget.js");
const debug_variables_widget_1 = __webpack_require__(/*! @theia/debug/lib/browser/view/debug-variables-widget */ "../../node_modules/@theia/debug/lib/browser/view/debug-variables-widget.js");
const browser_2 = __webpack_require__(/*! @theia/editor/lib/browser */ "../../node_modules/@theia/editor/lib/browser/index.js");
const navigator_contribution_1 = __webpack_require__(/*! @theia/navigator/lib/browser/navigator-contribution */ "../../node_modules/@theia/navigator/lib/browser/navigator-contribution.js");
const scm_tree_widget_1 = __webpack_require__(/*! @theia/scm/lib/browser/scm-tree-widget */ "../../node_modules/@theia/scm/lib/browser/scm-tree-widget.js");
const dirty_diff_widget_1 = __webpack_require__(/*! @theia/scm/lib/browser/dirty-diff/dirty-diff-widget */ "../../node_modules/@theia/scm/lib/browser/dirty-diff/dirty-diff-widget.js");
const timeline_tree_widget_1 = __webpack_require__(/*! @theia/timeline/lib/browser/timeline-tree-widget */ "../../node_modules/@theia/timeline/lib/browser/timeline-tree-widget.js");
const comment_thread_widget_1 = __webpack_require__(/*! ../comments/comment-thread-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comment-thread-widget.js");
const tree_view_widget_1 = __webpack_require__(/*! ../view/tree-view-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/tree-view-widget.js");
const webview_1 = __webpack_require__(/*! ../webview/webview */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview.js");
const editor_linenumber_contribution_1 = __webpack_require__(/*! @theia/editor/lib/browser/editor-linenumber-contribution */ "../../node_modules/@theia/editor/lib/browser/editor-linenumber-contribution.js");
const test_view_contribution_1 = __webpack_require__(/*! @theia/test/lib/browser/view/test-view-contribution */ "../../node_modules/@theia/test/lib/browser/view/test-view-contribution.js");
const test_run_view_contribution_1 = __webpack_require__(/*! @theia/test/lib/browser/view/test-run-view-contribution */ "../../node_modules/@theia/test/lib/browser/view/test-run-view-contribution.js");
const terminal_frontend_contribution_1 = __webpack_require__(/*! @theia/terminal/lib/browser/terminal-frontend-contribution */ "../../node_modules/@theia/terminal/lib/browser/terminal-frontend-contribution.js");
exports.PLUGIN_EDITOR_TITLE_MENU = ['plugin_editor/title'];
exports.PLUGIN_EDITOR_TITLE_RUN_MENU = ['plugin_editor/title/run'];
exports.PLUGIN_SCM_TITLE_MENU = ['plugin_scm/title'];
exports.PLUGIN_VIEW_TITLE_MENU = ['plugin_view/title'];
exports.implementedVSCodeContributionPoints = [
    'comments/comment/context',
    'comments/comment/title',
    'comments/commentThread/context',
    'debug/callstack/context',
    'debug/variables/context',
    'debug/toolBar',
    'editor/context',
    'editor/content',
    'editor/title',
    'editor/title/context',
    'editor/title/run',
    'editor/lineNumber/context',
    'explorer/context',
    'scm/change/title',
    'scm/resourceFolder/context',
    'scm/resourceGroup/context',
    'scm/resourceState/context',
    'scm/title',
    'timeline/item/context',
    'testing/item/context',
    'testing/message/context',
    'testing/profiles/context',
    'view/item/context',
    'view/title',
    'webview/context',
    'extension/context',
    'terminal/context',
    'terminal/title/context'
];
/** The values are menu paths to which the VSCode contribution points correspond */
exports.codeToTheiaMappings = new Map([
    ['comments/comment/context', [comment_thread_widget_1.COMMENT_CONTEXT]],
    ['comments/comment/title', [comment_thread_widget_1.COMMENT_TITLE]],
    ['comments/commentThread/context', [comment_thread_widget_1.COMMENT_THREAD_CONTEXT]],
    ['debug/callstack/context', [debug_stack_frames_widget_1.DebugStackFramesWidget.CONTEXT_MENU, debug_threads_widget_1.DebugThreadsWidget.CONTEXT_MENU]],
    ['debug/variables/context', [debug_variables_widget_1.DebugVariablesWidget.CONTEXT_MENU]],
    ['debug/toolBar', [debug_toolbar_widget_1.DebugToolBar.MENU]],
    ['editor/context', [browser_2.EDITOR_CONTEXT_MENU]],
    ['editor/content', [browser_2.EDITOR_CONTENT_MENU]],
    ['editor/title', [exports.PLUGIN_EDITOR_TITLE_MENU]],
    ['editor/title/context', [browser_1.SHELL_TABBAR_CONTEXT_MENU]],
    ['editor/title/run', [exports.PLUGIN_EDITOR_TITLE_RUN_MENU]],
    ['editor/lineNumber/context', [editor_linenumber_contribution_1.EDITOR_LINENUMBER_CONTEXT_MENU]],
    ['explorer/context', [navigator_contribution_1.NAVIGATOR_CONTEXT_MENU]],
    ['file/newFile', [browser_1.CommonMenus.FILE_NEW_CONTRIBUTIONS]],
    ['scm/change/title', [dirty_diff_widget_1.PLUGIN_SCM_CHANGE_TITLE_MENU]],
    ['scm/resourceFolder/context', [scm_tree_widget_1.ScmTreeWidget.RESOURCE_FOLDER_CONTEXT_MENU]],
    ['scm/resourceGroup/context', [scm_tree_widget_1.ScmTreeWidget.RESOURCE_GROUP_CONTEXT_MENU]],
    ['scm/resourceState/context', [scm_tree_widget_1.ScmTreeWidget.RESOURCE_CONTEXT_MENU]],
    ['scm/title', [exports.PLUGIN_SCM_TITLE_MENU]],
    ['testing/item/context', [test_view_contribution_1.TEST_VIEW_CONTEXT_MENU]],
    ['testing/message/context', [test_run_view_contribution_1.TEST_RUNS_CONTEXT_MENU]],
    ['testing/profiles/context', [test_view_contribution_1.PLUGIN_TEST_VIEW_TITLE_MENU]],
    ['timeline/item/context', [timeline_tree_widget_1.TIMELINE_ITEM_CONTEXT_MENU]],
    ['view/item/context', [tree_view_widget_1.VIEW_ITEM_CONTEXT_MENU]],
    ['view/title', [exports.PLUGIN_VIEW_TITLE_MENU]],
    ['webview/context', [webview_1.WEBVIEW_CONTEXT_MENU]],
    ['extension/context', [['extensions_context_menu', '3_contribution']]],
    ['terminal/context', [terminal_frontend_contribution_1.TerminalMenus.TERMINAL_CONTRIBUTIONS]],
    ['terminal/title/context', [terminal_frontend_contribution_1.TerminalMenus.TERMINAL_TITLE_CONTRIBUTIONS]]
]);
var CodeEditorWidgetUtil;
(function (CodeEditorWidgetUtil) {
    function is(arg) {
        return arg instanceof browser_2.EditorWidget || arg instanceof webview_1.WebviewWidget;
    }
    CodeEditorWidgetUtil.is = is;
    function getResourceUri(editor) {
        const resourceUri = navigatable_1.Navigatable.is(editor) && editor.getResourceUri();
        return resourceUri ? resourceUri['codeUri'] : undefined;
    }
    CodeEditorWidgetUtil.getResourceUri = getResourceUri;
})(CodeEditorWidgetUtil || (exports.CodeEditorWidgetUtil = CodeEditorWidgetUtil = {}));


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/message-registry-main.js"
/*!**************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/message-registry-main.js ***!
  \**************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageRegistryMainImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const modal_notification_1 = __webpack_require__(/*! ./dialogs/modal-notification */ "../../node_modules/@theia/plugin-ext/lib/main/browser/dialogs/modal-notification.js");
const basic_message_registry_main_1 = __webpack_require__(/*! ../common/basic-message-registry-main */ "../../node_modules/@theia/plugin-ext/lib/main/common/basic-message-registry-main.js");
/**
 * Message registry implementation that adds support for the model option via dialog in the browser.
 */
class MessageRegistryMainImpl extends basic_message_registry_main_1.BasicMessageRegistryMainImpl {
    constructor(container) {
        super(container);
    }
    async doShowMessage(type, message, options, actions) {
        if (options.modal) {
            const messageType = type === plugin_api_rpc_1.MainMessageType.Error ? modal_notification_1.MessageType.Error :
                type === plugin_api_rpc_1.MainMessageType.Warning ? modal_notification_1.MessageType.Warning :
                    modal_notification_1.MessageType.Info;
            const modalNotification = new modal_notification_1.ModalNotification();
            return modalNotification.showDialog(messageType, message, options, actions);
        }
        return super.doShowMessage(type, message, options, actions);
    }
}
exports.MessageRegistryMainImpl = MessageRegistryMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-documents-and-editors-main.js"
/*!**************************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-documents-and-editors-main.js ***!
  \**************************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebooksAndEditorsMain = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/notebook/lib/browser */ "../../node_modules/@theia/notebook/lib/browser/index.js");
const common_1 = __webpack_require__(/*! ../../../common */ "../../node_modules/@theia/plugin-ext/lib/common/index.js");
const notebook_dto_1 = __webpack_require__(/*! ./notebook-dto */ "../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-dto.js");
const browser_2 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const collections_1 = __webpack_require__(/*! ../../../common/collections */ "../../node_modules/@theia/plugin-ext/lib/common/collections.js");
const async_mutex_1 = __webpack_require__(/*! async-mutex */ "../../node_modules/async-mutex/lib/index.js");
class NotebookAndEditorState {
    static computeDelta(before, after) {
        if (!before) {
            return {
                addedDocuments: [...after.documents],
                removedDocuments: [],
                addedEditors: [...after.textEditors.values()],
                removedEditors: [],
                visibleEditors: [...after.visibleEditors].map(editor => editor[0])
            };
        }
        const documentDelta = (0, collections_1.diffSets)(before.documents, after.documents);
        const editorDelta = (0, collections_1.diffMaps)(before.textEditors, after.textEditors);
        const visibleEditorDelta = (0, collections_1.diffMaps)(before.visibleEditors, after.visibleEditors);
        return {
            addedDocuments: documentDelta.added,
            removedDocuments: documentDelta.removed.map(e => e.uri.toComponents()),
            addedEditors: editorDelta.added,
            removedEditors: editorDelta.removed.map(removed => removed.id),
            newActiveEditor: after.activeEditor,
            visibleEditors: visibleEditorDelta.added.length === 0 && visibleEditorDelta.removed.length === 0
                ? undefined
                : [...after.visibleEditors].map(editor => editor[0])
        };
    }
    constructor(documents, textEditors, activeEditor, visibleEditors) {
        this.documents = documents;
        this.textEditors = textEditors;
        this.activeEditor = activeEditor;
        this.visibleEditors = visibleEditors;
        //
    }
}
class NotebooksAndEditorsMain {
    constructor(rpc, container, tabsMain, notebookDocumentsMain, notebookEditorsMain) {
        this.notebookDocumentsMain = notebookDocumentsMain;
        this.notebookEditorsMain = notebookEditorsMain;
        this.disposables = new core_1.DisposableCollection();
        this.editorListeners = new Map();
        this.updateMutex = new async_mutex_1.Mutex();
        this.proxy = rpc.getProxy(common_1.MAIN_RPC_CONTEXT.NOTEBOOKS_EXT);
        this.notebookService = container.get(browser_1.NotebookService);
        this.notebookEditorService = container.get(browser_1.NotebookEditorWidgetService);
        this.WidgetManager = container.get(browser_2.WidgetManager);
        const notebookCellEditorService = container.get(browser_1.NotebookCellEditorService);
        notebookCellEditorService.onDidChangeFocusedCellEditor(editor => { var _a; return this.proxy.$acceptActiveCellEditorChange((_a = editor === null || editor === void 0 ? void 0 : editor.uri.toString()) !== null && _a !== void 0 ? _a : null); }, this, this.disposables);
        this.notebookService.onDidAddNotebookDocument(async () => this.updateState(), this, this.disposables);
        this.notebookService.onDidRemoveNotebookDocument(async () => this.updateState(), this, this.disposables);
        // this.WidgetManager.onActiveEditorChanged(() => this.updateState(), this, this.disposables);
        this.notebookEditorService.onDidAddNotebookEditor(async (editor) => this.handleEditorAdd(editor), this, this.disposables);
        this.notebookEditorService.onDidRemoveNotebookEditor(async (editor) => this.handleEditorRemove(editor), this, this.disposables);
        this.notebookEditorService.onDidChangeCurrentEditor(async (editor) => {
            if (editor) {
                await tabsMain.waitForWidget(editor);
            }
            this.updateState(editor);
        }, this, this.disposables);
    }
    dispose() {
        this.notebookDocumentsMain.dispose();
        this.notebookEditorsMain.dispose();
        this.disposables.dispose();
        this.editorListeners.forEach(listeners => listeners.forEach(listener => listener.dispose()));
    }
    async handleEditorAdd(editor) {
        const listeners = this.editorListeners.get(editor.id);
        const disposable = editor.onDidChangeModel(() => this.updateState());
        if (listeners) {
            listeners.push(disposable);
        }
        else {
            this.editorListeners.set(editor.id, [disposable]);
        }
        await this.updateState();
    }
    handleEditorRemove(editor) {
        const listeners = this.editorListeners.get(editor.id);
        listeners === null || listeners === void 0 ? void 0 : listeners.forEach(listener => listener.dispose());
        this.editorListeners.delete(editor.id);
        this.updateState();
    }
    async updateState(focusedEditor) {
        await this.updateMutex.runExclusive(async () => this.doUpdateState(focusedEditor));
    }
    async doUpdateState(focusedEditor) {
        const editors = new Map();
        const visibleEditorsMap = new Map();
        for (const editor of this.notebookEditorService.getNotebookEditors()) {
            editors.set(editor.id, editor);
        }
        const activeNotebookEditor = this.notebookEditorService.focusedEditor;
        let activeEditor = null;
        if (activeNotebookEditor) {
            activeEditor = activeNotebookEditor.id;
        }
        else if (focusedEditor === null || focusedEditor === void 0 ? void 0 : focusedEditor.model) {
            activeEditor = focusedEditor.id;
        }
        if (activeEditor && !editors.has(activeEditor)) {
            activeEditor = null;
        }
        const notebookEditors = this.WidgetManager.getWidgets(browser_1.NotebookEditorWidget.ID);
        for (const notebookEditor of notebookEditors) {
            if (editors.has(notebookEditor.id) && notebookEditor.isVisible) {
                visibleEditorsMap.set(notebookEditor.id, notebookEditor);
            }
        }
        const newState = new NotebookAndEditorState(new Set(this.notebookService.listNotebookDocuments()), editors, activeEditor, visibleEditorsMap);
        await this.onDelta(NotebookAndEditorState.computeDelta(this.currentState, newState));
        this.currentState = newState;
    }
    async onDelta(delta) {
        if (NotebooksAndEditorsMain.isDeltaEmpty(delta)) {
            return;
        }
        const dto = {
            removedDocuments: delta.removedDocuments,
            removedEditors: delta.removedEditors,
            newActiveEditor: delta.newActiveEditor,
            visibleEditors: delta.visibleEditors,
            addedDocuments: delta.addedDocuments.map(NotebooksAndEditorsMain.asModelAddData),
            addedEditors: delta.addedEditors.map(NotebooksAndEditorsMain.asEditorAddData),
        };
        // Handle internally first
        // In case the plugin wants to perform documents edits immediately
        // we want to make sure that all events have already been setup
        this.notebookEditorsMain.handleEditorsRemoved(delta.removedEditors);
        this.notebookDocumentsMain.handleNotebooksRemoved(delta.removedDocuments);
        this.notebookDocumentsMain.handleNotebooksAdded(delta.addedDocuments);
        this.notebookEditorsMain.handleEditorsAdded(delta.addedEditors);
        // Send to plugin last
        await this.proxy.$acceptDocumentsAndEditorsDelta(dto);
    }
    static isDeltaEmpty(delta) {
        var _a, _b, _c, _d, _e;
        if ((_a = delta.addedDocuments) === null || _a === void 0 ? void 0 : _a.length) {
            return false;
        }
        if ((_b = delta.removedDocuments) === null || _b === void 0 ? void 0 : _b.length) {
            return false;
        }
        if ((_c = delta.addedEditors) === null || _c === void 0 ? void 0 : _c.length) {
            return false;
        }
        if ((_d = delta.removedEditors) === null || _d === void 0 ? void 0 : _d.length) {
            return false;
        }
        if ((_e = delta.visibleEditors) === null || _e === void 0 ? void 0 : _e.length) {
            return false;
        }
        if (delta.newActiveEditor !== undefined) {
            return false;
        }
        return true;
    }
    static asModelAddData(e) {
        return {
            viewType: e.viewType,
            uri: e.uri.toComponents(),
            metadata: e.metadata,
            versionId: 1, // TODO implement versionID support
            cells: e.cells.map(notebook_dto_1.NotebookDto.toNotebookCellDto)
        };
    }
    static asEditorAddData(notebookEditor) {
        const uri = notebookEditor.getResourceUri();
        if (!uri) {
            throw new Error('Notebook editor without resource URI');
        }
        return {
            id: notebookEditor.id,
            documentUri: uri.toComponents(),
            selections: [{ start: 0, end: 0 }],
            visibleRanges: []
        };
    }
}
exports.NotebooksAndEditorsMain = NotebooksAndEditorsMain;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-documents-main.js"
/*!**************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-documents-main.js ***!
  \**************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookDocumentsMainImpl = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../../node_modules/@theia/core/lib/common/uri.js");
const browser_1 = __webpack_require__(/*! @theia/notebook/lib/browser */ "../../node_modules/@theia/notebook/lib/browser/index.js");
const common_1 = __webpack_require__(/*! @theia/notebook/lib/common */ "../../node_modules/@theia/notebook/lib/common/index.js");
const notebook_monaco_text_model_service_1 = __webpack_require__(/*! @theia/notebook/lib/browser/service/notebook-monaco-text-model-service */ "../../node_modules/@theia/notebook/lib/browser/service/notebook-monaco-text-model-service.js");
const common_2 = __webpack_require__(/*! ../../../common */ "../../node_modules/@theia/plugin-ext/lib/common/index.js");
const notebook_dto_1 = __webpack_require__(/*! ./notebook-dto */ "../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-dto.js");
const notebook_open_handler_1 = __webpack_require__(/*! @theia/notebook/lib/browser/notebook-open-handler */ "../../node_modules/@theia/notebook/lib/browser/notebook-open-handler.js");
class NotebookDocumentsMainImpl {
    constructor(rpc, container) {
        this.disposables = new core_1.DisposableCollection();
        this.documentEventListenersMapping = new Map();
        this.proxy = rpc.getProxy(common_2.MAIN_RPC_CONTEXT.NOTEBOOK_DOCUMENTS_EXT);
        this.notebookModelResolverService = container.get(browser_1.NotebookModelResolverService);
        this.notebookOpenHandler = container.get(notebook_open_handler_1.NotebookOpenHandler);
        // forward dirty and save events
        this.disposables.push(this.notebookModelResolverService.onDidChangeDirty(model => this.proxy.$acceptDirtyStateChanged(model.uri.toComponents(), model.isDirty())));
        this.disposables.push(this.notebookModelResolverService.onDidSaveNotebook(e => this.proxy.$acceptModelSaved(e)));
        this.notebookMonacoTextModelService = container.get(notebook_monaco_text_model_service_1.NotebookMonacoTextModelService);
    }
    get onDidAddNotebookCellModel() {
        return this.notebookMonacoTextModelService.onDidCreateNotebookCellModel;
    }
    dispose() {
        this.disposables.dispose();
        // this.modelReferenceCollection.dispose();
        this.documentEventListenersMapping.forEach(value => value.dispose());
    }
    handleNotebooksAdded(notebooks) {
        for (const notebook of notebooks) {
            const listener = notebook.onDidChangeContent(events => {
                const eventDto = {
                    versionId: 1, // TODO implement version ID support
                    rawEvents: []
                };
                for (const e of events) {
                    switch (e.kind) {
                        case common_1.NotebookCellsChangeType.ModelChange:
                            eventDto.rawEvents.push({
                                kind: e.kind,
                                changes: e.changes.map(diff => ({ ...diff, newItems: diff.newItems.map(notebook_dto_1.NotebookDto.toNotebookCellDto) }))
                            });
                            break;
                        case common_1.NotebookCellsChangeType.Move:
                            eventDto.rawEvents.push({
                                kind: e.kind,
                                index: e.index,
                                length: e.length,
                                newIdx: e.newIdx,
                            });
                            break;
                        case common_1.NotebookCellsChangeType.Output:
                            eventDto.rawEvents.push({
                                kind: e.kind,
                                index: e.index,
                                outputs: e.outputs.map(notebook_dto_1.NotebookDto.toNotebookOutputDto)
                            });
                            break;
                        case common_1.NotebookCellsChangeType.OutputItem:
                            eventDto.rawEvents.push({
                                kind: e.kind,
                                index: e.index,
                                outputId: e.outputId,
                                outputItems: e.outputItems.map(notebook_dto_1.NotebookDto.toNotebookOutputItemDto),
                                append: e.append
                            });
                            break;
                        case common_1.NotebookCellsChangeType.ChangeCellLanguage:
                        case common_1.NotebookCellsChangeType.ChangeCellContent:
                        case common_1.NotebookCellsChangeType.ChangeCellMetadata:
                        case common_1.NotebookCellsChangeType.ChangeCellInternalMetadata:
                            eventDto.rawEvents.push(e);
                            break;
                        case common_1.NotebookCellsChangeType.ChangeDocumentMetadata:
                            eventDto.rawEvents.push({
                                kind: e.kind,
                                metadata: e.metadata
                            });
                            break;
                    }
                }
                const hasDocumentMetadataChangeEvent = events.find(e => e.kind === common_1.NotebookCellsChangeType.ChangeDocumentMetadata);
                // using the model resolver service to know if the model is dirty or not.
                // assuming this is the first listener it can mean that at first the model
                // is marked as dirty and that another event is fired
                this.proxy.$acceptModelChanged(notebook.uri.toComponents(), eventDto, notebook.isDirty(), hasDocumentMetadataChangeEvent ? notebook.metadata : undefined);
            });
            this.documentEventListenersMapping.set(notebook.uri.toString(), new core_1.DisposableCollection(listener));
        }
    }
    handleNotebooksRemoved(uris) {
        var _a;
        for (const uri of uris) {
            (_a = this.documentEventListenersMapping.get(uri.toString())) === null || _a === void 0 ? void 0 : _a.dispose();
            this.documentEventListenersMapping.delete(uri.toString());
        }
    }
    async $tryCreateNotebook(options) {
        const ref = await this.notebookModelResolverService.resolveUntitledResource({ untitledResource: undefined }, options.viewType);
        // untitled notebooks are disposed when they get saved. we should not hold a reference
        // to such a disposed notebook and therefore dispose the reference as well
        // ref.onWillDispose(() => {
        //     ref.dispose();
        // });
        const uriComponents = ref.uri.toComponents();
        // untitled notebooks are dirty by default
        this.proxy.$acceptDirtyStateChanged(uriComponents, true);
        // apply content changes...
        if (options.content) {
            const data = notebook_dto_1.NotebookDto.fromNotebookDataDto(options.content);
            ref.setData(data);
            // Create and send a change events
            const rawEvents = [];
            if (options.content.cells && options.content.cells.length > 0) {
                rawEvents.push({
                    kind: common_1.NotebookCellsChangeType.ModelChange,
                    changes: [{ start: 0, startHandle: 0, deleteCount: 0, newItems: ref.cells.map(notebook_dto_1.NotebookDto.toNotebookCellDto) }]
                });
            }
            if (options.content.metadata) {
                rawEvents.push({
                    kind: common_1.NotebookCellsChangeType.ChangeDocumentMetadata,
                    metadata: options.content.metadata
                });
            }
            if (rawEvents.length > 0) {
                this.proxy.$acceptModelChanged(uriComponents, { versionId: 1, rawEvents }, true);
            }
        }
        return uriComponents;
    }
    async $tryOpenNotebook(uriComponents) {
        const uri = uri_1.URI.fromComponents(uriComponents);
        await this.notebookModelResolverService.resolve(uri);
        return uri.toComponents();
    }
    async $trySaveNotebook(uriComponents) {
        const uri = uri_1.URI.fromComponents(uriComponents);
        const ref = await this.notebookModelResolverService.resolve(uri);
        await ref.save();
        ref.dispose();
        return true;
    }
}
exports.NotebookDocumentsMainImpl = NotebookDocumentsMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-dto.js"
/*!***************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-dto.js ***!
  \***************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookDto = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const common_1 = __webpack_require__(/*! @theia/notebook/lib/common */ "../../node_modules/@theia/notebook/lib/common/index.js");
var NotebookDto;
(function (NotebookDto) {
    function toNotebookOutputItemDto(item) {
        return {
            mime: item.mime,
            valueBytes: item.data
        };
    }
    NotebookDto.toNotebookOutputItemDto = toNotebookOutputItemDto;
    function toNotebookOutputDto(output) {
        return {
            outputId: output.outputId,
            metadata: output.metadata,
            items: output.outputs.map(toNotebookOutputItemDto)
        };
    }
    NotebookDto.toNotebookOutputDto = toNotebookOutputDto;
    function toNotebookCellDataDto(cell) {
        return {
            cellKind: cell.cellKind,
            language: cell.language,
            source: cell.source,
            internalMetadata: cell.internalMetadata,
            metadata: cell.metadata,
            outputs: cell.outputs.map(toNotebookOutputDto)
        };
    }
    NotebookDto.toNotebookCellDataDto = toNotebookCellDataDto;
    function toNotebookDataDto(data) {
        return {
            metadata: data.metadata,
            cells: data.cells.map(toNotebookCellDataDto)
        };
    }
    NotebookDto.toNotebookDataDto = toNotebookDataDto;
    function fromNotebookOutputItemDto(item) {
        return {
            mime: item.mime,
            data: item.valueBytes
        };
    }
    NotebookDto.fromNotebookOutputItemDto = fromNotebookOutputItemDto;
    function fromNotebookOutputDto(output) {
        return {
            outputId: output.outputId,
            metadata: output.metadata,
            outputs: output.items.map(fromNotebookOutputItemDto)
        };
    }
    NotebookDto.fromNotebookOutputDto = fromNotebookOutputDto;
    function fromNotebookCellDataDto(cell) {
        return {
            cellKind: cell.cellKind,
            language: cell.language,
            source: cell.source,
            outputs: cell.outputs.map(fromNotebookOutputDto),
            metadata: cell.metadata,
            internalMetadata: cell.internalMetadata
        };
    }
    NotebookDto.fromNotebookCellDataDto = fromNotebookCellDataDto;
    function fromNotebookDataDto(data) {
        return {
            metadata: data.metadata,
            cells: data.cells.map(fromNotebookCellDataDto)
        };
    }
    NotebookDto.fromNotebookDataDto = fromNotebookDataDto;
    function toNotebookCellDto(cell) {
        const eol = core_1.OS.backend.EOL;
        return {
            handle: cell.handle,
            uri: cell.uri.toComponents(),
            source: cell.text.split(/\r?\n/g),
            eol,
            language: cell.language,
            cellKind: cell.cellKind,
            outputs: cell.outputs.map(toNotebookOutputDto),
            metadata: cell.metadata,
            internalMetadata: cell.internalMetadata,
        };
    }
    NotebookDto.toNotebookCellDto = toNotebookCellDto;
    function fromCellExecuteUpdateDto(data) {
        if (data.editType === common_1.CellExecutionUpdateType.Output) {
            return {
                editType: data.editType,
                cellHandle: data.cellHandle,
                append: data.append,
                outputs: data.outputs.map(fromNotebookOutputDto)
            };
        }
        else if (data.editType === common_1.CellExecutionUpdateType.OutputItems) {
            return {
                editType: data.editType,
                outputId: data.outputId,
                append: data.append,
                items: data.items.map(fromNotebookOutputItemDto)
            };
        }
        else {
            return data;
        }
    }
    NotebookDto.fromCellExecuteUpdateDto = fromCellExecuteUpdateDto;
    function fromCellExecuteCompleteDto(data) {
        return data;
    }
    NotebookDto.fromCellExecuteCompleteDto = fromCellExecuteCompleteDto;
})(NotebookDto || (exports.NotebookDto = NotebookDto = {}));


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-editors-main.js"
/*!************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-editors-main.js ***!
  \************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookEditorsMainImpl = void 0;
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../../node_modules/@theia/core/lib/common/uri.js");
const browser_1 = __webpack_require__(/*! @theia/notebook/lib/browser */ "../../node_modules/@theia/notebook/lib/browser/index.js");
const common_1 = __webpack_require__(/*! ../../../common */ "../../node_modules/@theia/plugin-ext/lib/common/index.js");
const notebook_open_handler_1 = __webpack_require__(/*! @theia/notebook/lib/browser/notebook-open-handler */ "../../node_modules/@theia/notebook/lib/browser/notebook-open-handler.js");
class NotebookEditorsMainImpl {
    constructor(rpc, container) {
        this.mainThreadEditors = new Map();
        this.proxy = rpc.getProxy(common_1.MAIN_RPC_CONTEXT.NOTEBOOK_EDITORS_EXT);
        this.notebookService = container.get(browser_1.NotebookService);
        this.notebookOpenHandler = container.get(notebook_open_handler_1.NotebookOpenHandler);
    }
    async $tryShowNotebookDocument(uriComponents, viewType, options) {
        const editor = await this.notebookOpenHandler.open(uri_1.URI.fromComponents(uriComponents), {
            notebookType: viewType
        });
        await editor.ready;
        return editor.id;
    }
    $tryRevealRange(id, range, revealType) {
        throw new Error('Method not implemented.');
    }
    $trySetSelections(id, range) {
        if (!this.mainThreadEditors.has(id)) {
            throw new Error('Editor not found');
        }
        const editor = this.mainThreadEditors.get(id);
        editor === null || editor === void 0 ? void 0 : editor.viewModel.setSelectedCell(editor.model.cells[range[0].start]);
    }
    async handleEditorsAdded(editors) {
        for (const editor of editors) {
            this.mainThreadEditors.set(editor.id, editor);
            const model = await editor.ready;
            editor.viewModel.onDidChangeSelectedCell(e => {
                const newCellIndex = e.cell ? model.cells.indexOf(e.cell) : -1;
                this.proxy.$acceptEditorPropertiesChanged(editor.id, {
                    selections: {
                        selections: newCellIndex >= 0 ? [{ start: newCellIndex, end: newCellIndex }] : []
                    }
                });
            });
        }
    }
    handleEditorsRemoved(editorIds) {
        var _a;
        for (const id of editorIds) {
            (_a = this.mainThreadEditors.get(id)) === null || _a === void 0 ? void 0 : _a.dispose();
            this.mainThreadEditors.delete(id);
        }
    }
    dispose() {
    }
}
exports.NotebookEditorsMainImpl = NotebookEditorsMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-kernels-main.js"
/*!************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-kernels-main.js ***!
  \************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookKernelsMainImpl = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const language_service_1 = __webpack_require__(/*! @theia/core/lib/browser/language-service */ "../../node_modules/@theia/core/lib/browser/language-service.js");
const common_1 = __webpack_require__(/*! ../../../common */ "../../node_modules/@theia/plugin-ext/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/notebook/lib/browser */ "../../node_modules/@theia/notebook/lib/browser/index.js");
const notebook_dto_1 = __webpack_require__(/*! ./notebook-dto */ "../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-dto.js");
class NotebookKernel {
    get preloadUris() {
        return this.preloads.map(p => p.uri);
    }
    get preloadProvides() {
        return this.preloads.map(p => p.provides).flat();
    }
    constructor(handle, data, languageService) {
        var _a, _b, _c, _d;
        this.handle = handle;
        this.languageService = languageService;
        this.onDidChangeEmitter = new core_1.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.id = data.id;
        this.viewType = data.notebookType;
        this.extensionId = data.extensionId;
        this.implementsInterrupt = (_a = data.supportsInterrupt) !== null && _a !== void 0 ? _a : false;
        this.label = data.label;
        this.description = data.description;
        this.detail = data.detail;
        this.supportedLanguages = (data.supportedLanguages && data.supportedLanguages.length > 0) ? data.supportedLanguages : languageService.languages.map(lang => lang.id);
        this.implementsExecutionOrder = (_b = data.supportsExecutionOrder) !== null && _b !== void 0 ? _b : false;
        this.localResourceRoot = core_1.URI.fromComponents(data.extensionLocation);
        this.preloads = (_d = (_c = data.preloads) === null || _c === void 0 ? void 0 : _c.map(u => ({ uri: core_1.URI.fromComponents(u.uri), provides: u.provides }))) !== null && _d !== void 0 ? _d : [];
    }
    update(data) {
        const event = Object.create(null);
        if (data.label !== undefined) {
            this.label = data.label;
            event.label = true;
        }
        if (data.description !== undefined) {
            this.description = data.description;
            event.description = true;
        }
        if (data.detail !== undefined) {
            this.detail = data.detail;
            event.detail = true;
        }
        if (data.supportedLanguages !== undefined) {
            this.supportedLanguages = (data.supportedLanguages && data.supportedLanguages.length > 0) ?
                data.supportedLanguages :
                this.languageService.languages.map(lang => lang.id);
            event.supportedLanguages = true;
        }
        if (data.supportsExecutionOrder !== undefined) {
            this.implementsExecutionOrder = data.supportsExecutionOrder;
            event.hasExecutionOrder = true;
        }
        if (data.supportsInterrupt !== undefined) {
            this.implementsInterrupt = data.supportsInterrupt;
            event.hasInterruptHandler = true;
        }
        this.onDidChangeEmitter.fire(event);
    }
}
class NotebookKernelsMainImpl {
    constructor(rpc, container) {
        this.kernels = new Map();
        this.kernelDetectionTasks = new Map();
        this.kernelSourceActionProviders = new Map();
        this.kernelSourceActionProvidersEventRegistrations = new Map();
        this.executions = new Map();
        this.proxy = rpc.getProxy(common_1.MAIN_RPC_CONTEXT.NOTEBOOK_KERNELS_EXT);
        this.notebookKernelService = container.get(browser_1.NotebookKernelService);
        this.notebookExecutionStateService = container.get(browser_1.NotebookExecutionStateService);
        this.notebookService = container.get(browser_1.NotebookService);
        this.languageService = container.get(language_service_1.LanguageService);
        this.notebookEditorWidgetService = container.get(browser_1.NotebookEditorWidgetService);
        this.notebookEditorWidgetService.onDidAddNotebookEditor(editor => {
            editor.onDidReceiveKernelMessage(async (message) => {
                const kernel = this.notebookKernelService.getSelectedOrSuggestedKernel(editor.model);
                if (kernel) {
                    this.proxy.$acceptKernelMessageFromRenderer(kernel.handle, editor.id, message);
                }
            });
        });
        this.notebookKernelService.onDidChangeSelectedKernel(e => {
            var _a, _b;
            if (e.newKernel) {
                const newKernelHandle = (_a = Array.from(this.kernels.entries()).find(([_, [kernel]]) => kernel.id === e.newKernel)) === null || _a === void 0 ? void 0 : _a[0];
                if (newKernelHandle !== undefined) {
                    this.proxy.$acceptNotebookAssociation(newKernelHandle, e.notebook.toComponents(), true);
                }
            }
            else {
                const oldKernelHandle = (_b = Array.from(this.kernels.entries()).find(([_, [kernel]]) => kernel.id === e.oldKernel)) === null || _b === void 0 ? void 0 : _b[0];
                if (oldKernelHandle !== undefined) {
                    this.proxy.$acceptNotebookAssociation(oldKernelHandle, e.notebook.toComponents(), false);
                }
            }
        });
    }
    async $postMessage(handle, editorId, message) {
        const tuple = this.kernels.get(handle);
        if (!tuple) {
            throw new Error('kernel already disposed');
        }
        const [kernel] = tuple;
        let didSend = false;
        for (const editor of this.notebookEditorWidgetService.getNotebookEditors()) {
            if (!editor.model) {
                continue;
            }
            if (this.notebookKernelService.getMatchingKernel(editor.model).selected !== kernel) {
                // different kernel
                continue;
            }
            if (editorId === undefined) {
                // all editors
                editor.postKernelMessage(message);
                didSend = true;
            }
            else if (editor.id === editorId) {
                // selected editors
                editor.postKernelMessage(message);
                didSend = true;
                break;
            }
        }
        return didSend;
    }
    async $addKernel(handle, data) {
        const that = this;
        const kernel = new class extends NotebookKernel {
            async executeNotebookCellsRequest(uri, handles) {
                await that.proxy.$executeCells(handle, uri.toComponents(), handles);
            }
            async cancelNotebookCellExecution(uri, handles) {
                await that.proxy.$cancelCells(handle, uri.toComponents(), handles);
            }
        }(handle, data, this.languageService);
        // this is for when a kernel is bound to a notebook while being registered
        const autobindListener = this.notebookKernelService.onDidChangeSelectedKernel(e => {
            if (e.newKernel === kernel.id) {
                this.proxy.$acceptNotebookAssociation(handle, e.notebook.toComponents(), true);
            }
        });
        const registration = this.notebookKernelService.registerKernel(kernel);
        this.kernels.set(handle, [kernel, registration]);
        autobindListener.dispose();
    }
    $updateKernel(handle, data) {
        const tuple = this.kernels.get(handle);
        if (tuple) {
            tuple[0].update(data);
        }
    }
    $removeKernel(handle) {
        const tuple = this.kernels.get(handle);
        if (tuple) {
            tuple[1].dispose();
            this.kernels.delete(handle);
        }
    }
    $updateNotebookPriority(handle, uri, value) {
        throw new Error('Method not implemented.');
    }
    $createExecution(handle, controllerId, uriComponents, cellHandle) {
        var _a;
        const uri = core_1.URI.fromComponents(uriComponents);
        const notebook = this.notebookService.getNotebookEditorModel(uri);
        if (!notebook) {
            throw new Error(`Notebook not found: ${uri.toString()}`);
        }
        const kernel = this.notebookKernelService.getMatchingKernel(notebook);
        if (!kernel.selected || kernel.selected.id !== controllerId) {
            throw new Error(`Kernel is not selected: ${(_a = kernel.selected) === null || _a === void 0 ? void 0 : _a.id} !== ${controllerId}`);
        }
        const execution = this.notebookExecutionStateService.getOrCreateCellExecution(uri, cellHandle);
        execution.confirm();
        this.executions.set(handle, execution);
    }
    $updateExecution(handle, updates) {
        const execution = this.executions.get(handle);
        execution === null || execution === void 0 ? void 0 : execution.update(updates.map(notebook_dto_1.NotebookDto.fromCellExecuteUpdateDto));
    }
    $completeExecution(handle, data) {
        try {
            const execution = this.executions.get(handle);
            execution === null || execution === void 0 ? void 0 : execution.complete(notebook_dto_1.NotebookDto.fromCellExecuteCompleteDto(data));
        }
        finally {
            this.executions.delete(handle);
        }
    }
    // TODO implement notebook execution (special api for executing full notebook instead of just cells)
    $createNotebookExecution(handle, controllerId, uri) {
        throw new Error('Method not implemented.');
    }
    $beginNotebookExecution(handle) {
        throw new Error('Method not implemented.');
    }
    $completeNotebookExecution(handle) {
        throw new Error('Method not implemented.');
    }
    async $addKernelDetectionTask(handle, notebookType) {
        const registration = this.notebookKernelService.registerNotebookKernelDetectionTask(notebookType);
        this.kernelDetectionTasks.set(handle, [notebookType, registration]);
    }
    $removeKernelDetectionTask(handle) {
        const tuple = this.kernelDetectionTasks.get(handle);
        if (tuple) {
            tuple[1].dispose();
            this.kernelDetectionTasks.delete(handle);
        }
    }
    async $addKernelSourceActionProvider(handle, eventHandle, notebookType) {
        const kernelSourceActionProvider = {
            viewType: notebookType,
            provideKernelSourceActions: async () => {
                const actions = await this.proxy.$provideKernelSourceActions(handle, core_1.CancellationToken.None);
                return actions.map(action => ({
                    label: action.label,
                    command: action.command,
                    description: action.description,
                    detail: action.detail,
                    documentation: action.documentation,
                }));
            }
        };
        if (typeof eventHandle === 'number') {
            const emitter = new core_1.Emitter();
            this.kernelSourceActionProvidersEventRegistrations.set(eventHandle, emitter);
            kernelSourceActionProvider.onDidChangeSourceActions = emitter.event;
        }
        const registration = this.notebookKernelService.registerKernelSourceActionProvider(notebookType, kernelSourceActionProvider);
        this.kernelSourceActionProviders.set(handle, [kernelSourceActionProvider, registration]);
    }
    $removeKernelSourceActionProvider(handle, eventHandle) {
        const tuple = this.kernelSourceActionProviders.get(handle);
        if (tuple) {
            tuple[1].dispose();
            this.kernelSourceActionProviders.delete(handle);
        }
        if (typeof eventHandle === 'number') {
            this.kernelSourceActionProvidersEventRegistrations.delete(eventHandle);
        }
    }
    $emitNotebookKernelSourceActionsChangeEvent(eventHandle) {
    }
    dispose() {
        this.kernels.forEach(kernel => kernel[1].dispose());
    }
}
exports.NotebookKernelsMainImpl = NotebookKernelsMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-renderers-main.js"
/*!**************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-renderers-main.js ***!
  \**************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookRenderersMainImpl = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/notebook/lib/browser */ "../../node_modules/@theia/notebook/lib/browser/index.js");
const common_1 = __webpack_require__(/*! ../../../common */ "../../node_modules/@theia/plugin-ext/lib/common/index.js");
class NotebookRenderersMainImpl {
    constructor(rpc, container) {
        this.disposables = new core_1.DisposableCollection();
        this.proxy = rpc.getProxy(common_1.MAIN_RPC_CONTEXT.NOTEBOOK_RENDERERS_EXT);
        this.rendererMessagingService = container.get(browser_1.NotebookRendererMessagingService);
        this.rendererMessagingService.onPostMessage(e => {
            this.proxy.$postRendererMessage(e.editorId, e.rendererId, e.message);
        });
    }
    $postMessage(editorId, rendererId, message) {
        return this.rendererMessagingService.receiveMessage(editorId, rendererId, message);
    }
    dispose() {
        this.disposables.dispose();
    }
}
exports.NotebookRenderersMainImpl = NotebookRenderersMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebooks-main.js"
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebooks-main.js ***!
  \*****************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toNotebookWorspaceEdit = exports.NotebooksMainImpl = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const common_1 = __webpack_require__(/*! @theia/notebook/lib/common */ "../../node_modules/@theia/notebook/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/notebook/lib/browser */ "../../node_modules/@theia/notebook/lib/browser/index.js");
const common_2 = __webpack_require__(/*! ../../../common */ "../../node_modules/@theia/plugin-ext/lib/common/index.js");
const notebook_dto_1 = __webpack_require__(/*! ./notebook-dto */ "../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebook-dto.js");
const hosted_plugin_1 = __webpack_require__(/*! ../../../hosted/browser/hosted-plugin */ "../../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin.js");
const notebook_model_1 = __webpack_require__(/*! @theia/notebook/lib/browser/view-model/notebook-model */ "../../node_modules/@theia/notebook/lib/browser/view-model/notebook-model.js");
const notebook_cell_model_1 = __webpack_require__(/*! @theia/notebook/lib/browser/view-model/notebook-cell-model */ "../../node_modules/@theia/notebook/lib/browser/view-model/notebook-cell-model.js");
const notebook_cell_status_bar_service_1 = __webpack_require__(/*! @theia/notebook/lib/browser/service/notebook-cell-status-bar-service */ "../../node_modules/@theia/notebook/lib/browser/service/notebook-cell-status-bar-service.js");
class NotebooksMainImpl {
    constructor(rpc, container, commands) {
        this.disposables = new core_1.DisposableCollection();
        this.notebookSerializer = new Map();
        this.notebookCellStatusBarRegistrations = new Map();
        this.notebookService = container.get(browser_1.NotebookService);
        this.cellStatusBarService = container.get(notebook_cell_status_bar_service_1.NotebookCellStatusBarService);
        const plugins = container.get(hosted_plugin_1.HostedPluginSupport);
        this.proxy = rpc.getProxy(common_2.MAIN_RPC_CONTEXT.NOTEBOOKS_EXT);
        this.notebookService.onWillUseNotebookSerializer(event => plugins.activateByNotebookSerializer(event));
        this.notebookService.markReady();
        commands.registerArgumentProcessor({
            processArgument: arg => {
                if (arg instanceof notebook_model_1.NotebookModel) {
                    return common_1.NotebookModelResource.create(arg.uri);
                }
                else if (arg instanceof notebook_cell_model_1.NotebookCellModel) {
                    return common_1.NotebookCellModelResource.create(arg.uri);
                }
                return arg;
            }
        });
    }
    dispose() {
        this.disposables.dispose();
        for (const disposable of this.notebookSerializer.values()) {
            disposable.dispose();
        }
    }
    $registerNotebookSerializer(handle, viewType, options) {
        const disposables = new core_1.DisposableCollection();
        disposables.push(this.notebookService.registerNotebookSerializer(viewType, {
            options,
            toNotebook: async (data) => {
                const dto = await this.proxy.$dataToNotebook(handle, data, core_1.CancellationToken.None);
                return notebook_dto_1.NotebookDto.fromNotebookDataDto(dto);
            },
            fromNotebook: (data) => this.proxy.$notebookToData(handle, notebook_dto_1.NotebookDto.toNotebookDataDto(data), core_1.CancellationToken.None)
        }));
        this.notebookSerializer.set(handle, disposables);
    }
    $unregisterNotebookSerializer(handle) {
        var _a;
        (_a = this.notebookSerializer.get(handle)) === null || _a === void 0 ? void 0 : _a.dispose();
        this.notebookSerializer.delete(handle);
    }
    $emitCellStatusBarEvent(eventHandle) {
        const emitter = this.notebookCellStatusBarRegistrations.get(eventHandle);
        if (emitter instanceof core_1.Emitter) {
            emitter.fire(undefined);
        }
    }
    async $registerNotebookCellStatusBarItemProvider(handle, eventHandle, viewType) {
        const that = this;
        const provider = {
            async provideCellStatusBarItems(notebookUri, index, token) {
                var _a;
                const result = await that.proxy.$provideNotebookCellStatusBarItems(handle, notebookUri.toComponents(), index, token);
                return {
                    items: (_a = result === null || result === void 0 ? void 0 : result.items) !== null && _a !== void 0 ? _a : [],
                    dispose() {
                        if (result) {
                            that.proxy.$releaseNotebookCellStatusBarItems(result.cacheId);
                        }
                    }
                };
            },
            viewType
        };
        if (typeof eventHandle === 'number') {
            const emitter = new core_1.Emitter();
            this.notebookCellStatusBarRegistrations.set(eventHandle, emitter);
            provider.onDidChangeStatusBarItems = emitter.event;
        }
        const disposable = this.cellStatusBarService.registerCellStatusBarItemProvider(provider);
        this.notebookCellStatusBarRegistrations.set(handle, disposable);
    }
    async $unregisterNotebookCellStatusBarItemProvider(handle, eventHandle) {
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const unregisterThing = (statusBarHandle) => {
            var _a;
            const entry = this.notebookCellStatusBarRegistrations.get(statusBarHandle);
            if (entry) {
                (_a = this.notebookCellStatusBarRegistrations.get(statusBarHandle)) === null || _a === void 0 ? void 0 : _a.dispose();
                this.notebookCellStatusBarRegistrations.delete(statusBarHandle);
            }
        };
        unregisterThing(handle);
        if (typeof eventHandle === 'number') {
            unregisterThing(eventHandle);
        }
    }
}
exports.NotebooksMainImpl = NotebooksMainImpl;
function toNotebookWorspaceEdit(dto) {
    return {
        edits: dto.edits.map((edit) => ({
            resource: core_1.URI.fromComponents(edit.resource),
            edit: edit.cellEdit.editType === 1 /* CellEditType.Replace */ ? {
                ...edit.cellEdit,
                cells: edit.cellEdit.cells.map(cell => notebook_dto_1.NotebookDto.fromNotebookCellDataDto(cell))
            } : edit.cellEdit
        }))
    };
}
exports.toNotebookWorspaceEdit = toNotebookWorspaceEdit;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/renderers/cell-output-webview.js"
/*!********************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/renderers/cell-output-webview.js ***!
  \********************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellOutputWebviewImpl = exports.DEFAULT_NOTEBOOK_OUTPUT_CSS = exports.createCellOutputWebviewContainer = exports.AdditionalNotebookCellOutputCss = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../../node_modules/@theia/core/shared/react/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const uuid_1 = __webpack_require__(/*! @theia/core/lib/common/uuid */ "../../node_modules/@theia/core/lib/common/uuid.js");
const browser_1 = __webpack_require__(/*! @theia/notebook/lib/browser */ "../../node_modules/@theia/notebook/lib/browser/index.js");
const webview_1 = __webpack_require__(/*! ../../webview/webview */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview.js");
const browser_2 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const output_webview_internal_1 = __webpack_require__(/*! ./output-webview-internal */ "../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/renderers/output-webview-internal.js");
const browser_3 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../../node_modules/@theia/workspace/lib/browser/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const notebook_options_1 = __webpack_require__(/*! @theia/notebook/lib/browser/service/notebook-options */ "../../node_modules/@theia/notebook/lib/browser/service/notebook-options.js");
const common_1 = __webpack_require__(/*! @theia/notebook/lib/common */ "../../node_modules/@theia/notebook/lib/common/index.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../../node_modules/@theia/core/lib/common/promise-util.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../../node_modules/@theia/core/lib/browser/context-key-service.js");
const notebook_context_keys_1 = __webpack_require__(/*! @theia/notebook/lib/browser/contributions/notebook-context-keys */ "../../node_modules/@theia/notebook/lib/browser/contributions/notebook-context-keys.js");
exports.AdditionalNotebookCellOutputCss = Symbol('AdditionalNotebookCellOutputCss');
function createCellOutputWebviewContainer(ctx) {
    const child = ctx.createChild();
    child.bind(exports.AdditionalNotebookCellOutputCss).toConstantValue(exports.DEFAULT_NOTEBOOK_OUTPUT_CSS);
    child.bind(CellOutputWebviewImpl).toSelf();
    return child;
}
exports.createCellOutputWebviewContainer = createCellOutputWebviewContainer;
// Should be kept up-to-date with:
// https://github.com/microsoft/vscode/blob/main/src/vs/workbench/contrib/notebook/browser/view/renderers/webviewThemeMapping.ts
const mapping = new Map([
    ['theme-font-family', 'vscode-font-family'],
    ['theme-font-weight', 'vscode-font-weight'],
    ['theme-font-size', 'vscode-font-size'],
    ['theme-code-font-family', 'vscode-editor-font-family'],
    ['theme-code-font-weight', 'vscode-editor-font-weight'],
    ['theme-code-font-size', 'vscode-editor-font-size'],
    ['theme-scrollbar-background', 'vscode-scrollbarSlider-background'],
    ['theme-scrollbar-hover-background', 'vscode-scrollbarSlider-hoverBackground'],
    ['theme-scrollbar-active-background', 'vscode-scrollbarSlider-activeBackground'],
    ['theme-quote-background', 'vscode-textBlockQuote-background'],
    ['theme-quote-border', 'vscode-textBlockQuote-border'],
    ['theme-code-foreground', 'vscode-textPreformat-foreground'],
    // Editor
    ['theme-background', 'vscode-editor-background'],
    ['theme-foreground', 'vscode-editor-foreground'],
    ['theme-ui-foreground', 'vscode-foreground'],
    ['theme-link', 'vscode-textLink-foreground'],
    ['theme-link-active', 'vscode-textLink-activeForeground'],
    // Buttons
    ['theme-button-background', 'vscode-button-background'],
    ['theme-button-hover-background', 'vscode-button-hoverBackground'],
    ['theme-button-foreground', 'vscode-button-foreground'],
    ['theme-button-secondary-background', 'vscode-button-secondaryBackground'],
    ['theme-button-secondary-hover-background', 'vscode-button-secondaryHoverBackground'],
    ['theme-button-secondary-foreground', 'vscode-button-secondaryForeground'],
    ['theme-button-hover-foreground', 'vscode-button-foreground'],
    ['theme-button-focus-foreground', 'vscode-button-foreground'],
    ['theme-button-secondary-hover-foreground', 'vscode-button-secondaryForeground'],
    ['theme-button-secondary-focus-foreground', 'vscode-button-secondaryForeground'],
    // Inputs
    ['theme-input-background', 'vscode-input-background'],
    ['theme-input-foreground', 'vscode-input-foreground'],
    ['theme-input-placeholder-foreground', 'vscode-input-placeholderForeground'],
    ['theme-input-focus-border-color', 'vscode-focusBorder'],
    // Menus
    ['theme-menu-background', 'vscode-menu-background'],
    ['theme-menu-foreground', 'vscode-menu-foreground'],
    ['theme-menu-hover-background', 'vscode-menu-selectionBackground'],
    ['theme-menu-focus-background', 'vscode-menu-selectionBackground'],
    ['theme-menu-hover-foreground', 'vscode-menu-selectionForeground'],
    ['theme-menu-focus-foreground', 'vscode-menu-selectionForeground'],
    // Errors
    ['theme-error-background', 'vscode-inputValidation-errorBackground'],
    ['theme-error-foreground', 'vscode-foreground'],
    ['theme-warning-background', 'vscode-inputValidation-warningBackground'],
    ['theme-warning-foreground', 'vscode-foreground'],
    ['theme-info-background', 'vscode-inputValidation-infoBackground'],
    ['theme-info-foreground', 'vscode-foreground'],
    // Notebook:
    ['theme-notebook-output-background', 'vscode-notebook-outputContainerBackgroundColor'],
    ['theme-notebook-output-border', 'vscode-notebook-outputContainerBorderColor'],
    ['theme-notebook-cell-selected-background', 'vscode-notebook-selectedCellBackground'],
    ['theme-notebook-symbol-highlight-background', 'vscode-notebook-symbolHighlightBackground'],
    ['theme-notebook-diff-removed-background', 'vscode-diffEditor-removedTextBackground'],
    ['theme-notebook-diff-inserted-background', 'vscode-diffEditor-insertedTextBackground'],
]);
const constants = {
    'theme-input-border-width': '1px',
    'theme-button-primary-hover-shadow': 'none',
    'theme-button-secondary-hover-shadow': 'none',
    'theme-input-border-color': 'transparent',
};
exports.DEFAULT_NOTEBOOK_OUTPUT_CSS = `
:root {
    ${Array.from(mapping.entries()).map(([key, value]) => `--${key}: var(--${value});`).join('\n')}
    ${Object.entries(constants).map(([key, value]) => `--${key}: ${value};`).join('\n')}
}

body {
    padding: 0;
}

table {
    border-collapse: collapse;
    border-spacing: 0;
}
  
table th,
table td {
    border: 1px solid;
}

table > thead > tr > th {
    text-align: left;
    border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
    padding: 5px 10px;
}

table > tbody > tr + tr > td {
    border-top: 1px solid;
}

table,
thead,
tr,
th,
td,
tbody {
    border: none !important;
    border-color: transparent;
    border-spacing: 0;
    border-collapse: collapse;
}

table,
th,
tr {
    vertical-align: middle;
    text-align: right;
}

thead {
    font-weight: bold;
    background-color: rgba(130, 130, 130, 0.16);
}

th,
td {
    padding: 4px 8px;
}

tr:nth-child(even) {
    background-color: rgba(130, 130, 130, 0.08);
}

tbody th {
    font-weight: normal;
}
`;
let CellOutputWebviewImpl = class CellOutputWebviewImpl {
    constructor() {
        // returns the output Height
        this.onDidRenderOutputEmitter = new core_1.Emitter();
        this.onDidRenderOutput = this.onDidRenderOutputEmitter.event;
        this.id = (0, uuid_1.generateUuid)();
        this.webviewWidgetInitialized = new promise_util_1.Deferred();
        this.toDispose = new core_1.DisposableCollection();
        this.isDisposed = false;
    }
    async init(notebook, editor) {
        this.notebook = notebook;
        this.editor = editor;
        this.options = this.notebookOptionsService.computeOutputOptions();
        this.toDispose.push(this.notebookOptionsService.onDidChangeOutputOptions(options => {
            this.options = options;
            this.updateStyles();
        }));
        this.webviewWidget = await this.widgetManager.getOrCreateWidget(webview_1.WebviewWidget.FACTORY_ID, { id: this.id });
        this.webviewWidgetInitialized.resolve();
        // this.webviewWidget.parent = this.editor ?? null;
        this.webviewWidget.setContentOptions({
            allowScripts: true,
            // eslint-disable-next-line max-len
            // list taken from https://github.com/microsoft/vscode/blob/a27099233b956dddc2536d4a0d714ab36266d897/src/vs/workbench/contrib/notebook/browser/view/renderers/backLayerWebView.ts#L762-L774
            enableCommandUris: [
                'github-issues.authNow',
                'workbench.extensions.search',
                'workbench.action.openSettings',
                '_notebook.selectKernel',
                'jupyter.viewOutput',
                'workbench.action.openLargeOutput',
                'cellOutput.enableScrolling',
            ],
        });
        this.webviewWidget.setHTML(await this.createWebviewContent());
        this.notebook.onDidAddOrRemoveCell(e => {
            if (e.newCellIds) {
                const newCells = e.newCellIds.map(id => this.notebook.cells.find(cell => cell.handle === id)).filter(cell => !!cell);
                newCells.forEach(cell => this.attachCellAndOutputListeners(cell));
            }
        });
        this.notebook.cells.forEach(cell => this.attachCellAndOutputListeners(cell));
        if (this.editor) {
            this.toDispose.push(this.editor.onDidPostKernelMessage(message => {
                this.webviewWidget.sendMessage({
                    type: 'customKernelMessage',
                    message
                });
            }));
            this.toDispose.push(this.editor.onPostRendererMessage(messageObj => {
                this.webviewWidget.sendMessage({
                    type: 'customRendererMessage',
                    ...messageObj
                });
            }));
        }
        this.webviewWidget.onMessage((message) => {
            this.handleWebviewMessage(message);
        });
    }
    attachCellAndOutputListeners(cell) {
        this.toDispose.push(cell.onDidChangeOutputs(outputChange => this.updateOutputs([{
                newOutputs: outputChange.newOutputs,
                start: outputChange.start,
                deleteCount: outputChange.deleteCount,
                cellHandle: cell.handle
            }])));
        this.toDispose.push(cell.onDidChangeOutputItems(output => {
            const oldOutputIndex = cell.outputs.findIndex(o => o.outputId === output.outputId);
            this.updateOutputs([{
                    cellHandle: cell.handle,
                    newOutputs: [output],
                    start: oldOutputIndex,
                    deleteCount: 1
                }]);
        }));
        this.toDispose.push(cell.onDidCellHeightChange(height => this.setCellHeight(cell, height)));
        this.toDispose.push(cell.onDidChangeOutputVisibility(visible => {
            this.webviewWidget.sendMessage({
                type: 'outputVisibilityChanged',
                cellHandle: cell.handle,
                visible
            });
        }));
    }
    render() {
        return React.createElement("div", { className: 'theia-notebook-cell-output-webview', ref: async (element) => {
                if (element) {
                    this.element = element;
                    await this.webviewWidgetInitialized.promise;
                    this.attachWebview();
                }
            } });
    }
    attachWebview() {
        if (this.element) {
            this.webviewWidget.processMessage(new browser_2.Message('before-attach'));
            this.element.appendChild(this.webviewWidget.node);
            this.webviewWidget.processMessage(new browser_2.Message('after-attach'));
            this.webviewWidget.setIframeHeight(0);
        }
    }
    isAttached() {
        var _a, _b;
        return (_b = (_a = this.element) === null || _a === void 0 ? void 0 : _a.contains(this.webviewWidget.node)) !== null && _b !== void 0 ? _b : false;
    }
    updateOutputs(updates) {
        if (this.webviewWidget.isHidden) {
            this.webviewWidget.show();
        }
        const visibleCells = this.notebook.getVisibleCells();
        const visibleCellHandleLookup = new Set(visibleCells.map(cell => cell.handle));
        const updateOutputMessage = {
            type: 'outputChanged',
            changes: updates
                .filter(update => visibleCellHandleLookup.has(update.cellHandle))
                .map(update => ({
                cellHandle: update.cellHandle,
                newOutputs: this.mapCellOutputsToWebviewOutput(update.newOutputs),
                start: update.start,
                deleteCount: update.deleteCount
            }))
        };
        if (updateOutputMessage.changes.length > 0) {
            this.webviewWidget.sendMessage(updateOutputMessage);
        }
    }
    cellsChanged(cellEvents) {
        const changes = [];
        const outputChanges = [];
        const visibleCellLookup = new Set(this.notebook.getVisibleCells());
        for (const event of cellEvents) {
            if (event.kind === common_1.NotebookCellsChangeType.Move) {
                changes.push(...event.cells.map((cell, i) => {
                    const cellMoved = {
                        type: 'cellMoved',
                        cellHandle: event.cells[0].handle, // TODO check this, ask Jonah
                        toIndex: event.newIdx,
                    };
                    return cellMoved;
                }));
            }
            else if (event.kind === common_1.NotebookCellsChangeType.ModelChange) {
                changes.push(...event.changes.map(change => {
                    const cellSpliced = {
                        type: 'cellsSpliced',
                        startCellHandle: change.startHandle,
                        deleteCount: change.deleteCount,
                        newCells: change.newItems.filter(cell => visibleCellLookup.has(cell)).map(cell => cell.handle)
                    };
                    return cellSpliced;
                }));
                outputChanges.push(...event.changes
                    .flatMap(change => change.newItems)
                    .filter(cell => visibleCellLookup.has(cell) && cell.outputs.length)
                    .map(newCell => ({
                    start: 0,
                    deleteCount: 0,
                    cellHandle: newCell.handle,
                    newOutputs: this.mapCellOutputsToWebviewOutput(newCell.outputs)
                })));
            }
        }
        this.webviewWidget.sendMessage({
            type: 'cellsChanged',
            changes: changes.filter(e => e)
        });
        if (outputChanges.length > 0) {
            this.webviewWidget.sendMessage({
                type: 'outputChanged',
                changes: outputChanges
            });
        }
    }
    mapCellOutputsToWebviewOutput(outputs) {
        return outputs.map(output => ({
            id: output.outputId,
            items: output.outputs.map(item => ({ mime: item.mime, data: item.data.buffer })),
            metadata: output.metadata
        }));
    }
    /**
     * Currently not used, but could be useful in a subclasses
     *
     * @param index cell index
     * @param cellHandle cell handle
     * @param visibleCells  visible cells
     * @returns visible cell index or -1 if not found
     */
    toVisibleCellIndex(index, cellHandle, visibleCells) {
        const cell = this.notebook.cells[index];
        if (cell.handle === cellHandle) {
            return visibleCells.indexOf(cell);
        }
        // in case of deletion index points to a non-existing cell
        return -1;
    }
    setCellHeight(cell, height) {
        if (!this.isDisposed) {
            this.webviewWidget.sendMessage({
                type: 'cellHeightUpdate',
                cellHandle: cell.handle,
                cellKind: cell.cellKind,
                height
            });
        }
    }
    async requestOutputPresentationUpdate(cellHandle, output) {
        const selectedMime = await this.quickPickService.show(output.outputs.map(item => ({ label: item.mime })), { description: core_1.nls.localizeByDefault('Select mimetype to render for current output') });
        if (selectedMime) {
            this.webviewWidget.sendMessage({
                type: 'changePreferredMimetype',
                cellHandle,
                outputId: output.outputId,
                mimeType: selectedMime.label
            });
        }
    }
    handleWebviewMessage(message) {
        var _a, _b, _c, _d;
        if (!this.editor) {
            throw new Error('No editor found for cell output webview');
        }
        switch (message.type) {
            case 'initialized':
                this.updateOutputs(this.notebook.getVisibleCells().map(cell => ({
                    cellHandle: cell.handle,
                    newOutputs: cell.outputs,
                    start: 0,
                    deleteCount: 0
                })));
                this.updateStyles();
                break;
            case 'customRendererMessage':
                this.messagingService.getScoped(this.editor.id).postMessage(message.rendererId, message.message);
                break;
            case 'didRenderOutput':
                this.webviewWidget.setIframeHeight(message.bodyHeight);
                this.onDidRenderOutputEmitter.fire({
                    cellHandle: message.cellHandle,
                    outputId: message.outputId,
                    outputHeight: message.outputHeight
                });
                break;
            case 'did-scroll-wheel':
                this.editor.node.getElementsByClassName('theia-notebook-viewport')[0].children[0].scrollBy(message.deltaX, message.deltaY);
                break;
            case 'customKernelMessage':
                this.editor.recieveKernelMessage(message.message);
                break;
            case 'inputFocusChanged':
                (_a = this.editor) === null || _a === void 0 ? void 0 : _a.outputInputFocusChanged(message.focused);
                break;
            case 'cellFocusChanged':
                const selectedCell = this.notebook.getCellByHandle(message.cellHandle);
                if (selectedCell) {
                    this.editor.viewModel.setSelectedCell(selectedCell);
                }
                break;
            case 'webviewFocusChanged':
                if (message.focused) {
                    (_b = window.getSelection()) === null || _b === void 0 ? void 0 : _b.empty();
                }
                this.contextKeyService.setContext(notebook_context_keys_1.NOTEBOOK_OUTPUT_FOCUSED, message.focused);
                break;
            case 'cellHeightRequest':
                const cellHeight = (_d = (_c = this.notebook.getCellByHandle(message.cellHandle)) === null || _c === void 0 ? void 0 : _c.cellHeight) !== null && _d !== void 0 ? _d : 0;
                this.webviewWidget.sendMessage({
                    type: 'cellHeightUpdate',
                    cellHandle: message.cellHandle,
                    height: cellHeight
                });
                break;
            case 'bodyHeightChange':
                this.webviewWidget.setIframeHeight(message.height);
                break;
        }
    }
    getPreloads() {
        var _a;
        const kernel = this.notebookKernelService.getSelectedOrSuggestedKernel(this.notebook);
        const kernelPreloads = (_a = kernel === null || kernel === void 0 ? void 0 : kernel.preloadUris.map(uri => uri.toString())) !== null && _a !== void 0 ? _a : [];
        const staticPreloads = this.notebookRendererRegistry.staticNotebookPreloads
            .filter(preload => preload.type === this.notebook.viewType)
            .map(preload => preload.entrypoint);
        return kernelPreloads.concat(staticPreloads);
    }
    updateStyles() {
        this.webviewWidget.sendMessage({
            type: 'notebookStyles',
            styles: this.generateStyles()
        });
    }
    generateStyles() {
        return {
            'notebook-output-node-left-padding': `${this.options.outputNodeLeftPadding}px`,
            'notebook-cell-output-font-size': `${this.options.outputFontSize || this.options.fontSize}px`,
            'notebook-cell-output-line-height': `${this.options.outputLineHeight}px`,
            'notebook-cell-output-max-height': `${this.options.outputLineHeight * this.options.outputLineLimit}px`,
            'notebook-cell-output-font-family': this.options.outputFontFamily || this.options.fontFamily,
        };
    }
    async createWebviewContent() {
        const isWorkspaceTrusted = await this.workspaceTrustService.getWorkspaceTrust();
        const preloads = this.preloadsScriptString(isWorkspaceTrusted);
        const content = `
                <html>
                    <head>
                        <meta charset="UTF-8">
                        <style>
                            ${this.additionalOutputCss}
                        </style>
                    </head>
                    <body>
                        <script type="module">${preloads}</script>
                    </body>
                </html>
                `;
        return content;
    }
    preloadsScriptString(isWorkspaceTrusted) {
        const ctx = {
            isWorkspaceTrusted,
            rendererData: this.notebookRendererRegistry.notebookRenderers,
            renderOptions: {
                lineLimit: this.options.outputLineLimit,
                outputScrolling: this.options.outputScrolling,
                outputWordWrap: this.options.outputWordWrap,
            },
            staticPreloadsData: this.getPreloads()
        };
        // TS will try compiling `import()` in webviewPreloads, so use a helper function instead
        // of using `import(...)` directly
        return `
            const __import = (x) => import(x);
                (${output_webview_internal_1.outputWebviewPreload})(JSON.parse(decodeURIComponent("${encodeURIComponent(JSON.stringify(ctx))}")))`;
    }
    dispose() {
        this.isDisposed = true;
        this.toDispose.dispose();
    }
};
exports.CellOutputWebviewImpl = CellOutputWebviewImpl;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.NotebookRendererMessagingService),
    tslib_1.__metadata("design:type", browser_1.NotebookRendererMessagingService)
], CellOutputWebviewImpl.prototype, "messagingService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.WidgetManager),
    tslib_1.__metadata("design:type", browser_2.WidgetManager)
], CellOutputWebviewImpl.prototype, "widgetManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_3.WorkspaceTrustService),
    tslib_1.__metadata("design:type", browser_3.WorkspaceTrustService)
], CellOutputWebviewImpl.prototype, "workspaceTrustService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.NotebookRendererRegistry),
    tslib_1.__metadata("design:type", browser_1.NotebookRendererRegistry)
], CellOutputWebviewImpl.prototype, "notebookRendererRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.NotebookEditorWidgetService),
    tslib_1.__metadata("design:type", browser_1.NotebookEditorWidgetService)
], CellOutputWebviewImpl.prototype, "notebookEditorWidgetService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.NotebookKernelService),
    tslib_1.__metadata("design:type", browser_1.NotebookKernelService)
], CellOutputWebviewImpl.prototype, "notebookKernelService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.QuickPickService),
    tslib_1.__metadata("design:type", Object)
], CellOutputWebviewImpl.prototype, "quickPickService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(exports.AdditionalNotebookCellOutputCss),
    tslib_1.__metadata("design:type", String)
], CellOutputWebviewImpl.prototype, "additionalOutputCss", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(notebook_options_1.NotebookOptionsService),
    tslib_1.__metadata("design:type", notebook_options_1.NotebookOptionsService)
], CellOutputWebviewImpl.prototype, "notebookOptionsService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], CellOutputWebviewImpl.prototype, "contextKeyService", void 0);
exports.CellOutputWebviewImpl = CellOutputWebviewImpl = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], CellOutputWebviewImpl);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/renderers/output-webview-internal.js"
/*!************************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/renderers/output-webview-internal.js ***!
  \************************************************************************************************************/
(__unused_webpack_module, exports) {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.outputWebviewPreload = void 0;
;
;
async function outputWebviewPreload(ctx) {
    // workaround to allow rendering of links in outputs for non chromium browsers
    // see https://developer.mozilla.org/en-US/docs/Web/API/Trusted_Types_API#cross-browser_support_for_trusted_types
    if (!window.trustedTypes) {
        window.trustedTypes = {
            createPolicy: (name, rules) => rules
        };
    }
    const theia = acquireVsCodeApi();
    const renderFallbackErrorName = 'vscode.fallbackToNextRenderer';
    document.body.style.overflow = 'hidden';
    const container = document.createElement('div');
    container.id = 'container';
    container.classList.add('widgetarea');
    document.body.appendChild(container);
    function createEmitter(listenerChange = () => undefined) {
        const listeners = new Set();
        return {
            fire(data) {
                for (const listener of [...listeners]) {
                    listener.fn.call(listener.thisArg, data);
                }
            },
            event(fn, thisArg, disposables) {
                const listenerObj = { fn, thisArg };
                const disposable = {
                    dispose: () => {
                        listeners.delete(listenerObj);
                        listenerChange(listeners);
                    },
                };
                listeners.add(listenerObj);
                listenerChange(listeners);
                if (disposables) {
                    if ('push' in disposables) {
                        disposables.push(disposable);
                    }
                    else {
                        disposables.add(disposable);
                    }
                }
                return disposable;
            }
        };
    }
    ;
    const settingChange = createEmitter();
    const onDidReceiveKernelMessage = createEmitter();
    function createKernelContext() {
        return Object.freeze({
            onDidReceiveKernelMessage: onDidReceiveKernelMessage.event,
            postKernelMessage: (data) => {
                theia.postMessage({ type: 'customKernelMessage', message: data });
            }
        });
    }
    async function runKernelPreload(url) {
        try {
            return activateModuleKernelPreload(url);
        }
        catch (e) {
            console.error(e);
            throw e;
        }
    }
    async function activateModuleKernelPreload(url) {
        const baseUri = window.location.href.replace(/\/webview\/index\.html.*/, '');
        const module = (await __import(`${baseUri}/${url}`));
        if (!module.activate) {
            console.error(`Notebook preload '${url}' was expected to be a module but it does not export an 'activate' function`);
            return;
        }
        return module.activate(createKernelContext());
    }
    class OutputCell {
        constructor(cellHandle, cellIndex) {
            this.cellHandle = cellHandle;
            this.outputElements = [];
            this.cellHeight = 0;
            this.element = document.createElement('div');
            this.element.style.outline = '0';
            this.element.id = `cellHandle${cellHandle}`;
            this.element.classList.add('cell_container');
            this.element.addEventListener('focusin', e => {
                theia.postMessage({ type: 'cellFocusChanged', cellHandle: cellHandle });
            });
            if (cellIndex !== undefined && cellIndex < container.children.length) {
                container.insertBefore(this.element, container.children[cellIndex]);
            }
            else {
                container.appendChild(this.element);
            }
            this.element = this.element;
            theia.postMessage({ type: 'cellHeightRequest', cellHandle: cellHandle });
        }
        dispose() {
            this.element.remove();
        }
        calcTotalOutputHeight() {
            return this.outputElements.reduce((acc, output) => acc + output.element.getBoundingClientRect().height, 0) + 5;
        }
        createOutputElement(index, output, items) {
            let outputContainer = this.outputElements.find(o => o.outputId === output.id);
            if (!outputContainer) {
                outputContainer = new OutputContainer(output, items, this);
                this.element.appendChild(outputContainer.containerElement);
                this.outputElements.splice(index, 0, outputContainer);
                this.updateCellHeight(this.cellHeight);
            }
            return outputContainer;
        }
        clearOutputs(start, deleteCount) {
            for (const output of this.outputElements.splice(start, deleteCount)) {
                output === null || output === void 0 ? void 0 : output.clear();
                output.containerElement.remove();
            }
        }
        show(outputId, top) {
            const outputContainer = this.outputElements.find(o => o.outputId === outputId);
            if (!outputContainer) {
                return;
            }
        }
        hide() {
            this.element.style.visibility = 'hidden';
        }
        updateCellHeight(height) {
            this.cellHeight = height;
            let additionalHeight = 54.5;
            additionalHeight -= cells[0] === this ? 2.5 : 0; // first cell
            additionalHeight -= this.outputElements.length ? 0 : 5.5; // no outputs
            this.element.style.paddingTop = `${height + additionalHeight}px`;
        }
        outputVisibilityChanged(visible) {
            var _a;
            this.outputElements.forEach(output => {
                output.element.style.display = visible ? 'initial' : 'none';
                output.containerElement.style.minHeight = visible ? '20px' : '0px';
            });
            if (visible) {
                (_a = this.element.getElementsByClassName('output-hidden')) === null || _a === void 0 ? void 0 : _a[0].remove();
                window.requestAnimationFrame(() => this.outputElements.forEach(output => sendDidRenderMessage(this, output)));
            }
            else {
                const outputHiddenElement = document.createElement('div');
                outputHiddenElement.classList.add('output-hidden');
                outputHiddenElement.style.height = '16px';
                this.element.appendChild(outputHiddenElement);
            }
        }
    }
    const cells = [];
    class OutputContainer {
        constructor(output, items, cell) {
            this.cell = cell;
            this.outputId = output.id;
            this.createHtmlElement();
            this.allItems = items;
        }
        findItemToRender(preferredMimetype) {
            var _a;
            if (preferredMimetype) {
                const itemToRender = this.allItems.find(item => item.mime === preferredMimetype);
                if (itemToRender) {
                    return itemToRender;
                }
            }
            return (_a = this.renderedItem) !== null && _a !== void 0 ? _a : this.allItems[0];
        }
        clear() {
            var _a, _b, _c;
            (_b = (_a = this.renderer) === null || _a === void 0 ? void 0 : _a.disposeOutputItem) === null || _b === void 0 ? void 0 : _b.call(_a, (_c = this.renderedItem) === null || _c === void 0 ? void 0 : _c.id);
            this.element.innerHTML = '';
        }
        preferredMimeTypeChange(mimeType) {
            this.containerElement.remove();
            this.createHtmlElement();
            this.cell.element.appendChild(this.containerElement);
            renderers.render(this.cell, this, mimeType, undefined, new AbortController().signal);
        }
        createHtmlElement() {
            this.containerElement = document.createElement('div');
            this.containerElement.classList.add('output-container');
            this.containerElement.style.minHeight = '20px';
            this.element = document.createElement('div');
            this.element.id = this.outputId;
            this.element.classList.add('output');
            this.containerElement.appendChild(this.element);
        }
    }
    class Renderer {
        constructor(data) {
            this.data = data;
            this.onMessageEvent = createEmitter();
        }
        receiveMessage(message) {
            this.onMessageEvent.fire(message);
        }
        disposeOutputItem(id) {
            var _a, _b;
            (_b = (_a = this.rendererApi) === null || _a === void 0 ? void 0 : _a.disposeOutputItem) === null || _b === void 0 ? void 0 : _b.call(_a, id);
        }
        async getOrLoad() {
            if (this.rendererApi) {
                return this.rendererApi;
            }
            // Preloads need to be loaded before loading renderers.
            await kernelPreloads.waitForAllCurrent();
            const baseUri = window.location.href.replace(/\/webview\/index\.html.*/, '');
            const rendererModule = await __import(`${baseUri}/${this.data.entrypoint.uri}`);
            this.rendererApi = await rendererModule.activate(this.createRendererContext());
            return this.rendererApi;
        }
        createRendererContext() {
            const context = {
                setState: newState => theia.setState({ ...theia.getState(), [this.data.id]: newState }),
                getState: () => {
                    const state = theia.getState();
                    return typeof state === 'object' && state ? state[this.data.id] : undefined;
                },
                getRenderer: async (id) => {
                    const renderer = renderers.getRenderer(id);
                    if (!renderer) {
                        return undefined;
                    }
                    if (renderer.rendererApi) {
                        return renderer.rendererApi;
                    }
                    return renderer.getOrLoad();
                },
                workspace: {
                    get isTrusted() { return true; } // TODO use Workspace trust service
                },
                settings: {
                    get lineLimit() { return ctx.renderOptions.lineLimit; },
                    get outputScrolling() { return ctx.renderOptions.outputScrolling; },
                    get outputWordWrap() { return ctx.renderOptions.outputWordWrap; },
                },
                get onDidChangeSettings() { return settingChange.event; },
            };
            if (this.data.requiresMessaging) {
                context.onDidReceiveMessage = this.onMessageEvent.event;
                context.postMessage = message => {
                    theia.postMessage({ type: 'customRendererMessage', rendererId: this.data.id, message });
                };
            }
            return Object.freeze(context);
        }
    }
    const renderers = new class {
        constructor() {
            this.renderers = new Map();
            for (const renderer of ctx.rendererData) {
                this.addRenderer(renderer);
            }
        }
        getRenderer(id) {
            return this.renderers.get(id);
        }
        rendererEqual(a, b) {
            if (a.id !== b.id || a.entrypoint.uri !== b.entrypoint.uri || a.entrypoint.extends !== b.entrypoint.extends || a.requiresMessaging !== b.requiresMessaging) {
                return false;
            }
            if (a.mimeTypes.length !== b.mimeTypes.length) {
                return false;
            }
            for (let i = 0; i < a.mimeTypes.length; i++) {
                if (a.mimeTypes[i] !== b.mimeTypes[i]) {
                    return false;
                }
            }
            return true;
        }
        updateRendererData(rendererData) {
            const oldKeys = new Set(this.renderers.keys());
            const newKeys = new Set(rendererData.map(d => d.id));
            for (const renderer of rendererData) {
                const existing = this.renderers.get(renderer.id);
                if (existing && this.rendererEqual(existing.data, renderer)) {
                    continue;
                }
                this.addRenderer(renderer);
            }
            for (const key of oldKeys) {
                if (!newKeys.has(key)) {
                    this.renderers.delete(key);
                }
            }
        }
        addRenderer(renderer) {
            this.renderers.set(renderer.id, new Renderer(renderer));
        }
        clearAll() {
            for (const renderer of this.renderers.values()) {
                renderer.disposeOutputItem();
            }
        }
        clearOutput(rendererId, outputId) {
            var _a;
            // outputRunner.cancelOutput(outputId);
            (_a = this.renderers.get(rendererId)) === null || _a === void 0 ? void 0 : _a.disposeOutputItem(outputId);
        }
        async render(cell, output, preferredMimeType, preferredRendererId, signal) {
            const item = output.findItemToRender(preferredMimeType);
            const primaryRenderer = this.findRenderer(preferredRendererId, item);
            if (!primaryRenderer) {
                this.showRenderError(item, output.element, 'No renderer found for output type.');
                return;
            }
            // Try primary renderer first
            if (!(await this.doRender(item, output.element, primaryRenderer, signal)).continue) {
                output.renderer = primaryRenderer;
                this.onRenderCompleted(cell, output);
                return;
            }
            // Primary renderer failed in an expected way. Fallback to render the next mime types
            for (const additionalItem of output.allItems) {
                if (additionalItem.mime === item.mime) {
                    continue;
                }
                if (signal.aborted) {
                    return;
                }
                if (additionalItem) {
                    const renderer = this.findRenderer(undefined, additionalItem);
                    if (renderer) {
                        if (!(await this.doRender(additionalItem, output.element, renderer, signal)).continue) {
                            output.renderer = renderer;
                            this.onRenderCompleted(cell, output);
                            return; // We rendered successfully
                        }
                    }
                }
            }
            // All renderers have failed and there is nothing left to fallback to
            this.showRenderError(item, output.element, 'No fallback renderers found or all fallback renderers failed.');
        }
        onRenderCompleted(cell, output) {
            // we need to check for all images are loaded. Otherwise we can't determine the correct height of the output
            const images = Array.from(document.images);
            if (images.length > 0) {
                Promise.all(images
                    .filter(img => !img.complete && !img.dataset.waiting)
                    .map(img => {
                    img.dataset.waiting = 'true'; // mark to avoid overriding onload a second time
                    return new Promise(resolve => { img.onload = img.onerror = resolve; });
                })).then(() => {
                    sendDidRenderMessage(cell, output);
                    new ResizeObserver(() => sendDidRenderMessage(cell, output)).observe(cell.element);
                });
            }
            else {
                sendDidRenderMessage(cell, output);
                new ResizeObserver(() => sendDidRenderMessage(cell, output)).observe(cell.element);
            }
        }
        async doRender(item, element, renderer, signal) {
            var _a;
            try {
                await ((_a = (await renderer.getOrLoad())) === null || _a === void 0 ? void 0 : _a.renderOutputItem(item, element, signal));
                return { continue: false }; // We rendered successfully
            }
            catch (e) {
                if (signal.aborted) {
                    return { continue: false };
                }
                if (e instanceof Error && e.name === renderFallbackErrorName) {
                    return { continue: true };
                }
                else {
                    throw e; // Bail and let callers handle unknown errors
                }
            }
        }
        findRenderer(preferredRendererId, info) {
            let foundRenderer;
            if (typeof preferredRendererId === 'string') {
                foundRenderer = Array.from(this.renderers.values())
                    .find(renderer => renderer.data.id === preferredRendererId);
            }
            else {
                const rendererList = Array.from(this.renderers.values())
                    .filter(renderer => renderer.data.mimeTypes.includes(info.mime) && !renderer.data.entrypoint.extends);
                if (rendererList.length) {
                    // De-prioritize built-in renderers
                    // rendererList.sort((a, b) => +a.data.isBuiltin - +b.data.isBuiltin);
                    // Use first renderer we find in sorted list
                    foundRenderer = rendererList[0];
                }
            }
            return foundRenderer;
        }
        showRenderError(info, element, errorMessage) {
            const errorContainer = document.createElement('div');
            const error = document.createElement('div');
            error.className = 'no-renderer-error';
            error.innerText = errorMessage;
            const cellText = document.createElement('div');
            cellText.innerText = info.text();
            errorContainer.appendChild(error);
            errorContainer.appendChild(cellText);
            element.innerText = '';
            element.appendChild(errorContainer);
        }
    }();
    function sendDidRenderMessage(cell, output) {
        theia.postMessage({
            type: 'didRenderOutput',
            cellHandle: cell.cellHandle,
            outputId: output.outputId,
            outputHeight: cell.calcTotalOutputHeight(),
            bodyHeight: document.body.clientHeight
        });
    }
    const kernelPreloads = new class {
        constructor() {
            this.preloads = new Map();
        }
        /**
         * Returns a promise that resolves when the given preload is activated.
         */
        waitFor(uri) {
            return this.preloads.get(uri) || Promise.resolve(new Error(`Preload not ready: ${uri}`));
        }
        /**
         * Loads a preload.
         * @param uri URI to load from
         * @param originalUri URI to show in an error message if the preload is invalid.
         */
        load(uri) {
            const promise = Promise.all([
                runKernelPreload(uri),
                this.waitForAllCurrent(),
            ]);
            this.preloads.set(uri, promise);
            return promise;
        }
        /**
         * Returns a promise that waits for all currently-registered preloads to
         * activate before resolving.
         */
        waitForAllCurrent() {
            return Promise.all([...this.preloads.values()].map(p => p.catch(err => err)));
        }
    };
    await Promise.all(ctx.staticPreloadsData.map(preload => kernelPreloads.load(preload)));
    async function outputsChanged(changedEvent) {
        var _a, _b, _c;
        for (const cellChange of changedEvent.changes) {
            let cell = cells.find(c => c.cellHandle === cellChange.cellHandle);
            if (!cell) {
                cell = new OutputCell(cellChange.cellHandle);
                cells.push(cell);
            }
            cell.clearOutputs(cellChange.start, cellChange.deleteCount);
            for (const outputData of (_a = cellChange.newOutputs) !== null && _a !== void 0 ? _a : []) {
                const apiItems = outputData.items.map((item, index) => ({
                    id: `${outputData.id}-${index}`,
                    mime: item.mime,
                    metadata: outputData.metadata,
                    data() {
                        return item.data;
                    },
                    text() {
                        return new TextDecoder().decode(this.data());
                    },
                    json() {
                        return JSON.parse(this.text());
                    },
                    blob() {
                        return new Blob([this.data()], { type: this.mime });
                    },
                }));
                const output = cell.createOutputElement(cellChange.start, outputData, apiItems);
                await renderers.render(cell, output, undefined, undefined, new AbortController().signal);
                theia.postMessage({
                    type: 'didRenderOutput',
                    cellHandle: cell.cellHandle,
                    outputId: outputData.id,
                    outputHeight: (_c = (_b = document.getElementById(output.outputId)) === null || _b === void 0 ? void 0 : _b.clientHeight) !== null && _c !== void 0 ? _c : 0,
                    bodyHeight: document.body.clientHeight
                });
            }
        }
    }
    function cellsChanged(changes) {
        for (const change of changes) {
            if (change.type === 'cellMoved') {
                const currentIndex = cells.findIndex(c => c.cellHandle === change.cellHandle);
                const cell = cells[currentIndex];
                cells.splice(change.toIndex, 0, cells.splice(currentIndex, 1)[0]);
                if (change.toIndex < cells.length - 1) {
                    container.insertBefore(cell.element, container.children[change.toIndex + (change.toIndex > currentIndex ? 1 : 0)]);
                }
                else {
                    container.appendChild(cell.element);
                }
            }
            else if (change.type === 'cellsSpliced') {
                // if startCellHandle is negative, it means we should add a trailing new cell
                const startCellIndex = change.startCellHandle < 0 ? cells.length : cells.findIndex(c => c.cellHandle === change.startCellHandle);
                if (startCellIndex === -1) {
                    console.error(`Can't find cell output to splice. Cells: ${cells.length}, startCellHandle: ${change.startCellHandle}`);
                }
                else {
                    const deletedCells = cells.splice(startCellIndex, change.deleteCount, ...change.newCells.map((cellHandle, i) => new OutputCell(cellHandle, startCellIndex + i)));
                    deletedCells.forEach(cell => cell.dispose());
                }
            }
        }
    }
    function shouldHandleScroll(event) {
        for (let node = event.target; node; node = node.parentNode) {
            if (!(node instanceof Element)) {
                return false;
            }
            // scroll up
            if (event.deltaY < 0 && node.scrollTop > 0) {
                // there is still some content to scroll
                return true;
            }
            // scroll down
            if (event.deltaY > 0 && node.scrollTop + node.clientHeight < node.scrollHeight) {
                // per https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight
                // scrollTop is not rounded but scrollHeight and clientHeight are
                // so we need to check if the difference is less than some threshold
                if (node.scrollHeight - node.scrollTop - node.clientHeight < 2) {
                    continue;
                }
                // if the node is not scrollable, we can continue. We don't check the computed style always as it's expensive
                if (window.getComputedStyle(node).overflowY === 'hidden' || window.getComputedStyle(node).overflowY === 'visible') {
                    continue;
                }
                return true;
            }
        }
        return false;
    }
    const handleWheel = (event) => {
        if (event.defaultPrevented || shouldHandleScroll(event)) {
            return;
        }
        theia.postMessage({
            type: 'did-scroll-wheel',
            deltaY: event.deltaY,
            deltaX: event.deltaX,
        });
    };
    window.addEventListener('message', async (rawEvent) => {
        var _a, _b, _c;
        const event = rawEvent;
        let cellHandle;
        switch (event.data.type) {
            case 'updateRenderers':
                renderers.updateRendererData(event.data.rendererData);
                break;
            case 'outputChanged':
                outputsChanged(event.data);
                break;
            case 'cellsChanged':
                cellsChanged(event.data.changes);
                break;
            case 'customRendererMessage':
                (_a = renderers.getRenderer(event.data.rendererId)) === null || _a === void 0 ? void 0 : _a.receiveMessage(event.data.message);
                break;
            case 'changePreferredMimetype':
                cellHandle = event.data.cellHandle;
                const mimeType = event.data.mimeType;
                (_b = cells.find(c => c.cellHandle === cellHandle)) === null || _b === void 0 ? void 0 : _b.outputElements.forEach(o => o.preferredMimeTypeChange(mimeType));
                break;
            case 'customKernelMessage':
                onDidReceiveKernelMessage.fire(event.data.message);
                break;
            case 'preload':
                const resources = event.data.resources;
                for (const uri of resources) {
                    kernelPreloads.load(uri);
                }
                break;
            case 'notebookStyles':
                const documentStyle = window.document.documentElement.style;
                for (let i = documentStyle.length - 1; i >= 0; i--) {
                    const property = documentStyle[i];
                    // Don't remove properties that the webview might have added separately
                    if (property && property.startsWith('--notebook-')) {
                        documentStyle.removeProperty(property);
                    }
                }
                // Re-add new properties
                for (const [name, value] of Object.entries(event.data.styles)) {
                    documentStyle.setProperty(`--${name}`, value);
                }
                break;
            case 'cellHeightUpdate':
                cellHandle = event.data.cellHandle;
                const cell = cells.find(c => c.cellHandle === cellHandle);
                if (cell) {
                    cell.updateCellHeight(event.data.height);
                }
                break;
            case 'outputVisibilityChanged':
                cellHandle = event.data.cellHandle;
                (_c = cells.find(c => c.cellHandle === cellHandle)) === null || _c === void 0 ? void 0 : _c.outputVisibilityChanged(event.data.visible);
                break;
        }
    });
    window.addEventListener('wheel', handleWheel);
    document.head.originalAppendChild = document.head.appendChild;
    document.head.appendChild = function appendChild(node) {
        if (node instanceof HTMLScriptElement && node.src.includes('webviewuuid')) {
            node.src = node.src.replace('webviewuuid', location.hostname.split('.')[0]);
        }
        return this.originalAppendChild(node);
    };
    const focusChange = (event, focus) => {
        if (event.target instanceof HTMLInputElement) {
            theia.postMessage({ type: 'inputFocusChanged', focused: focus });
        }
    };
    window.addEventListener('focusin', (event) => focusChange(event, true));
    window.addEventListener('focusout', (event) => focusChange(event, false));
    const webviewFocuseChange = (focus) => {
        theia.postMessage({ type: 'webviewFocusChanged', focused: focus });
    };
    window.addEventListener('focus', () => webviewFocuseChange(true));
    window.addEventListener('blur', () => webviewFocuseChange(false));
    new ResizeObserver(() => {
        theia.postMessage({
            type: 'bodyHeightChange',
            height: document.body.clientHeight
        });
    }).observe(document.body);
    theia.postMessage({ type: 'initialized' });
}
exports.outputWebviewPreload = outputWebviewPreload;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/notification-main.js"
/*!**********************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/notification-main.js ***!
  \**********************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotificationMainImpl = void 0;
const common_1 = __webpack_require__(/*! ../../common */ "../../node_modules/@theia/plugin-ext/lib/common/index.js");
const basic_notification_main_1 = __webpack_require__(/*! ../common/basic-notification-main */ "../../node_modules/@theia/plugin-ext/lib/main/common/basic-notification-main.js");
class NotificationMainImpl extends basic_notification_main_1.BasicNotificationMainImpl {
    constructor(rpc, container) {
        super(rpc, container, common_1.MAIN_RPC_CONTEXT.NOTIFICATION_EXT);
    }
}
exports.NotificationMainImpl = NotificationMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/output-channel-registry-main.js"
/*!*********************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/output-channel-registry-main.js ***!
  \*********************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OutputChannelRegistryMainImpl = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const command_1 = __webpack_require__(/*! @theia/core/lib/common/command */ "../../node_modules/@theia/core/lib/common/command.js");
const output_commands_1 = __webpack_require__(/*! @theia/output/lib/browser/output-commands */ "../../node_modules/@theia/output/lib/browser/output-commands.js");
let OutputChannelRegistryMainImpl = class OutputChannelRegistryMainImpl {
    $append(name, text, pluginInfo) {
        this.commandService.executeCommand(output_commands_1.OutputCommands.APPEND.id, { name, text });
        return Promise.resolve();
    }
    $clear(name) {
        this.commandService.executeCommand(output_commands_1.OutputCommands.CLEAR.id, { name });
        return Promise.resolve();
    }
    $dispose(name) {
        this.commandService.executeCommand(output_commands_1.OutputCommands.DISPOSE.id, { name });
        return Promise.resolve();
    }
    async $reveal(name, preserveFocus) {
        const options = { preserveFocus };
        this.commandService.executeCommand(output_commands_1.OutputCommands.SHOW.id, { name, options });
    }
    $close(name) {
        this.commandService.executeCommand(output_commands_1.OutputCommands.HIDE.id, { name });
        return Promise.resolve();
    }
};
exports.OutputChannelRegistryMainImpl = OutputChannelRegistryMainImpl;
tslib_1.__decorate([
    (0, inversify_1.inject)(command_1.CommandService),
    tslib_1.__metadata("design:type", Object)
], OutputChannelRegistryMainImpl.prototype, "commandService", void 0);
exports.OutputChannelRegistryMainImpl = OutputChannelRegistryMainImpl = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], OutputChannelRegistryMainImpl);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-authentication-service.js"
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-authentication-service.js ***!
  \**********************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 EclipseSource and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginAuthenticationServiceImpl = exports.getAuthenticationProviderActivationEvent = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const authentication_service_1 = __webpack_require__(/*! @theia/core/lib/browser/authentication-service */ "../../node_modules/@theia/core/lib/browser/authentication-service.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../../node_modules/@theia/core/lib/common/promise-util.js");
const hosted_plugin_1 = __webpack_require__(/*! ../../hosted/browser/hosted-plugin */ "../../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin.js");
function getAuthenticationProviderActivationEvent(id) { return `onAuthenticationRequest:${id}`; }
exports.getAuthenticationProviderActivationEvent = getAuthenticationProviderActivationEvent;
/**
 * Plugin authentication service that aims to activate additional plugins if sessions are created or queried.
 */
class PluginAuthenticationServiceImpl extends authentication_service_1.AuthenticationServiceImpl {
    async getSessions(id, scopes) {
        await this.tryActivateProvider(id);
        return super.getSessions(id, scopes);
    }
    async login(id, scopes) {
        await this.tryActivateProvider(id);
        return super.login(id, scopes);
    }
    async tryActivateProvider(providerId) {
        this.pluginService.activateByEvent(getAuthenticationProviderActivationEvent(providerId));
        const provider = this.authenticationProviders.get(providerId);
        if (provider) {
            return provider;
        }
        // When activate has completed, the extension has made the call to `registerAuthenticationProvider`.
        // However, activate cannot block on this, so the renderer may not have gotten the event yet.
        return Promise.race([
            this.waitForProviderRegistration(providerId),
            (0, promise_util_1.timeoutReject)(5000, 'Timed out waiting for authentication provider to register')
        ]);
    }
    async waitForProviderRegistration(providerId) {
        const waitForRegistration = new promise_util_1.Deferred();
        const registration = this.onDidRegisterAuthenticationProvider(info => {
            if (info.id === providerId) {
                registration.dispose();
                const provider = this.authenticationProviders.get(providerId);
                if (provider) {
                    waitForRegistration.resolve(provider);
                }
                else {
                    waitForRegistration.reject(new Error(`No authentication provider '${providerId}' is currently registered.`));
                }
            }
        });
        return waitForRegistration.promise;
    }
}
exports.PluginAuthenticationServiceImpl = PluginAuthenticationServiceImpl;
tslib_1.__decorate([
    (0, inversify_1.inject)(hosted_plugin_1.HostedPluginSupport),
    tslib_1.__metadata("design:type", hosted_plugin_1.HostedPluginSupport)
], PluginAuthenticationServiceImpl.prototype, "pluginService", void 0);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-contribution-handler.js"
/*!********************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-contribution-handler.js ***!
  \********************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginContributionHandler = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const textmate_1 = __webpack_require__(/*! @theia/monaco/lib/browser/textmate */ "../../node_modules/@theia/monaco/lib/browser/textmate/index.js");
const menus_contribution_handler_1 = __webpack_require__(/*! ./menus/menus-contribution-handler */ "../../node_modules/@theia/plugin-ext/lib/main/browser/menus/menus-contribution-handler.js");
const plugin_view_registry_1 = __webpack_require__(/*! ./view/plugin-view-registry */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-registry.js");
const plugin_custom_editor_registry_1 = __webpack_require__(/*! ./custom-editors/plugin-custom-editor-registry */ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/plugin-custom-editor-registry.js");
const common_1 = __webpack_require__(/*! ../../common */ "../../node_modules/@theia/plugin-ext/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const keybindings_contribution_handler_1 = __webpack_require__(/*! ./keybindings/keybindings-contribution-handler */ "../../node_modules/@theia/plugin-ext/lib/main/browser/keybindings/keybindings-contribution-handler.js");
const monaco_snippet_suggest_provider_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-snippet-suggest-provider */ "../../node_modules/@theia/monaco/lib/browser/monaco-snippet-suggest-provider.js");
const plugin_shared_style_1 = __webpack_require__(/*! ./plugin-shared-style */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-shared-style.js");
const command_1 = __webpack_require__(/*! @theia/core/lib/common/command */ "../../node_modules/@theia/core/lib/common/command.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../node_modules/@theia/core/lib/common/event.js");
const browser_2 = __webpack_require__(/*! @theia/task/lib/browser */ "../../node_modules/@theia/task/lib/browser/index.js");
const browser_3 = __webpack_require__(/*! @theia/notebook/lib/browser */ "../../node_modules/@theia/notebook/lib/browser/index.js");
const plugin_debug_service_1 = __webpack_require__(/*! ./debug/plugin-debug-service */ "../../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-service.js");
const debug_schema_updater_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-schema-updater */ "../../node_modules/@theia/debug/lib/browser/debug-schema-updater.js");
const monaco_theming_service_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-theming-service */ "../../node_modules/@theia/monaco/lib/browser/monaco-theming-service.js");
const color_registry_1 = __webpack_require__(/*! @theia/core/lib/browser/color-registry */ "../../node_modules/@theia/core/lib/browser/color-registry.js");
const plugin_icon_service_1 = __webpack_require__(/*! ./plugin-icon-service */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-icon-service.js");
const plugin_icon_theme_service_1 = __webpack_require__(/*! ./plugin-icon-theme-service */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-icon-theme-service.js");
const common_2 = __webpack_require__(/*! @theia/core/lib/common */ "../../node_modules/@theia/core/lib/common/index.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const terminal_profile_service_1 = __webpack_require__(/*! @theia/terminal/lib/browser/terminal-profile-service */ "../../node_modules/@theia/terminal/lib/browser/terminal-profile-service.js");
const terminal_service_1 = __webpack_require__(/*! @theia/terminal/lib/browser/base/terminal-service */ "../../node_modules/@theia/terminal/lib/browser/base/terminal-service.js");
const plugin_terminal_registry_1 = __webpack_require__(/*! ./plugin-terminal-registry */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-terminal-registry.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../../node_modules/@theia/core/lib/browser/context-key-service.js");
const language_service_1 = __webpack_require__(/*! @theia/core/lib/browser/language-service */ "../../node_modules/@theia/core/lib/browser/language-service.js");
const themables_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/base/common/themables */ "../../node_modules/@theia/monaco-editor-core/esm/vs/base/common/themables.js");
let PluginContributionHandler = class PluginContributionHandler {
    constructor() {
        this.injections = new Map();
        this.commandHandlers = new Map();
        this.onDidRegisterCommandHandlerEmitter = new event_1.Emitter();
        this.onDidRegisterCommandHandler = this.onDidRegisterCommandHandlerEmitter.event;
    }
    /**
     * Always synchronous in order to simplify handling disconnections.
     * @throws never, loading of each contribution should handle errors
     * in order to avoid preventing loading of other contributions or extensions
     */
    handleContributions(clientId, plugin) {
        const contributions = plugin.contributes;
        if (!contributions) {
            return disposable_1.Disposable.NULL;
        }
        const toDispose = new disposable_1.DisposableCollection(disposable_1.Disposable.create(() => { }));
        /* eslint-disable @typescript-eslint/no-explicit-any */
        const logError = (message, ...args) => console.error(`[${clientId}][${plugin.metadata.model.id}]: ${message}`, ...args);
        const logWarning = (message, ...args) => console.warn(`[${clientId}][${plugin.metadata.model.id}]: ${message}`, ...args);
        const pushContribution = (id, contribute) => {
            if (toDispose.disposed) {
                return;
            }
            try {
                toDispose.push(contribute());
            }
            catch (e) {
                logError(`Failed to load '${id}' contribution.`, e);
            }
        };
        const configuration = contributions.configuration;
        if (configuration) {
            for (const config of configuration) {
                pushContribution('configuration', () => this.preferenceSchemaProvider.addSchema(config));
            }
        }
        const configurationDefaults = contributions.configurationDefaults;
        if (configurationDefaults) {
            pushContribution('configurationDefaults', () => this.updateDefaultOverridesSchema(configurationDefaults));
        }
        const languages = contributions.languages;
        if (languages && languages.length) {
            for (const lang of languages) {
                // it is not possible to unregister a language
                monaco.languages.register({
                    id: lang.id,
                    aliases: lang.aliases,
                    extensions: lang.extensions,
                    filenamePatterns: lang.filenamePatterns,
                    filenames: lang.filenames,
                    firstLine: lang.firstLine,
                    mimetypes: lang.mimetypes
                });
                if (lang.icon) {
                    const languageIcon = this.style.toFileIconClass(lang.icon);
                    pushContribution(`language.${lang.id}.icon`, () => languageIcon);
                    pushContribution(`language.${lang.id}.iconRegistration`, () => this.languageService.registerIcon(lang.id, languageIcon.object.iconClass));
                }
                const langConfiguration = lang.configuration;
                if (langConfiguration) {
                    pushContribution(`language.${lang.id}.configuration`, () => monaco.languages.setLanguageConfiguration(lang.id, {
                        wordPattern: this.createRegex(langConfiguration.wordPattern),
                        autoClosingPairs: langConfiguration.autoClosingPairs,
                        brackets: langConfiguration.brackets,
                        comments: langConfiguration.comments,
                        folding: this.convertFolding(langConfiguration.folding),
                        surroundingPairs: langConfiguration.surroundingPairs,
                        indentationRules: this.convertIndentationRules(langConfiguration.indentationRules),
                        onEnterRules: this.convertOnEnterRules(langConfiguration.onEnterRules),
                    }));
                }
            }
        }
        const grammars = contributions.grammars;
        if (grammars && grammars.length) {
            const grammarsWithLanguage = [];
            for (const grammar of grammars) {
                if (grammar.injectTo) {
                    for (const injectScope of grammar.injectTo) {
                        pushContribution(`grammar.injectTo.${injectScope}`, () => {
                            const injections = this.injections.get(injectScope) || [];
                            injections.push(grammar.scope);
                            this.injections.set(injectScope, injections);
                            return disposable_1.Disposable.create(() => {
                                const index = injections.indexOf(grammar.scope);
                                if (index !== -1) {
                                    injections.splice(index, 1);
                                }
                            });
                        });
                    }
                }
                if (grammar.language) {
                    // processing is deferred.
                    grammarsWithLanguage.push(grammar);
                }
                pushContribution(`grammar.textmate.scope.${grammar.scope}`, () => this.grammarsRegistry.registerTextmateGrammarScope(grammar.scope, {
                    async getGrammarDefinition() {
                        return {
                            format: grammar.format,
                            content: grammar.grammar || '',
                            location: grammar.grammarLocation
                        };
                    },
                    getInjections: (scopeName) => this.injections.get(scopeName)
                }));
            }
            // load grammars on next tick to await registration of languages from all plugins in current tick
            // see https://github.com/eclipse-theia/theia/issues/6907#issuecomment-578600243
            setTimeout(() => {
                for (const grammar of grammarsWithLanguage) {
                    const language = grammar.language;
                    pushContribution(`grammar.language.${language}.scope`, () => this.grammarsRegistry.mapLanguageIdToTextmateGrammar(language, grammar.scope));
                    pushContribution(`grammar.language.${language}.configuration`, () => {
                        var _a;
                        return this.grammarsRegistry.registerGrammarConfiguration(language, {
                            embeddedLanguages: this.convertEmbeddedLanguages(grammar.embeddedLanguages, logWarning),
                            tokenTypes: this.convertTokenTypes(grammar.tokenTypes),
                            balancedBracketSelectors: (_a = grammar.balancedBracketScopes) !== null && _a !== void 0 ? _a : ['*'],
                            unbalancedBracketSelectors: grammar.balancedBracketScopes,
                        });
                    });
                }
                // activate grammars only once everything else is loaded.
                // see https://github.com/eclipse-theia/theia-cpp-extensions/issues/100#issuecomment-610643866
                setTimeout(() => {
                    for (const grammar of grammarsWithLanguage) {
                        const language = grammar.language;
                        pushContribution(`grammar.language.${language}.activation`, () => this.monacoTextmateService.activateLanguage(language));
                    }
                });
            });
        }
        pushContribution('commands', () => this.registerCommands(contributions));
        pushContribution('menus', () => this.menusContributionHandler.handle(plugin));
        pushContribution('keybindings', () => this.keybindingsContributionHandler.handle(contributions));
        if (contributions.customEditors) {
            for (const customEditor of contributions.customEditors) {
                pushContribution(`customEditors.${customEditor.viewType}`, () => this.customEditorRegistry.registerCustomEditor(customEditor, plugin));
            }
        }
        if (contributions.viewsContainers) {
            for (const location in contributions.viewsContainers) {
                if (contributions.viewsContainers.hasOwnProperty(location)) {
                    for (const viewContainer of contributions.viewsContainers[location]) {
                        pushContribution(`viewContainers.${viewContainer.id}`, () => this.viewRegistry.registerViewContainer(location, viewContainer));
                    }
                }
            }
        }
        if (contributions.views) {
            // eslint-disable-next-line guard-for-in
            for (const location in contributions.views) {
                for (const view of contributions.views[location]) {
                    pushContribution(`views.${view.id}`, () => this.viewRegistry.registerView(location, view));
                }
            }
        }
        if (contributions.viewsWelcome) {
            for (const [index, viewWelcome] of contributions.viewsWelcome.entries()) {
                pushContribution(`viewsWelcome.${viewWelcome.view}.${index}`, () => this.viewRegistry.registerViewWelcome(viewWelcome));
            }
        }
        if (contributions.snippets) {
            for (const snippet of contributions.snippets) {
                pushContribution(`snippets.${snippet.uri}`, () => this.snippetSuggestProvider.fromURI(snippet.uri, {
                    language: snippet.language,
                    source: snippet.source
                }));
            }
        }
        if (contributions.themes && contributions.themes.length) {
            const pending = {};
            for (const theme of contributions.themes) {
                pushContribution(`themes.${theme.uri}`, () => this.monacoThemingService.register(theme, pending));
            }
        }
        if (contributions.iconThemes && contributions.iconThemes.length) {
            for (const iconTheme of contributions.iconThemes) {
                pushContribution(`iconThemes.${iconTheme.uri}`, () => this.iconThemeService.register(iconTheme, plugin));
            }
        }
        if (contributions.icons && contributions.icons.length) {
            for (const icon of contributions.icons) {
                const defaultIcon = icon.defaults;
                let key;
                if (common_1.IconContribution.isIconDefinition(defaultIcon)) {
                    key = defaultIcon.location;
                }
                else {
                    key = defaultIcon.id;
                }
                pushContribution(`icons.${key}`, () => this.iconService.register(icon, plugin));
            }
        }
        const colors = contributions.colors;
        if (colors) {
            pushContribution('colors', () => this.colors.register(...colors));
        }
        if (contributions.taskDefinitions) {
            for (const taskDefinition of contributions.taskDefinitions) {
                pushContribution(`taskDefinitions.${taskDefinition.taskType}`, () => this.taskDefinitionRegistry.register(taskDefinition));
            }
        }
        if (contributions.problemPatterns) {
            for (const problemPattern of contributions.problemPatterns) {
                pushContribution(`problemPatterns.${problemPattern.name || problemPattern.regexp}`, () => this.problemPatternRegistry.register(problemPattern));
            }
        }
        if (contributions.problemMatchers) {
            for (const problemMatcher of contributions.problemMatchers) {
                pushContribution(`problemMatchers.${problemMatcher.label}`, () => this.problemMatcherRegistry.register(problemMatcher));
            }
        }
        if (contributions.debuggers && contributions.debuggers.length) {
            toDispose.push(disposable_1.Disposable.create(() => this.debugSchema.update()));
            for (const contribution of contributions.debuggers) {
                pushContribution(`debuggers.${contribution.type}`, () => this.debugService.registerDebugger(contribution));
            }
            this.debugSchema.update();
        }
        if (contributions.resourceLabelFormatters) {
            for (const formatter of contributions.resourceLabelFormatters) {
                for (const contribution of this.contributionProvider.getContributions()) {
                    if (contribution instanceof browser_1.DefaultUriLabelProviderContribution) {
                        pushContribution(`resourceLabelFormatters.${formatter.scheme}`, () => contribution.registerFormatter(formatter));
                    }
                }
            }
        }
        const self = this;
        if (contributions.terminalProfiles) {
            for (const profile of contributions.terminalProfiles) {
                pushContribution(`terminalProfiles.${profile.id}`, () => {
                    this.contributedProfileStore.registerTerminalProfile(profile.title, {
                        async start() {
                            const terminalId = await self.pluginTerminalRegistry.start(profile.id);
                            const result = self.terminalService.getById(terminalId);
                            if (!result) {
                                throw new Error(`Error starting terminal from profile ${profile.id}`);
                            }
                            return result;
                        }
                    });
                    return disposable_1.Disposable.create(() => {
                        this.contributedProfileStore.unregisterTerminalProfile(profile.id);
                    });
                });
            }
        }
        if (contributions.notebooks) {
            for (const notebook of contributions.notebooks) {
                pushContribution(`notebook.${notebook.type}`, () => this.notebookTypeRegistry.registerNotebookType(notebook, plugin.metadata.model.displayName));
            }
        }
        if (contributions.notebookRenderer) {
            for (const renderer of contributions.notebookRenderer) {
                pushContribution(`notebookRenderer.${renderer.id}`, () => this.notebookRendererRegistry.registerNotebookRenderer(renderer, common_1.PluginPackage.toPluginUrl(plugin.metadata.model, '')));
            }
        }
        if (contributions.notebookPreload) {
            for (const preload of contributions.notebookPreload) {
                pushContribution(`notebookPreloads.${preload.type}:${preload.entrypoint}`, () => this.notebookRendererRegistry.registerStaticNotebookPreload(preload.type, preload.entrypoint, common_1.PluginPackage.toPluginUrl(plugin.metadata.model, '')));
            }
        }
        return toDispose;
    }
    registerCommands(contribution) {
        if (!contribution.commands) {
            return disposable_1.Disposable.NULL;
        }
        const toDispose = new disposable_1.DisposableCollection();
        for (const { iconUrl, themeIcon, command, category, shortTitle, title, originalTitle, enablement } of contribution.commands) {
            const reference = iconUrl && this.style.toIconClass(iconUrl);
            const icon = themeIcon && themables_1.ThemeIcon.fromString(themeIcon);
            let iconClass;
            if (reference) {
                toDispose.push(reference);
                iconClass = reference.object.iconClass;
            }
            else if (icon) {
                iconClass = themables_1.ThemeIcon.asClassName(icon);
            }
            toDispose.push(this.registerCommand({ id: command, category, shortTitle, label: title, originalLabel: originalTitle, iconClass }, enablement));
        }
        return toDispose;
    }
    registerCommand(command, enablement) {
        if (this.hasCommand(command.id)) {
            console.warn(`command '${command.id}' already registered`);
            return disposable_1.Disposable.NULL;
        }
        const commandHandler = {
            execute: async (...args) => {
                const handler = this.commandHandlers.get(command.id);
                if (!handler) {
                    throw new Error(`command '${command.id}' not found`);
                }
                return handler(...args);
            },
            // Always enabled - a command can be executed programmatically or via the commands palette.
            isEnabled: () => {
                if (enablement) {
                    return this.contextKeyService.match(enablement);
                }
                return true;
            },
            // Visibility rules are defined via the `menus` contribution point.
            isVisible() { return true; }
        };
        if (enablement) {
            const contextKeys = this.contextKeyService.parseKeys(enablement);
            if (contextKeys && contextKeys.size > 0) {
                commandHandler.onDidChangeEnabled = (listener) => this.contextKeyService.onDidChange(e => {
                    if (e.affects(contextKeys)) {
                        listener();
                    }
                });
            }
        }
        const toDispose = new disposable_1.DisposableCollection();
        if (this.commands.getCommand(command.id)) {
            // overriding built-in command, i.e. `type` by the VSCodeVim extension
            toDispose.push(this.commands.registerHandler(command.id, commandHandler));
        }
        else {
            toDispose.push(this.commands.registerCommand(command, commandHandler));
        }
        this.commandHandlers.set(command.id, undefined);
        toDispose.push(disposable_1.Disposable.create(() => this.commandHandlers.delete(command.id)));
        return toDispose;
    }
    registerCommandHandler(id, execute) {
        if (this.hasCommandHandler(id)) {
            console.warn(`command handler '${id}' already registered`);
            return disposable_1.Disposable.NULL;
        }
        this.commandHandlers.set(id, execute);
        this.onDidRegisterCommandHandlerEmitter.fire(id);
        return disposable_1.Disposable.create(() => this.commandHandlers.set(id, undefined));
    }
    hasCommand(id) {
        return this.commandHandlers.has(id);
    }
    hasCommandHandler(id) {
        return !!this.commandHandlers.get(id);
    }
    updateDefaultOverridesSchema(configurationDefaults) {
        const disposables = new disposable_1.DisposableCollection();
        // eslint-disable-next-line guard-for-in
        for (const key in configurationDefaults) {
            const defaultValue = configurationDefaults[key];
            const match = key.match(common_2.OVERRIDE_PROPERTY_PATTERN);
            if (match && (0, common_2.isObject)(defaultValue)) {
                for (const [propertyName, value] of Object.entries(defaultValue)) {
                    disposables.push(this.preferenceSchemaProvider.registerOverride(propertyName, match[1], value));
                }
            }
            else {
                // regular configuration override
                disposables.push(this.preferenceSchemaProvider.registerOverride(key, undefined, defaultValue));
            }
        }
        return disposables;
    }
    createRegex(value) {
        if (typeof value === 'string') {
            return new RegExp(value, '');
        }
        if (typeof value == 'undefined') {
            return undefined;
        }
        return new RegExp(value.pattern, value.flags);
    }
    convertIndentationRules(rules) {
        if (!rules) {
            return undefined;
        }
        return {
            decreaseIndentPattern: this.createRegex(rules.decreaseIndentPattern),
            increaseIndentPattern: this.createRegex(rules.increaseIndentPattern),
            indentNextLinePattern: this.createRegex(rules.indentNextLinePattern),
            unIndentedLinePattern: this.createRegex(rules.unIndentedLinePattern)
        };
    }
    convertFolding(folding) {
        if (!folding) {
            return undefined;
        }
        const result = {
            offSide: folding.offSide
        };
        if (folding.markers) {
            result.markers = {
                end: this.createRegex(folding.markers.end),
                start: this.createRegex(folding.markers.start)
            };
        }
        return result;
    }
    convertTokenTypes(tokenTypes) {
        if (typeof tokenTypes === 'undefined' || tokenTypes === null) {
            return undefined;
        }
        const result = Object.create(null);
        const scopes = Object.keys(tokenTypes);
        const len = scopes.length;
        for (let i = 0; i < len; i++) {
            const scope = scopes[i];
            const tokenType = tokenTypes[scope];
            switch (tokenType) {
                case 'string':
                    result[scope] = 2 /* StandardTokenType.String */;
                    break;
                case 'other':
                    result[scope] = 0 /* StandardTokenType.Other */;
                    break;
                case 'comment':
                    result[scope] = 1 /* StandardTokenType.Comment */;
                    break;
            }
        }
        return result;
    }
    convertEmbeddedLanguages(languages, logWarning) {
        if (typeof languages === 'undefined' || languages === null) {
            return undefined;
        }
        const result = Object.create(null);
        const scopes = Object.keys(languages);
        const len = scopes.length;
        for (let i = 0; i < len; i++) {
            const scope = scopes[i];
            const langId = languages[scope];
            result[scope] = (0, textmate_1.getEncodedLanguageId)(langId);
            if (!result[scope]) {
                logWarning(`Language for '${scope}' not found.`);
            }
        }
        return result;
    }
    convertOnEnterRules(onEnterRules) {
        if (!onEnterRules) {
            return undefined;
        }
        const result = [];
        for (const onEnterRule of onEnterRules) {
            const rule = {
                beforeText: this.createRegex(onEnterRule.beforeText),
                afterText: this.createRegex(onEnterRule.afterText),
                previousLineText: this.createRegex(onEnterRule.previousLineText),
                action: this.createEnterAction(onEnterRule.action),
            };
            result.push(rule);
        }
        return result;
    }
    createEnterAction(action) {
        let indentAction;
        switch (action.indent) {
            case 'indent':
                indentAction = monaco.languages.IndentAction.Indent;
                break;
            case 'indentOutdent':
                indentAction = monaco.languages.IndentAction.IndentOutdent;
                break;
            case 'outdent':
                indentAction = monaco.languages.IndentAction.Outdent;
                break;
            default:
                indentAction = monaco.languages.IndentAction.None;
                break;
        }
        return { indentAction, appendText: action.appendText, removeText: action.removeText };
    }
};
exports.PluginContributionHandler = PluginContributionHandler;
tslib_1.__decorate([
    (0, inversify_1.inject)(textmate_1.TextmateRegistry),
    tslib_1.__metadata("design:type", textmate_1.TextmateRegistry)
], PluginContributionHandler.prototype, "grammarsRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_view_registry_1.PluginViewRegistry),
    tslib_1.__metadata("design:type", plugin_view_registry_1.PluginViewRegistry)
], PluginContributionHandler.prototype, "viewRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_custom_editor_registry_1.PluginCustomEditorRegistry),
    tslib_1.__metadata("design:type", plugin_custom_editor_registry_1.PluginCustomEditorRegistry)
], PluginContributionHandler.prototype, "customEditorRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(menus_contribution_handler_1.MenusContributionPointHandler),
    tslib_1.__metadata("design:type", menus_contribution_handler_1.MenusContributionPointHandler)
], PluginContributionHandler.prototype, "menusContributionHandler", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(common_2.PreferenceSchemaService),
    tslib_1.__metadata("design:type", Object)
], PluginContributionHandler.prototype, "preferenceSchemaProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(textmate_1.MonacoTextmateService),
    tslib_1.__metadata("design:type", textmate_1.MonacoTextmateService)
], PluginContributionHandler.prototype, "monacoTextmateService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(keybindings_contribution_handler_1.KeybindingsContributionPointHandler),
    tslib_1.__metadata("design:type", keybindings_contribution_handler_1.KeybindingsContributionPointHandler)
], PluginContributionHandler.prototype, "keybindingsContributionHandler", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(monaco_snippet_suggest_provider_1.MonacoSnippetSuggestProvider),
    tslib_1.__metadata("design:type", monaco_snippet_suggest_provider_1.MonacoSnippetSuggestProvider)
], PluginContributionHandler.prototype, "snippetSuggestProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(command_1.CommandRegistry),
    tslib_1.__metadata("design:type", command_1.CommandRegistry)
], PluginContributionHandler.prototype, "commands", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(language_service_1.LanguageService),
    tslib_1.__metadata("design:type", language_service_1.LanguageService)
], PluginContributionHandler.prototype, "languageService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_shared_style_1.PluginSharedStyle),
    tslib_1.__metadata("design:type", plugin_shared_style_1.PluginSharedStyle)
], PluginContributionHandler.prototype, "style", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.TaskDefinitionRegistry),
    tslib_1.__metadata("design:type", browser_2.TaskDefinitionRegistry)
], PluginContributionHandler.prototype, "taskDefinitionRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.ProblemMatcherRegistry),
    tslib_1.__metadata("design:type", browser_2.ProblemMatcherRegistry)
], PluginContributionHandler.prototype, "problemMatcherRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.ProblemPatternRegistry),
    tslib_1.__metadata("design:type", browser_2.ProblemPatternRegistry)
], PluginContributionHandler.prototype, "problemPatternRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_debug_service_1.PluginDebugService),
    tslib_1.__metadata("design:type", plugin_debug_service_1.PluginDebugService)
], PluginContributionHandler.prototype, "debugService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_schema_updater_1.DebugSchemaUpdater),
    tslib_1.__metadata("design:type", debug_schema_updater_1.DebugSchemaUpdater)
], PluginContributionHandler.prototype, "debugSchema", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(monaco_theming_service_1.MonacoThemingService),
    tslib_1.__metadata("design:type", monaco_theming_service_1.MonacoThemingService)
], PluginContributionHandler.prototype, "monacoThemingService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(color_registry_1.ColorRegistry),
    tslib_1.__metadata("design:type", color_registry_1.ColorRegistry)
], PluginContributionHandler.prototype, "colors", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_icon_service_1.PluginIconService),
    tslib_1.__metadata("design:type", plugin_icon_service_1.PluginIconService)
], PluginContributionHandler.prototype, "iconService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_icon_theme_service_1.PluginIconThemeService),
    tslib_1.__metadata("design:type", plugin_icon_theme_service_1.PluginIconThemeService)
], PluginContributionHandler.prototype, "iconThemeService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(terminal_service_1.TerminalService),
    tslib_1.__metadata("design:type", Object)
], PluginContributionHandler.prototype, "terminalService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_terminal_registry_1.PluginTerminalRegistry),
    tslib_1.__metadata("design:type", plugin_terminal_registry_1.PluginTerminalRegistry)
], PluginContributionHandler.prototype, "pluginTerminalRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(terminal_profile_service_1.ContributedTerminalProfileStore),
    tslib_1.__metadata("design:type", Object)
], PluginContributionHandler.prototype, "contributedProfileStore", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_3.NotebookTypeRegistry),
    tslib_1.__metadata("design:type", browser_3.NotebookTypeRegistry)
], PluginContributionHandler.prototype, "notebookTypeRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_3.NotebookRendererRegistry),
    tslib_1.__metadata("design:type", browser_3.NotebookRendererRegistry)
], PluginContributionHandler.prototype, "notebookRendererRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(common_2.ContributionProvider),
    (0, inversify_1.named)(browser_1.LabelProviderContribution),
    tslib_1.__metadata("design:type", Object)
], PluginContributionHandler.prototype, "contributionProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], PluginContributionHandler.prototype, "contextKeyService", void 0);
exports.PluginContributionHandler = PluginContributionHandler = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginContributionHandler);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-ext-argument-processor.js"
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-ext-argument-processor.js ***!
  \**********************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2025 EclipseSource GmbH.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginExtToolbarItemArgumentProcessor = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
/**
 * This processor handles arguments passed to commands that are contributed by plugins and available as toolbar items.
 *
 * When a toolbar item executes a command, it often passes the active widget as an argument. This can lead to
 * serialization problems. To solve this issue, this processor checks if an argument is a Widget instance and if so, it extracts
 * and returns only the widget's ID, which can be safely serialized and used to identify the widget in the plugin host.
 */
let PluginExtToolbarItemArgumentProcessor = class PluginExtToolbarItemArgumentProcessor {
    processArgument(arg) {
        if (arg instanceof browser_1.Widget) {
            return arg.id;
        }
        return arg;
    }
};
exports.PluginExtToolbarItemArgumentProcessor = PluginExtToolbarItemArgumentProcessor;
exports.PluginExtToolbarItemArgumentProcessor = PluginExtToolbarItemArgumentProcessor = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginExtToolbarItemArgumentProcessor);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-ext-frontend-module.js"
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-ext-frontend-module.js ***!
  \*******************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
__webpack_require__(/*! ../../../src/main/style/status-bar.css */ "../../node_modules/@theia/plugin-ext/src/main/style/status-bar.css");
__webpack_require__(/*! ../../../src/main/browser/style/index.css */ "../../node_modules/@theia/plugin-ext/src/main/browser/style/index.css");
__webpack_require__(/*! ../../../src/main/browser/style/comments.css */ "../../node_modules/@theia/plugin-ext/src/main/browser/style/comments.css");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../../node_modules/@theia/core/lib/common/index.js");
const messaging_1 = __webpack_require__(/*! @theia/core/lib/browser/messaging */ "../../node_modules/@theia/core/lib/browser/messaging/index.js");
const hosted_plugin_1 = __webpack_require__(/*! ../../hosted/browser/hosted-plugin */ "../../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin.js");
const hosted_plugin_watcher_1 = __webpack_require__(/*! ../../hosted/browser/hosted-plugin-watcher */ "../../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin-watcher.js");
const commands_1 = __webpack_require__(/*! ./commands */ "../../node_modules/@theia/plugin-ext/lib/main/browser/commands.js");
const plugin_frontend_contribution_1 = __webpack_require__(/*! ./plugin-frontend-contribution */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-frontend-contribution.js");
const plugin_protocol_1 = __webpack_require__(/*! ../../common/plugin-protocol */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-protocol.js");
const modal_notification_1 = __webpack_require__(/*! ./dialogs/modal-notification */ "../../node_modules/@theia/plugin-ext/lib/main/browser/dialogs/modal-notification.js");
const plugin_ext_widget_1 = __webpack_require__(/*! ./plugin-ext-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-ext-widget.js");
const plugin_frontend_view_contribution_1 = __webpack_require__(/*! ./plugin-frontend-view-contribution */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-frontend-view-contribution.js");
const text_editor_model_service_1 = __webpack_require__(/*! ./text-editor-model-service */ "../../node_modules/@theia/plugin-ext/lib/main/browser/text-editor-model-service.js");
const menus_contribution_handler_1 = __webpack_require__(/*! ./menus/menus-contribution-handler */ "../../node_modules/@theia/plugin-ext/lib/main/browser/menus/menus-contribution-handler.js");
const plugin_contribution_handler_1 = __webpack_require__(/*! ./plugin-contribution-handler */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-contribution-handler.js");
const plugin_view_registry_1 = __webpack_require__(/*! ./view/plugin-view-registry */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-registry.js");
const workspace_main_1 = __webpack_require__(/*! ./workspace-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/workspace-main.js");
const plugin_ext_api_contribution_1 = __webpack_require__(/*! ../../common/plugin-ext-api-contribution */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-ext-api-contribution.js");
const plugin_paths_protocol_1 = __webpack_require__(/*! ../common/plugin-paths-protocol */ "../../node_modules/@theia/plugin-ext/lib/main/common/plugin-paths-protocol.js");
const keybindings_contribution_handler_1 = __webpack_require__(/*! ./keybindings/keybindings-contribution-handler */ "../../node_modules/@theia/plugin-ext/lib/main/browser/keybindings/keybindings-contribution-handler.js");
const debug_session_contribution_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-session-contribution */ "../../node_modules/@theia/debug/lib/browser/debug-session-contribution.js");
const plugin_debug_session_contribution_registry_1 = __webpack_require__(/*! ./debug/plugin-debug-session-contribution-registry */ "../../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-session-contribution-registry.js");
const plugin_debug_service_1 = __webpack_require__(/*! ./debug/plugin-debug-service */ "../../node_modules/@theia/plugin-ext/lib/main/browser/debug/plugin-debug-service.js");
const debug_service_1 = __webpack_require__(/*! @theia/debug/lib/common/debug-service */ "../../node_modules/@theia/debug/lib/common/debug-service.js");
const plugin_shared_style_1 = __webpack_require__(/*! ./plugin-shared-style */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-shared-style.js");
const selection_provider_command_1 = __webpack_require__(/*! ./selection-provider-command */ "../../node_modules/@theia/plugin-ext/lib/main/browser/selection-provider-command.js");
const view_context_key_service_1 = __webpack_require__(/*! ./view/view-context-key-service */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/view-context-key-service.js");
const plugin_view_widget_1 = __webpack_require__(/*! ./view/plugin-view-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-widget.js");
const tree_view_widget_1 = __webpack_require__(/*! ./view/tree-view-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/tree-view-widget.js");
const rpc_protocol_1 = __webpack_require__(/*! ../../common/rpc-protocol */ "../../node_modules/@theia/plugin-ext/lib/common/rpc-protocol.js");
const common_2 = __webpack_require__(/*! ../../common */ "../../node_modules/@theia/plugin-ext/lib/common/index.js");
const languages_main_1 = __webpack_require__(/*! ./languages-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/languages-main.js");
const output_channel_registry_main_1 = __webpack_require__(/*! ./output-channel-registry-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/output-channel-registry-main.js");
const webview_1 = __webpack_require__(/*! ./webview/webview */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview.js");
const webview_environment_1 = __webpack_require__(/*! ./webview/webview-environment */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-environment.js");
const webview_theme_data_provider_1 = __webpack_require__(/*! ./webview/webview-theme-data-provider */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-theme-data-provider.js");
const webview_resource_cache_1 = __webpack_require__(/*! ./webview/webview-resource-cache */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-resource-cache.js");
const plugin_icon_theme_service_1 = __webpack_require__(/*! ./plugin-icon-theme-service */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-icon-theme-service.js");
const plugin_tree_view_node_label_provider_1 = __webpack_require__(/*! ./view/plugin-tree-view-node-label-provider */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-tree-view-node-label-provider.js");
const webview_widget_factory_1 = __webpack_require__(/*! ./webview/webview-widget-factory */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-widget-factory.js");
const comments_service_1 = __webpack_require__(/*! ./comments/comments-service */ "../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-service.js");
const comments_decorator_1 = __webpack_require__(/*! ./comments/comments-decorator */ "../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-decorator.js");
const comments_contribution_1 = __webpack_require__(/*! ./comments/comments-contribution */ "../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-contribution.js");
const comments_context_1 = __webpack_require__(/*! ./comments/comments-context */ "../../node_modules/@theia/plugin-ext/lib/main/browser/comments/comments-context.js");
const plugin_custom_editor_registry_1 = __webpack_require__(/*! ./custom-editors/plugin-custom-editor-registry */ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/plugin-custom-editor-registry.js");
const custom_editor_widget_factory_1 = __webpack_require__(/*! ../browser/custom-editors/custom-editor-widget-factory */ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-widget-factory.js");
const custom_editor_widget_1 = __webpack_require__(/*! ./custom-editors/custom-editor-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-widget.js");
const custom_editor_service_1 = __webpack_require__(/*! ./custom-editors/custom-editor-service */ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-service.js");
const webview_frontend_security_warnings_1 = __webpack_require__(/*! ./webview/webview-frontend-security-warnings */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-frontend-security-warnings.js");
const plugin_authentication_service_1 = __webpack_require__(/*! ./plugin-authentication-service */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-authentication-service.js");
const authentication_service_1 = __webpack_require__(/*! @theia/core/lib/browser/authentication-service */ "../../node_modules/@theia/core/lib/browser/authentication-service.js");
const tree_view_decorator_service_1 = __webpack_require__(/*! ./view/tree-view-decorator-service */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/tree-view-decorator-service.js");
const plugin_menu_command_adapter_1 = __webpack_require__(/*! ./menus/plugin-menu-command-adapter */ "../../node_modules/@theia/plugin-ext/lib/main/browser/menus/plugin-menu-command-adapter.js");
__webpack_require__(/*! ./theme-icon-override */ "../../node_modules/@theia/plugin-ext/lib/main/browser/theme-icon-override.js");
const plugin_icon_service_1 = __webpack_require__(/*! ./plugin-icon-service */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-icon-service.js");
const plugin_terminal_registry_1 = __webpack_require__(/*! ./plugin-terminal-registry */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-terminal-registry.js");
const dnd_file_content_store_1 = __webpack_require__(/*! ./view/dnd-file-content-store */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/dnd-file-content-store.js");
const webview_context_keys_1 = __webpack_require__(/*! ./webview/webview-context-keys */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-context-keys.js");
const language_pack_service_1 = __webpack_require__(/*! ../../common/language-pack-service */ "../../node_modules/@theia/plugin-ext/lib/common/language-pack-service.js");
const tab_bar_toolbar_1 = __webpack_require__(/*! @theia/core/lib/browser/shell/tab-bar-toolbar */ "../../node_modules/@theia/core/lib/browser/shell/tab-bar-toolbar/index.js");
const browser_2 = __webpack_require__(/*! @theia/notebook/lib/browser */ "../../node_modules/@theia/notebook/lib/browser/index.js");
const cell_output_webview_1 = __webpack_require__(/*! ./notebooks/renderers/cell-output-webview */ "../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/renderers/cell-output-webview.js");
const command_registry_main_1 = __webpack_require__(/*! ./command-registry-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/command-registry-main.js");
const webview_secondary_window_support_1 = __webpack_require__(/*! ./webview/webview-secondary-window-support */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-secondary-window-support.js");
const custom_editor_undo_redo_handler_1 = __webpack_require__(/*! ./custom-editors/custom-editor-undo-redo-handler */ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-undo-redo-handler.js");
const webview_preferences_1 = __webpack_require__(/*! ../common/webview-preferences */ "../../node_modules/@theia/plugin-ext/lib/main/common/webview-preferences.js");
const webview_frontend_preference_contribution_1 = __webpack_require__(/*! ./webview/webview-frontend-preference-contribution */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-frontend-preference-contribution.js");
const plugin_ext_argument_processor_1 = __webpack_require__(/*! ./plugin-ext-argument-processor */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-ext-argument-processor.js");
exports["default"] = new inversify_1.ContainerModule((bind, unbind, isBound, rebind) => {
    bind(languages_main_1.LanguagesMainImpl).toSelf().inTransientScope();
    bind(common_2.LanguagesMainFactory).toFactory(context => (rpc) => {
        const child = context.container.createChild();
        child.bind(rpc_protocol_1.RPCProtocol).toConstantValue(rpc);
        return child.get(languages_main_1.LanguagesMainImpl);
    });
    bind(output_channel_registry_main_1.OutputChannelRegistryMainImpl).toSelf().inTransientScope();
    bind(common_2.OutputChannelRegistryFactory).toFactory(context => () => {
        const child = context.container.createChild();
        return child.get(output_channel_registry_main_1.OutputChannelRegistryMainImpl);
    });
    bind(modal_notification_1.ModalNotification).toSelf().inSingletonScope();
    bind(hosted_plugin_1.HostedPluginSupport).toSelf().inSingletonScope();
    bind(hosted_plugin_watcher_1.HostedPluginWatcher).toSelf().inSingletonScope();
    bind(selection_provider_command_1.SelectionProviderCommandContribution).toSelf().inSingletonScope();
    bind(common_1.CommandContribution).toService(selection_provider_command_1.SelectionProviderCommandContribution);
    bind(commands_1.OpenUriCommandHandler).toSelf().inSingletonScope();
    bind(plugin_frontend_contribution_1.PluginApiFrontendContribution).toSelf().inSingletonScope();
    bind(common_1.CommandContribution).toService(plugin_frontend_contribution_1.PluginApiFrontendContribution);
    bind(tab_bar_toolbar_1.TabBarToolbarContribution).toService(plugin_frontend_contribution_1.PluginApiFrontendContribution);
    bind(text_editor_model_service_1.EditorModelService).toSelf().inSingletonScope();
    bind(browser_1.FrontendApplicationContribution).toDynamicValue(ctx => ({
        onStart() {
            ctx.container.get(hosted_plugin_1.HostedPluginSupport).onStart(ctx.container);
        }
    }));
    bind(plugin_protocol_1.HostedPluginServer).toDynamicValue(ctx => {
        const connection = ctx.container.get(messaging_1.WebSocketConnectionProvider);
        const hostedWatcher = ctx.container.get(hosted_plugin_watcher_1.HostedPluginWatcher);
        return connection.createProxy(plugin_protocol_1.hostedServicePath, hostedWatcher.getHostedPluginClient());
    }).inSingletonScope();
    bind(plugin_paths_protocol_1.PluginPathsService).toDynamicValue(ctx => {
        const connection = ctx.container.get(messaging_1.WebSocketConnectionProvider);
        return connection.createProxy(plugin_paths_protocol_1.pluginPathsServicePath);
    }).inSingletonScope();
    (0, browser_1.bindViewContribution)(bind, plugin_frontend_view_contribution_1.PluginFrontendViewContribution);
    bind(plugin_ext_widget_1.PluginWidget).toSelf();
    bind(browser_1.WidgetFactory).toDynamicValue(ctx => ({
        id: plugin_frontend_view_contribution_1.PluginFrontendViewContribution.PLUGINS_WIDGET_FACTORY_ID,
        createWidget: () => ctx.container.get(plugin_ext_widget_1.PluginWidget)
    }));
    bind(plugin_protocol_1.PluginServer).toDynamicValue(ctx => {
        const provider = ctx.container.get(messaging_1.WebSocketConnectionProvider);
        return provider.createProxy(plugin_protocol_1.pluginServerJsonRpcPath);
    }).inSingletonScope();
    bind(view_context_key_service_1.ViewContextKeyService).toSelf().inSingletonScope();
    (0, tree_view_decorator_service_1.bindTreeViewDecoratorUtilities)(bind);
    bind(plugin_tree_view_node_label_provider_1.PluginTreeViewNodeLabelProvider).toSelf().inSingletonScope();
    bind(browser_1.LabelProviderContribution).toService(plugin_tree_view_node_label_provider_1.PluginTreeViewNodeLabelProvider);
    bind(dnd_file_content_store_1.DnDFileContentStore).toSelf().inSingletonScope();
    bind(browser_1.WidgetFactory).toDynamicValue(({ container }) => ({
        id: plugin_view_registry_1.PLUGIN_VIEW_DATA_FACTORY_ID,
        createWidget: (options) => {
            const props = {
                contextMenuPath: tree_view_widget_1.VIEW_ITEM_CONTEXT_MENU,
                expandOnlyOnExpansionToggleClick: true,
                expansionTogglePadding: 22,
                globalSelection: true,
                leftPadding: 8,
                search: true,
                multiSelect: options.multiSelect
            };
            const child = (0, browser_1.createTreeContainer)(container, {
                props,
                tree: tree_view_widget_1.PluginTree,
                model: tree_view_widget_1.PluginTreeModel,
                widget: tree_view_widget_1.TreeViewWidget,
                decoratorService: tree_view_decorator_service_1.TreeViewDecoratorService
            });
            child.bind(tree_view_widget_1.TreeViewWidgetOptions).toConstantValue(options);
            return child.get(browser_1.TreeWidget);
        }
    })).inSingletonScope();
    (0, webview_preferences_1.bindWebviewPreferences)(bind);
    bind(webview_frontend_preference_contribution_1.WebviewFrontendPreferenceContribution).toSelf().inSingletonScope();
    bind(common_1.PreferenceContribution).toService(webview_frontend_preference_contribution_1.WebviewFrontendPreferenceContribution);
    bind(webview_environment_1.WebviewEnvironment).toSelf().inSingletonScope();
    bind(webview_theme_data_provider_1.WebviewThemeDataProvider).toSelf().inSingletonScope();
    bind(webview_resource_cache_1.WebviewResourceCache).toSelf().inSingletonScope();
    bind(webview_1.WebviewWidget).toSelf();
    bind(webview_widget_factory_1.WebviewWidgetFactory).toDynamicValue(ctx => new webview_widget_factory_1.WebviewWidgetFactory(ctx.container)).inSingletonScope();
    bind(browser_1.WidgetFactory).toService(webview_widget_factory_1.WebviewWidgetFactory);
    bind(webview_context_keys_1.WebviewContextKeys).toSelf().inSingletonScope();
    bind(webview_secondary_window_support_1.WebviewSecondaryWindowSupport).toSelf().inSingletonScope();
    bind(browser_1.FrontendApplicationContribution).toService(webview_secondary_window_support_1.WebviewSecondaryWindowSupport);
    bind(browser_1.FrontendApplicationContribution).toService(webview_context_keys_1.WebviewContextKeys);
    bind(browser_1.WidgetStatusBarContribution).toConstantValue((0, browser_1.noopWidgetStatusBarContribution)(webview_1.WebviewWidget));
    bind(plugin_custom_editor_registry_1.PluginCustomEditorRegistry).toSelf().inSingletonScope();
    bind(custom_editor_service_1.CustomEditorService).toSelf().inSingletonScope();
    bind(custom_editor_widget_1.CustomEditorWidget).toSelf();
    bind(custom_editor_widget_factory_1.CustomEditorWidgetFactory).toDynamicValue(ctx => new custom_editor_widget_factory_1.CustomEditorWidgetFactory(ctx.container)).inSingletonScope();
    bind(browser_1.WidgetFactory).toService(custom_editor_widget_factory_1.CustomEditorWidgetFactory);
    bind(custom_editor_undo_redo_handler_1.CustomEditorUndoRedoHandler).toSelf().inSingletonScope();
    bind(browser_1.UndoRedoHandler).toService(custom_editor_undo_redo_handler_1.CustomEditorUndoRedoHandler);
    bind(browser_1.WidgetFactory).toDynamicValue(ctx => ({
        id: custom_editor_widget_1.CustomEditorWidget.SIDE_BY_SIDE_FACTORY_ID,
        createWidget: (arg) => {
            const uri = new common_1.URI(arg.uri);
            const [leftUri, rightUri] = browser_1.DiffUris.decode(uri);
            const navigatable = {
                getResourceUri: () => rightUri,
                createMoveToUri: resourceUri => browser_1.DiffUris.encode(leftUri, rightUri.withPath(resourceUri.path))
            };
            const widget = new browser_1.SplitWidget({ navigatable });
            widget.id = arg.viewType + '.side-by-side:' + (0, common_1.generateUuid)();
            const labelProvider = ctx.container.get(browser_1.LabelProvider);
            widget.title.label = labelProvider.getName(uri);
            widget.title.iconClass = labelProvider.getIcon(uri);
            widget.title.closable = true;
            return widget;
        }
    })).inSingletonScope();
    bind(plugin_view_widget_1.PluginViewWidget).toSelf();
    bind(browser_1.WidgetFactory).toDynamicValue(({ container }) => ({
        id: plugin_view_registry_1.PLUGIN_VIEW_FACTORY_ID,
        createWidget: (identifier) => {
            const child = container.createChild();
            child.bind(plugin_view_widget_1.PluginViewWidgetIdentifier).toConstantValue(identifier);
            return child.get(plugin_view_widget_1.PluginViewWidget);
        }
    })).inSingletonScope();
    bind(browser_1.WidgetFactory).toDynamicValue(({ container }) => ({
        id: plugin_view_registry_1.PLUGIN_VIEW_CONTAINER_FACTORY_ID,
        createWidget: (identifier) => container.get(browser_1.ViewContainer.Factory)(identifier)
    })).inSingletonScope();
    bind(plugin_shared_style_1.PluginSharedStyle).toSelf().inSingletonScope();
    bind(plugin_view_registry_1.PluginViewRegistry).toSelf().inSingletonScope();
    bind(browser_1.FrontendApplicationContribution).toService(plugin_view_registry_1.PluginViewRegistry);
    bind(plugin_icon_theme_service_1.PluginIconThemeFactory).toFactory(({ container }) => (definition) => {
        const child = container.createChild();
        child.bind(plugin_icon_theme_service_1.PluginIconThemeDefinition).toConstantValue(definition);
        child.bind(plugin_icon_theme_service_1.PluginIconTheme).toSelf().inSingletonScope();
        return child.get(plugin_icon_theme_service_1.PluginIconTheme);
    });
    bind(plugin_icon_theme_service_1.PluginIconThemeService).toSelf().inSingletonScope();
    bind(browser_1.LabelProviderContribution).toService(plugin_icon_theme_service_1.PluginIconThemeService);
    bind(menus_contribution_handler_1.MenusContributionPointHandler).toSelf().inSingletonScope();
    bind(plugin_menu_command_adapter_1.PluginMenuCommandAdapter).toSelf().inSingletonScope();
    bind(keybindings_contribution_handler_1.KeybindingsContributionPointHandler).toSelf().inSingletonScope();
    bind(plugin_contribution_handler_1.PluginContributionHandler).toSelf().inSingletonScope();
    bind(workspace_main_1.TextContentResourceResolver).toSelf().inSingletonScope();
    bind(common_1.ResourceResolver).toService(workspace_main_1.TextContentResourceResolver);
    (0, common_1.bindContributionProvider)(bind, plugin_ext_api_contribution_1.MainPluginApiProvider);
    bind(plugin_debug_service_1.PluginDebugService).toSelf().inSingletonScope();
    rebind(debug_service_1.DebugService).toService(plugin_debug_service_1.PluginDebugService);
    bind(plugin_debug_session_contribution_registry_1.PluginDebugSessionContributionRegistry).toSelf().inSingletonScope();
    rebind(debug_session_contribution_1.DebugSessionContributionRegistry).toService(plugin_debug_session_contribution_registry_1.PluginDebugSessionContributionRegistry);
    bind(comments_service_1.CommentsService).to(comments_service_1.PluginCommentService).inSingletonScope();
    bind(comments_decorator_1.CommentingRangeDecorator).toSelf().inSingletonScope();
    bind(comments_contribution_1.CommentsContribution).toSelf().inSingletonScope();
    bind(comments_context_1.CommentsContext).toSelf().inSingletonScope();
    bind(webview_frontend_security_warnings_1.WebviewFrontendSecurityWarnings).toSelf().inSingletonScope();
    bind(browser_1.FrontendApplicationContribution).toService(webview_frontend_security_warnings_1.WebviewFrontendSecurityWarnings);
    bind(plugin_icon_service_1.PluginIconService).toSelf().inSingletonScope();
    bind(browser_1.FrontendApplicationContribution).toService(plugin_icon_service_1.PluginIconService);
    bind(plugin_authentication_service_1.PluginAuthenticationServiceImpl).toSelf().inSingletonScope();
    rebind(authentication_service_1.AuthenticationService).toService(plugin_authentication_service_1.PluginAuthenticationServiceImpl);
    bind(plugin_terminal_registry_1.PluginTerminalRegistry).toSelf().inSingletonScope();
    bind(language_pack_service_1.LanguagePackService).toDynamicValue(ctx => {
        const provider = ctx.container.get(messaging_1.WebSocketConnectionProvider);
        return provider.createProxy(language_pack_service_1.languagePackServicePath);
    }).inSingletonScope();
    bind(browser_2.CellOutputWebviewFactory).toFactory(ctx => () => (0, cell_output_webview_1.createCellOutputWebviewContainer)(ctx.container).get(cell_output_webview_1.CellOutputWebviewImpl));
    (0, common_1.bindContributionProvider)(bind, command_registry_main_1.ArgumentProcessorContribution);
    bind(plugin_ext_argument_processor_1.PluginExtToolbarItemArgumentProcessor).toSelf().inSingletonScope();
    bind(command_registry_main_1.ArgumentProcessorContribution).toService(plugin_ext_argument_processor_1.PluginExtToolbarItemArgumentProcessor);
});


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-ext-widget.js"
/*!**********************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-ext-widget.js ***!
  \**********************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginWidget = exports.PLUGINS_LABEL = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../../node_modules/@theia/core/shared/react/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const react_widget_1 = __webpack_require__(/*! @theia/core/lib/browser/widgets/react-widget */ "../../node_modules/@theia/core/lib/browser/widgets/react-widget.js");
const alert_message_1 = __webpack_require__(/*! @theia/core/lib/browser/widgets/alert-message */ "../../node_modules/@theia/core/lib/browser/widgets/alert-message.js");
const hosted_plugin_1 = __webpack_require__(/*! ../../hosted/browser/hosted-plugin */ "../../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin.js");
const progress_bar_factory_1 = __webpack_require__(/*! @theia/core/lib/browser/progress-bar-factory */ "../../node_modules/@theia/core/lib/browser/progress-bar-factory.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../../node_modules/@theia/core/lib/common/index.js");
exports.PLUGINS_LABEL = common_1.nls.localize('theia/plugin-ext/plugins', 'Plugins');
let PluginWidget = class PluginWidget extends react_widget_1.ReactWidget {
    constructor() {
        super();
        this.toDisposeProgress = new disposable_1.DisposableCollection();
        this.id = 'plugins';
        this.title.label = exports.PLUGINS_LABEL;
        this.title.caption = exports.PLUGINS_LABEL;
        this.title.iconClass = (0, browser_1.codicon)('diff-added');
        this.title.closable = true;
        this.node.tabIndex = 0;
        this.addClass('theia-plugins');
        this.update();
    }
    init() {
        this.toDispose.push(this.pluginService.onDidChangePlugins(() => this.update()));
    }
    onActivateRequest(msg) {
        super.onActivateRequest(msg);
        this.node.focus();
    }
    render() {
        return React.createElement("div", { ref: ref => {
                this.toDisposeProgress.dispose();
                this.toDispose.push(this.toDisposeProgress);
                if (ref) {
                    this.toDispose.push(this.progressBarFactory({ container: this.node, insertMode: 'prepend', locationId: hosted_plugin_1.PluginProgressLocation }));
                }
            } }, this.doRender());
    }
    doRender() {
        const plugins = this.pluginService.plugins;
        if (!plugins.length) {
            return React.createElement(alert_message_1.AlertMessage, { type: 'INFO', header: 'No plugins currently available.' });
        }
        return React.createElement(React.Fragment, null, this.renderPlugins(plugins));
    }
    renderPlugins(plugins) {
        return React.createElement("div", { id: 'pluginListContainer' }, plugins.sort((a, b) => this.compareMetadata(a, b)).map(plugin => this.renderPlugin(plugin)));
    }
    renderPlugin(plugin) {
        return React.createElement("div", { key: plugin.model.name, className: this.createPluginClassName(plugin) },
            React.createElement("div", { className: 'column flexcontainer pluginInformationContainer' },
                React.createElement("div", { className: 'row flexcontainer' },
                    React.createElement("div", { className: (0, browser_1.codicon)('list-selection') }),
                    React.createElement("div", { title: plugin.model.name, className: 'pluginName noWrapInfo' }, plugin.model.name)),
                React.createElement("div", { className: 'row flexcontainer' },
                    React.createElement("div", { className: 'pluginVersion' }, plugin.model.version)),
                React.createElement("div", { className: 'row flexcontainer' },
                    React.createElement("div", { className: 'pluginDescription noWrapInfo' }, plugin.model.description)),
                React.createElement("div", { className: 'row flexcontainer' },
                    React.createElement("div", { className: 'pluginPublisher noWrapInfo flexcontainer' }, plugin.model.publisher))));
    }
    createPluginClassName(plugin) {
        const classNames = ['pluginHeaderContainer'];
        return classNames.join(' ');
    }
    /**
     * Compare two plugins based on their names, and publishers.
     * @param a the first plugin metadata.
     * @param b the second plugin metadata.
     */
    compareMetadata(a, b) {
        // Determine the name of the plugins.
        const nameA = a.model.name.toLowerCase();
        const nameB = b.model.name.toLowerCase();
        // Determine the publisher of the plugin (when names are equal).
        const publisherA = a.model.publisher.toLowerCase();
        const publisherB = b.model.publisher.toLowerCase();
        return (nameA === nameA)
            ? nameA.localeCompare(nameB)
            : publisherA.localeCompare(publisherB);
    }
};
exports.PluginWidget = PluginWidget;
tslib_1.__decorate([
    (0, inversify_1.inject)(hosted_plugin_1.HostedPluginSupport),
    tslib_1.__metadata("design:type", hosted_plugin_1.HostedPluginSupport)
], PluginWidget.prototype, "pluginService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(progress_bar_factory_1.ProgressBarFactory),
    tslib_1.__metadata("design:type", Function)
], PluginWidget.prototype, "progressBarFactory", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], PluginWidget.prototype, "init", null);
exports.PluginWidget = PluginWidget = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], PluginWidget);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-frontend-contribution.js"
/*!*********************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-frontend-contribution.js ***!
  \*********************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var PluginApiFrontendContribution_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginApiFrontendContribution = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../../node_modules/@theia/core/lib/common/index.js");
const commands_1 = __webpack_require__(/*! ./commands */ "../../node_modules/@theia/plugin-ext/lib/main/browser/commands.js");
const tree_view_widget_1 = __webpack_require__(/*! ./view/tree-view-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/tree-view-widget.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const plugin_view_widget_1 = __webpack_require__(/*! ./view/plugin-view-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-widget.js");
let PluginApiFrontendContribution = PluginApiFrontendContribution_1 = class PluginApiFrontendContribution {
    registerCommands(commands) {
        commands.registerCommand(commands_1.OpenUriCommandHandler.COMMAND_METADATA, {
            execute: (arg) => this.openUriCommandHandler.execute(arg),
            isVisible: () => false
        });
        commands.registerCommand(PluginApiFrontendContribution_1.COLLAPSE_ALL_COMMAND, {
            execute: (widget) => {
                if (widget instanceof plugin_view_widget_1.PluginViewWidget && widget.widgets[0] instanceof tree_view_widget_1.TreeViewWidget) {
                    const model = widget.widgets[0].model;
                    if (browser_1.CompositeTreeNode.is(model.root)) {
                        for (const child of model.root.children) {
                            if (browser_1.CompositeTreeNode.is(child)) {
                                model.collapseAll(child);
                            }
                        }
                    }
                }
            },
            isVisible: (widget) => widget instanceof plugin_view_widget_1.PluginViewWidget && widget.widgets[0] instanceof tree_view_widget_1.TreeViewWidget && widget.widgets[0].showCollapseAll
        });
    }
    registerToolbarItems(registry) {
        registry.registerItem({
            id: PluginApiFrontendContribution_1.COLLAPSE_ALL_COMMAND.id,
            command: PluginApiFrontendContribution_1.COLLAPSE_ALL_COMMAND.id,
            tooltip: PluginApiFrontendContribution_1.COLLAPSE_ALL_COMMAND.label,
            icon: PluginApiFrontendContribution_1.COLLAPSE_ALL_COMMAND.iconClass,
            priority: 1000
        });
    }
};
exports.PluginApiFrontendContribution = PluginApiFrontendContribution;
PluginApiFrontendContribution.COLLAPSE_ALL_COMMAND = common_1.Command.toDefaultLocalizedCommand({
    id: 'treeviews.collapseAll',
    iconClass: (0, browser_1.codicon)('collapse-all'),
    label: 'Collapse All'
});
tslib_1.__decorate([
    (0, inversify_1.inject)(commands_1.OpenUriCommandHandler),
    tslib_1.__metadata("design:type", commands_1.OpenUriCommandHandler)
], PluginApiFrontendContribution.prototype, "openUriCommandHandler", void 0);
exports.PluginApiFrontendContribution = PluginApiFrontendContribution = PluginApiFrontendContribution_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginApiFrontendContribution);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-frontend-view-contribution.js"
/*!**************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-frontend-view-contribution.js ***!
  \**************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var PluginFrontendViewContribution_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginFrontendViewContribution = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const view_contribution_1 = __webpack_require__(/*! @theia/core/lib/browser/shell/view-contribution */ "../../node_modules/@theia/core/lib/browser/shell/view-contribution.js");
const plugin_ext_widget_1 = __webpack_require__(/*! ./plugin-ext-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-ext-widget.js");
let PluginFrontendViewContribution = PluginFrontendViewContribution_1 = class PluginFrontendViewContribution extends view_contribution_1.AbstractViewContribution {
    constructor() {
        super({
            widgetId: PluginFrontendViewContribution_1.PLUGINS_WIDGET_FACTORY_ID,
            widgetName: plugin_ext_widget_1.PLUGINS_LABEL,
            defaultWidgetOptions: {
                area: 'left',
                rank: 400
            },
            toggleCommandId: 'pluginsView:toggle'
        });
    }
};
exports.PluginFrontendViewContribution = PluginFrontendViewContribution;
PluginFrontendViewContribution.PLUGINS_WIDGET_FACTORY_ID = 'plugins';
exports.PluginFrontendViewContribution = PluginFrontendViewContribution = PluginFrontendViewContribution_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], PluginFrontendViewContribution);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-icon-service.js"
/*!************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-icon-service.js ***!
  \************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginIconService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../../node_modules/@theia/core/shared/vscode-uri/index.js");
const monaco_icon_registry_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-icon-registry */ "../../node_modules/@theia/monaco/lib/browser/monaco-icon-registry.js");
const path = __webpack_require__(/*! path */ "../../node_modules/path-browserify/index.js");
const plugin_protocol_1 = __webpack_require__(/*! ../../common/plugin-protocol */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-protocol.js");
let PluginIconService = class PluginIconService {
    constructor() {
        this.toDispose = new disposable_1.DisposableCollection();
        this.styleSheet = '';
    }
    register(contribution, plugin) {
        const defaultIcon = contribution.defaults;
        if (plugin_protocol_1.IconContribution.isIconDefinition(defaultIcon)) {
            this.registerFontIcon(contribution, defaultIcon);
        }
        else {
            this.registerRegularIcon(contribution, defaultIcon.id);
        }
        return disposable_1.Disposable.NULL;
    }
    dispose() {
        this.toDispose.dispose();
    }
    registerFontIcon(contribution, defaultIcon) {
        const location = this.toPluginUrl(contribution.extensionId, getIconRelativePath(vscode_uri_1.URI.parse(defaultIcon.location).path));
        const format = getFileExtension(location.path);
        const fontId = getFontId(contribution.extensionId, location.path);
        const definition = this.iconRegistry.registerIconFont(fontId, { src: [{ location: location, format }] });
        this.iconRegistry.registerIcon(contribution.id, {
            fontCharacter: defaultIcon.fontCharacter,
            font: {
                id: fontId,
                definition
            }
        }, contribution.description);
    }
    registerRegularIcon(contribution, defaultIconId) {
        this.iconRegistry.registerIcon(contribution.id, { id: defaultIconId }, contribution.description);
    }
    toPluginUrl(id, relativePath) {
        return vscode_uri_1.URI.from(new browser_1.Endpoint({
            path: `hostedPlugin/${this.formatExtensionId(id)}/${encodeURIComponent(relativePath)}`
        }).getRestUrl().toComponents());
    }
    formatExtensionId(id) {
        return id.replace(/\W/g, '_');
    }
};
exports.PluginIconService = PluginIconService;
tslib_1.__decorate([
    (0, inversify_1.inject)(monaco_icon_registry_1.MonacoIconRegistry),
    tslib_1.__metadata("design:type", monaco_icon_registry_1.MonacoIconRegistry)
], PluginIconService.prototype, "iconRegistry", void 0);
exports.PluginIconService = PluginIconService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginIconService);
function getIconRelativePath(iconPath) {
    const index = iconPath.indexOf('extension');
    return index === -1 ? '' : iconPath.substring(index + 'extension'.length + 1);
}
function getFontId(extensionId, fontPath) {
    return path.join(extensionId, fontPath);
}
function getFileExtension(filePath) {
    const index = filePath.lastIndexOf('.');
    return index === -1 ? '' : filePath.substring(index + 1);
}


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-icon-theme-service.js"
/*!******************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-icon-theme-service.js ***!
  \******************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code is copied and modified from:
// https://github.com/microsoft/vscode/blob/7cf4cca47aa025a590fc939af54932042302be63/src/vs/workbench/services/themes/browser/fileIconThemeData.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginIconThemeService = exports.PluginIconTheme = exports.PluginIconThemeDefinition = exports.PluginIconThemeFactory = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const debounce = __webpack_require__(/*! @theia/core/shared/lodash.debounce */ "../../node_modules/@theia/core/shared/lodash.debounce/index.js");
const jsoncparser = __webpack_require__(/*! jsonc-parser */ "../../node_modules/jsonc-parser/lib/esm/main.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const icon_theme_service_1 = __webpack_require__(/*! @theia/core/lib/browser/icon-theme-service */ "../../node_modules/@theia/core/lib/browser/icon-theme-service.js");
const plugin_protocol_1 = __webpack_require__(/*! ../../common/plugin-protocol */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-protocol.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../../node_modules/@theia/core/lib/common/uri.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../node_modules/@theia/core/lib/common/event.js");
const label_provider_1 = __webpack_require__(/*! @theia/core/lib/browser/label-provider */ "../../node_modules/@theia/core/lib/browser/label-provider.js");
const browser_1 = __webpack_require__(/*! @theia/filesystem/lib/browser */ "../../node_modules/@theia/filesystem/lib/browser/index.js");
const navigator_tree_1 = __webpack_require__(/*! @theia/navigator/lib/browser/navigator-tree */ "../../node_modules/@theia/navigator/lib/browser/navigator-tree.js");
const endpoint_1 = __webpack_require__(/*! @theia/core/lib/browser/endpoint */ "../../node_modules/@theia/core/lib/browser/endpoint.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../../node_modules/@theia/filesystem/lib/browser/file-service.js");
const files_1 = __webpack_require__(/*! @theia/filesystem/lib/common/files */ "../../node_modules/@theia/filesystem/lib/common/files.js");
const browser_2 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../../node_modules/@theia/workspace/lib/browser/index.js");
const standaloneServices_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices */ "../../node_modules/@theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices.js");
const language_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/common/languages/language */ "../../node_modules/@theia/monaco-editor-core/esm/vs/editor/common/languages/language.js");
const language_service_1 = __webpack_require__(/*! @theia/core/lib/browser/language-service */ "../../node_modules/@theia/core/lib/browser/language-service.js");
const plugin_shared_style_1 = __webpack_require__(/*! ./plugin-shared-style */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-shared-style.js");
exports.PluginIconThemeFactory = Symbol('PluginIconThemeFactory');
let PluginIconThemeDefinition = class PluginIconThemeDefinition {
};
exports.PluginIconThemeDefinition = PluginIconThemeDefinition;
exports.PluginIconThemeDefinition = PluginIconThemeDefinition = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginIconThemeDefinition);
class PluginLanguageIconInfo {
    constructor() {
        this.hasSpecificFileIcons = false;
        this.coveredLanguages = {};
    }
}
;
let PluginIconTheme = class PluginIconTheme extends PluginIconThemeDefinition {
    constructor() {
        super(...arguments);
        this.onDidChangeEmitter = new event_1.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
        this.toDeactivate = new disposable_1.DisposableCollection();
        this.toUnload = new disposable_1.DisposableCollection();
        this.toDisposeStyleElement = new disposable_1.DisposableCollection();
        this.toDispose = new disposable_1.DisposableCollection(this.toDeactivate, this.toDisposeStyleElement, this.toUnload, this.onDidChangeEmitter);
        this.icons = new Set();
        this.reload = debounce(() => {
            this.toUnload.dispose();
            this.doActivate();
        }, 50);
        this.fileIcon = plugin_shared_style_1.PLUGIN_FILE_ICON_CLASS;
        this.folderIcon = 'theia-plugin-folder-icon';
        this.folderExpandedIcon = 'theia-plugin-folder-expanded-icon';
        this.rootFolderIcon = 'theia-plugin-root-folder-icon';
        this.rootFolderExpandedIcon = 'theia-plugin-root-folder-expanded-icon';
    }
    init() {
        Object.assign(this, this.definition);
        this.packageRootUri = new uri_1.default(this.packageUri);
        this.locationUri = new uri_1.default(this.uri).parent;
    }
    dispose() {
        this.toDispose.dispose();
    }
    fireDidChange() {
        this.onDidChangeEmitter.fire({ affects: () => true });
    }
    activate() {
        if (!this.toDeactivate.disposed) {
            return this.toDeactivate;
        }
        this.toDeactivate.push(disposable_1.Disposable.create(() => this.fireDidChange()));
        this.doActivate();
        return this.toDeactivate;
    }
    async doActivate() {
        await this.load();
        this.updateStyleElement();
    }
    updateStyleElement() {
        this.toDisposeStyleElement.dispose();
        if (this.toDeactivate.disposed || !this.styleSheetContent) {
            return;
        }
        const styleElement = document.createElement('style');
        styleElement.type = 'text/css';
        styleElement.className = 'theia-icon-theme';
        styleElement.innerText = this.styleSheetContent;
        document.head.appendChild(styleElement);
        const toRemoveStyleElement = disposable_1.Disposable.create(() => styleElement.remove());
        this.toDisposeStyleElement.push(toRemoveStyleElement);
        this.toDeactivate.push(toRemoveStyleElement);
        this.fireDidChange();
    }
    /**
     * This should be aligned with
     * https://github.com/microsoft/vscode/blob/7cf4cca47aa025a590fc939af54932042302be63/src/vs/workbench/services/themes/browser/fileIconThemeData.ts#L201
     */
    async load() {
        if (this.styleSheetContent !== undefined) {
            return;
        }
        this.styleSheetContent = '';
        this.toUnload.push(disposable_1.Disposable.create(() => {
            this.styleSheetContent = undefined;
            this.hasFileIcons = undefined;
            this.hasFolderIcons = undefined;
            this.hidesExplorerArrows = undefined;
            this.icons.clear();
        }));
        const uri = new uri_1.default(this.uri);
        const result = await this.fileService.read(uri);
        const content = result.value;
        const json = jsoncparser.parse(content, undefined, { disallowComments: false });
        this.hidesExplorerArrows = !!json.hidesExplorerArrows;
        const toUnwatch = this.fileService.watch(uri);
        if (this.toUnload.disposed) {
            toUnwatch.dispose();
        }
        else {
            this.toUnload.push(toUnwatch);
            this.toUnload.push(this.fileService.onDidFilesChange(e => {
                if (e.contains(uri, 1 /* FileChangeType.ADDED */) || e.contains(uri, 0 /* FileChangeType.UPDATED */)) {
                    this.reload();
                }
            }));
        }
        const iconDefinitions = json.iconDefinitions;
        if (!iconDefinitions) {
            return;
        }
        const definitionSelectors = new Map();
        const acceptSelector = (themeType, definitionId, ...icons) => {
            if (!iconDefinitions[definitionId]) {
                return;
            }
            let selector = '';
            for (const icon of icons) {
                if (icon) {
                    selector += '.' + icon;
                    this.icons.add(icon);
                }
            }
            if (!selector) {
                return;
            }
            const selectors = definitionSelectors.get(definitionId) || [];
            if (themeType !== 'dark') {
                selector = '.theia-' + themeType + ' ' + selector;
            }
            selectors.push(selector + '::before');
            definitionSelectors.set(definitionId, selectors);
        };
        let iconInfo = this.collectSelectors(json, acceptSelector.bind(undefined, 'dark'));
        if (json.light) {
            iconInfo = this.collectSelectors(json.light, acceptSelector.bind(undefined, 'light'));
        }
        if (json.highContrast) {
            iconInfo = this.collectSelectors(json.highContrast, acceptSelector.bind(undefined, 'hc'));
        }
        const showLanguageModeIcons = this.showLanguageModeIcons === true
            || json.showLanguageModeIcons === true
            || (iconInfo.hasSpecificFileIcons && json.showLanguageModeIcons !== false);
        const fonts = json.fonts;
        if (Array.isArray(fonts)) {
            for (const font of fonts) {
                if (font) {
                    let src = '';
                    if (Array.isArray(font.src)) {
                        for (const srcLocation of font.src) {
                            if (srcLocation && srcLocation.path) {
                                const cssUrl = this.toCSSUrl(srcLocation.path);
                                if (cssUrl) {
                                    if (src) {
                                        src += ', ';
                                    }
                                    src += `${cssUrl} format('${srcLocation.format}')`;
                                }
                            }
                        }
                    }
                    if (src) {
                        this.styleSheetContent += `@font-face {
    src: ${src};
    font-family: '${font.id}';
    font-weight: ${font.weight};
    font-style: ${font.style};
}
`;
                    }
                }
            }
            const firstFont = fonts[0];
            if (firstFont && firstFont.id) {
                this.styleSheetContent += `.${this.fileIcon}::before, .${this.folderIcon}::before, .${this.rootFolderIcon}::before {
    font-family: '${firstFont.id}';
    font-size: ${firstFont.size || '150%'};
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    vertical-align: top;
}
`;
            }
        }
        for (const definitionId of definitionSelectors.keys()) {
            const iconDefinition = iconDefinitions[definitionId];
            const selectors = definitionSelectors.get(definitionId);
            if (selectors && iconDefinition) {
                const cssUrl = this.toCSSUrl(iconDefinition.iconPath);
                if (cssUrl) {
                    this.styleSheetContent += `${selectors.join(', ')} {
    content: ' ';
    background-image: ${cssUrl};
    background-size: ${plugin_shared_style_1.DEFAULT_ICON_SIZE}px;
    background-position: left center;
    background-repeat: no-repeat;
}
`;
                }
                if (iconDefinition.fontCharacter || iconDefinition.fontColor) {
                    let body = '';
                    if (iconDefinition.fontColor) {
                        body += ` color: ${iconDefinition.fontColor};`;
                    }
                    if (iconDefinition.fontCharacter) {
                        body += ` content: '${iconDefinition.fontCharacter}';`;
                    }
                    if (iconDefinition.fontSize) {
                        body += ` font-size: ${iconDefinition.fontSize};`;
                    }
                    if (iconDefinition.fontId) {
                        body += ` font-family: ${iconDefinition.fontId};`;
                    }
                    this.styleSheetContent += `${selectors.join(', ')} {${body} }\n`;
                }
            }
        }
        if (showLanguageModeIcons) {
            for (const language of this.languageService.languages) {
                // only show language icons if there are no more specific icons in the style document
                if (!iconInfo.coveredLanguages[language.id]) {
                    const icon = this.languageService.getIcon(language.id);
                    if (icon) {
                        this.icons.add(this.fileIcon);
                        this.icons.add(this.languageIcon(language.id));
                        this.icons.add(icon);
                    }
                }
            }
        }
    }
    toCSSUrl(iconPath) {
        if (!iconPath) {
            return undefined;
        }
        const iconUri = this.locationUri.resolve(iconPath);
        const relativePath = this.packageRootUri.path.relative(iconUri.path.normalize());
        return relativePath && `url('${new endpoint_1.Endpoint({
            path: `hostedPlugin/${this.pluginId}/${encodeURIComponent(relativePath.normalize().toString())}`
        }).getRestUrl().toString()}')`;
    }
    escapeCSS(value) {
        value = value.replace(/[^\-a-zA-Z0-9]/g, '-');
        if (value.charAt(0).match(/[0-9\-]/)) {
            value = '-' + value;
        }
        return value;
    }
    folderNameIcon(folderName) {
        return 'theia-plugin-' + this.escapeCSS(folderName.toLowerCase()) + '-folder-name-icon';
    }
    expandedFolderNameIcon(folderName) {
        return 'theia-plugin-' + this.escapeCSS(folderName.toLowerCase()) + '-expanded-folder-name-icon';
    }
    fileNameIcon(fileName) {
        fileName = fileName.toLowerCase();
        const extIndex = fileName.indexOf('.');
        const icons = extIndex !== -1 ? this.fileExtensionIcon(fileName.substring(extIndex + 1)) : [];
        icons.unshift('theia-plugin-' + this.escapeCSS(fileName) + '-file-name-icon');
        return icons;
    }
    fileExtensionIcon(fileExtension) {
        fileExtension = fileExtension.toString();
        const icons = [];
        const segments = fileExtension.split('.');
        if (segments.length) {
            if (segments.length) {
                for (let i = 0; i < segments.length; i++) {
                    icons.push('theia-plugin-' + this.escapeCSS(segments.slice(i).join('.')) + '-ext-file-icon');
                }
                icons.push('theia-plugin-ext-file-icon'); // extra segment to increase file-ext score
            }
        }
        return icons;
    }
    languageIcon(languageId) {
        return 'theia-plugin-' + this.escapeCSS(languageId) + '-lang-file-icon';
    }
    collectSelectors(associations, accept) {
        const iconInfo = new PluginLanguageIconInfo();
        if (associations.folder) {
            accept(associations.folder, this.folderIcon);
            if (associations.folderExpanded === undefined) {
                // Use the same icon for expanded state (issue #12727). Check for
                // undefined folderExpanded property to allow for
                // "folderExpanded": null in case a developer really wants that
                accept(associations.folder, this.folderExpandedIcon);
            }
            this.hasFolderIcons = true;
        }
        if (associations.folderExpanded) {
            accept(associations.folderExpanded, this.folderExpandedIcon);
            this.hasFolderIcons = true;
        }
        const rootFolder = associations.rootFolder || associations.folder;
        if (rootFolder) {
            accept(rootFolder, this.rootFolderIcon);
            this.hasFolderIcons = true;
        }
        const rootFolderExpanded = associations.rootFolderExpanded || associations.folderExpanded;
        if (rootFolderExpanded) {
            accept(rootFolderExpanded, this.rootFolderExpandedIcon);
            this.hasFolderIcons = true;
        }
        if (associations.file) {
            accept(associations.file, this.fileIcon);
            this.hasFileIcons = true;
        }
        const folderNames = associations.folderNames;
        if (folderNames) {
            // eslint-disable-next-line guard-for-in
            for (const folderName in folderNames) {
                accept(folderNames[folderName], this.folderNameIcon(folderName), this.folderIcon);
                this.hasFolderIcons = true;
            }
        }
        const folderNamesExpanded = associations.folderNamesExpanded;
        if (folderNamesExpanded) {
            // eslint-disable-next-line guard-for-in
            for (const folderName in folderNamesExpanded) {
                accept(folderNamesExpanded[folderName], this.expandedFolderNameIcon(folderName), this.folderExpandedIcon);
                this.hasFolderIcons = true;
            }
        }
        const languageIds = associations.languageIds;
        if (languageIds) {
            if (!languageIds.jsonc && languageIds.json) {
                languageIds.jsonc = languageIds.json;
            }
            // eslint-disable-next-line guard-for-in
            for (const languageId in languageIds) {
                accept(languageIds[languageId], this.languageIcon(languageId), this.fileIcon);
                this.hasFileIcons = true;
                iconInfo.hasSpecificFileIcons = true;
                iconInfo.coveredLanguages[languageId] = true;
            }
        }
        const fileExtensions = associations.fileExtensions;
        if (fileExtensions) {
            // eslint-disable-next-line guard-for-in
            for (const fileExtension in fileExtensions) {
                accept(fileExtensions[fileExtension], ...this.fileExtensionIcon(fileExtension), this.fileIcon);
                this.hasFileIcons = true;
                iconInfo.hasSpecificFileIcons = true;
            }
        }
        const fileNames = associations.fileNames;
        if (fileNames) {
            // eslint-disable-next-line guard-for-in
            for (const fileName in fileNames) {
                accept(fileNames[fileName], ...this.fileNameIcon(fileName), this.fileIcon);
                this.hasFileIcons = true;
                iconInfo.hasSpecificFileIcons = true;
            }
        }
        return iconInfo;
    }
    /**
     * This should be aligned with
     * https://github.com/microsoft/vscode/blob/7cf4cca47aa025a590fc939af54932042302be63/src/vs/editor/common/services/getIconClasses.ts#L5
     */
    getIcon(element) {
        let icon = '';
        for (const className of this.getClassNames(element)) {
            if (this.icons.has(className)) {
                if (icon) {
                    icon += ' ';
                }
                icon += className;
            }
        }
        return icon;
    }
    getClassNames(element) {
        if (navigator_tree_1.WorkspaceRootNode.is(element)) {
            const name = this.labelProvider.getName(element);
            if (element.expanded) {
                return [this.rootFolderExpandedIcon, this.expandedFolderNameIcon(name)];
            }
            return [this.rootFolderIcon, this.folderNameIcon(name)];
        }
        if (browser_1.DirNode.is(element)) {
            if (element.expanded) {
                const name = this.labelProvider.getName(element);
                return [this.folderExpandedIcon, this.expandedFolderNameIcon(name)];
            }
            return this.getFolderClassNames(element);
        }
        if (browser_1.FileStatNode.is(element)) {
            return this.getFileClassNames(element, element.fileStat.resource.toString());
        }
        if (files_1.FileStat.is(element)) {
            if (element.isDirectory) {
                return this.getFolderClassNames(element);
            }
            return this.getFileClassNames(element, element.resource.toString());
        }
        if (label_provider_1.URIIconReference.is(element)) {
            if (element.id === 'folder') {
                return this.getFolderClassNames(element);
            }
            return this.getFileClassNames(element, element.uri && element.uri.toString());
        }
        return this.getFileClassNames(element, element.toString());
    }
    getFolderClassNames(element) {
        const name = this.labelProvider.getName(element);
        return [this.folderIcon, this.folderNameIcon(name)];
    }
    getFileClassNames(element, uri) {
        var _a;
        const name = this.labelProvider.getName(element);
        const classNames = this.fileNameIcon(name);
        if (uri) {
            const parsedURI = new uri_1.default(uri);
            const isRoot = (_a = this.workspaceService.getWorkspaceRootUri(new uri_1.default(uri))) === null || _a === void 0 ? void 0 : _a.isEqual(parsedURI);
            if (isRoot) {
                classNames.unshift(this.rootFolderIcon);
            }
            else {
                classNames.unshift(this.fileIcon);
            }
            const language = standaloneServices_1.StandaloneServices.get(language_1.ILanguageService).createByFilepathOrFirstLine(parsedURI['codeUri']);
            classNames.push(this.languageIcon(language.languageId));
            const defaultLanguageIcon = this.languageService.getIcon(language.languageId);
            if (defaultLanguageIcon) {
                classNames.push(defaultLanguageIcon);
            }
        }
        return classNames;
    }
};
exports.PluginIconTheme = PluginIconTheme;
tslib_1.__decorate([
    (0, inversify_1.inject)(file_service_1.FileService),
    tslib_1.__metadata("design:type", file_service_1.FileService)
], PluginIconTheme.prototype, "fileService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(label_provider_1.LabelProvider),
    tslib_1.__metadata("design:type", label_provider_1.LabelProvider)
], PluginIconTheme.prototype, "labelProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(PluginIconThemeDefinition),
    tslib_1.__metadata("design:type", PluginIconThemeDefinition)
], PluginIconTheme.prototype, "definition", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.WorkspaceService),
    tslib_1.__metadata("design:type", browser_2.WorkspaceService)
], PluginIconTheme.prototype, "workspaceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(language_service_1.LanguageService),
    tslib_1.__metadata("design:type", language_service_1.LanguageService)
], PluginIconTheme.prototype, "languageService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], PluginIconTheme.prototype, "init", null);
exports.PluginIconTheme = PluginIconTheme = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginIconTheme);
let PluginIconThemeService = class PluginIconThemeService {
    constructor() {
        this.onDidChangeEmitter = new event_1.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
    }
    fireDidChange() {
        this.onDidChangeEmitter.fire({ affects: () => true });
    }
    register(contribution, plugin) {
        const pluginId = (0, plugin_protocol_1.getPluginId)(plugin.metadata.model);
        const packageUri = plugin.metadata.model.packageUri;
        const iconTheme = this.iconThemeFactory({
            id: contribution.id,
            label: contribution.label || new uri_1.default(contribution.uri).path.base,
            description: contribution.description,
            uri: contribution.uri,
            uiTheme: contribution.uiTheme,
            pluginId,
            packageUri
        });
        return new disposable_1.DisposableCollection(iconTheme, iconTheme.onDidChange(() => this.fireDidChange()), this.iconThemeService.register(iconTheme));
    }
    canHandle(element) {
        const current = this.iconThemeService.getDefinition(this.iconThemeService.current);
        if (current instanceof PluginIconTheme && ((element instanceof uri_1.default && element.scheme === 'file') || label_provider_1.URIIconReference.is(element) || files_1.FileStat.is(element) || browser_1.FileStatNode.is(element))) {
            return Number.MAX_SAFE_INTEGER;
        }
        return 0;
    }
    getIcon(element) {
        const current = this.iconThemeService.getDefinition(this.iconThemeService.current);
        if (current instanceof PluginIconTheme) {
            return current.getIcon(element);
        }
        return undefined;
    }
};
exports.PluginIconThemeService = PluginIconThemeService;
tslib_1.__decorate([
    (0, inversify_1.inject)(icon_theme_service_1.IconThemeService),
    tslib_1.__metadata("design:type", icon_theme_service_1.IconThemeService)
], PluginIconThemeService.prototype, "iconThemeService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(exports.PluginIconThemeFactory),
    tslib_1.__metadata("design:type", Function)
], PluginIconThemeService.prototype, "iconThemeFactory", void 0);
exports.PluginIconThemeService = PluginIconThemeService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginIconThemeService);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-shared-style.js"
/*!************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-shared-style.js ***!
  \************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var PluginSharedStyle_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginSharedStyle = exports.DEFAULT_ICON_SIZE = exports.PLUGIN_FILE_ICON_CLASS = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const theming_1 = __webpack_require__(/*! @theia/core/lib/browser/theming */ "../../node_modules/@theia/core/lib/browser/theming.js");
const reference_1 = __webpack_require__(/*! @theia/core/lib/common/reference */ "../../node_modules/@theia/core/lib/common/reference.js");
const endpoint_1 = __webpack_require__(/*! @theia/core/lib/browser/endpoint */ "../../node_modules/@theia/core/lib/browser/endpoint.js");
exports.PLUGIN_FILE_ICON_CLASS = 'theia-plugin-file-icon';
exports.DEFAULT_ICON_SIZE = 16;
let PluginSharedStyle = PluginSharedStyle_1 = class PluginSharedStyle {
    constructor() {
        this.rules = [];
        this.toUpdate = new disposable_1.DisposableCollection();
        this.icons = new reference_1.SyncReferenceCollection(key => this.createPluginIcon(key));
        this.iconSequence = 0;
    }
    init() {
        this.update();
        this.themeService.onDidColorThemeChange(() => this.update());
    }
    update() {
        this.toUpdate.dispose();
        const style = this.style = document.createElement('style');
        style.type = 'text/css';
        style.media = 'screen';
        document.getElementsByTagName('head')[0].appendChild(style);
        this.toUpdate.push(disposable_1.Disposable.create(() => document.getElementsByTagName('head')[0].removeChild(style)));
        for (const rule of this.rules) {
            this.doInsertRule(rule);
        }
    }
    insertRule(selector, body) {
        const rule = { selector, body };
        this.rules.push(rule);
        this.doInsertRule(rule);
        return disposable_1.Disposable.create(() => {
            const index = this.rules.indexOf(rule);
            if (index !== -1) {
                this.rules.splice(index, 1);
                this.deleteRule(selector);
            }
        });
    }
    doInsertRule({ selector, body }) {
        const sheet = this.style.sheet;
        const cssBody = body(this.themeService.getCurrentTheme());
        sheet.insertRule(selector + ' {\n' + cssBody + '\n}', 0);
    }
    deleteRule(selector) {
        const sheet = this.style.sheet;
        const rules = sheet.rules || sheet.cssRules || [];
        for (let i = rules.length - 1; i >= 0; i--) {
            const rule = rules[i];
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (rule.selectorText.indexOf(selector) !== -1) {
                sheet.deleteRule(i);
            }
        }
    }
    toIconClass(url, { size } = { size: exports.DEFAULT_ICON_SIZE }) {
        return this.icons.acquire({ url, size });
    }
    toFileIconClass(url) {
        return this.icons.acquire({ url, type: 'file' });
    }
    createPluginIcon(key) {
        var _a, _b;
        const iconUrl = key.url;
        const size = (_a = key.size) !== null && _a !== void 0 ? _a : exports.DEFAULT_ICON_SIZE;
        const type = (_b = key.type) !== null && _b !== void 0 ? _b : 'icon';
        const darkIconUrl = PluginSharedStyle_1.toExternalIconUrl(`${typeof iconUrl === 'object' ? iconUrl.dark : iconUrl}`);
        const lightIconUrl = PluginSharedStyle_1.toExternalIconUrl(`${typeof iconUrl === 'object' ? iconUrl.light : iconUrl}`);
        const toDispose = new disposable_1.DisposableCollection();
        let iconClass = 'plugin-icon-' + this.iconSequence++;
        if (type === 'icon') {
            toDispose.push(this.insertRule('.' + iconClass + '::before', theme => `
                    content: "";
                    background-position: 2px;
                    display: block;
                    width: ${size}px;
                    height: ${size}px;
                    background: center no-repeat url("${theme.type === 'light' ? lightIconUrl : darkIconUrl}");
                    background-size: ${size}px;
                `));
        }
        else {
            toDispose.push(this.insertRule('.' + iconClass + '::before', theme => `
                    content: "";
                    background-image: url("${theme.type === 'light' ? lightIconUrl : darkIconUrl}");
                    background-size: ${exports.DEFAULT_ICON_SIZE}px;
                    background-position: left center;
                    background-repeat: no-repeat;
                `));
            iconClass += ' ' + exports.PLUGIN_FILE_ICON_CLASS;
        }
        return { iconClass, dispose: () => toDispose.dispose() };
    }
    static toExternalIconUrl(iconUrl) {
        if (iconUrl.startsWith('hostedPlugin/')) {
            return new endpoint_1.Endpoint({ path: iconUrl }).getRestUrl().toString();
        }
        return iconUrl;
    }
};
exports.PluginSharedStyle = PluginSharedStyle;
tslib_1.__decorate([
    (0, inversify_1.inject)(theming_1.ThemeService),
    tslib_1.__metadata("design:type", theming_1.ThemeService)
], PluginSharedStyle.prototype, "themeService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], PluginSharedStyle.prototype, "init", null);
exports.PluginSharedStyle = PluginSharedStyle = PluginSharedStyle_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginSharedStyle);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-storage.js"
/*!*******************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-storage.js ***!
  \*******************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StorageMainImpl = void 0;
const plugin_protocol_1 = __webpack_require__(/*! ../../common/plugin-protocol */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-protocol.js");
const workspace_service_1 = __webpack_require__(/*! @theia/workspace/lib/browser/workspace-service */ "../../node_modules/@theia/workspace/lib/browser/workspace-service.js");
class StorageMainImpl {
    constructor(container) {
        this.pluginServer = container.get(plugin_protocol_1.PluginServer);
        this.workspaceService = container.get(workspace_service_1.WorkspaceService);
    }
    $set(key, value, isGlobal) {
        return this.pluginServer.setStorageValue(key, value, this.toKind(isGlobal));
    }
    $get(key, isGlobal) {
        return this.pluginServer.getStorageValue(key, this.toKind(isGlobal));
    }
    $getAll(isGlobal) {
        return this.pluginServer.getAllStorageValues(this.toKind(isGlobal));
    }
    toKind(isGlobal) {
        var _a;
        if (isGlobal) {
            return undefined;
        }
        return {
            workspace: (_a = this.workspaceService.workspace) === null || _a === void 0 ? void 0 : _a.resource.toString(),
            roots: this.workspaceService.tryGetRoots().map(root => root.resource.toString())
        };
    }
}
exports.StorageMainImpl = StorageMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-terminal-registry.js"
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-terminal-registry.js ***!
  \*****************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginTerminalRegistry = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
let PluginTerminalRegistry = class PluginTerminalRegistry {
    start(profileId) {
        return this.startCallback(profileId);
    }
};
exports.PluginTerminalRegistry = PluginTerminalRegistry;
exports.PluginTerminalRegistry = PluginTerminalRegistry = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginTerminalRegistry);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/preference-registry-main.js"
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/preference-registry-main.js ***!
  \*****************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PreferenceRegistryMainImpl = exports.getPreferences = void 0;
const preferences_1 = __webpack_require__(/*! @theia/core/lib/common/preferences */ "../../node_modules/@theia/core/lib/common/preferences/index.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const types_impl_1 = __webpack_require__(/*! ../../plugin/types-impl */ "../../node_modules/@theia/plugin-ext/lib/plugin/types-impl.js");
const browser_1 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../../node_modules/@theia/workspace/lib/browser/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
function getPreferences(preferenceProviderProvider, rootFolders) {
    const folders = rootFolders.map(root => root.resource.toString());
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return preferences_1.PreferenceScope.getScopes().reduce((result, scope) => {
        result[scope] = {};
        const provider = preferenceProviderProvider(scope);
        if (provider) {
            if (scope === preferences_1.PreferenceScope.Folder) {
                for (const f of folders) {
                    const folderPrefs = provider.getPreferences(f);
                    result[scope][f] = folderPrefs;
                }
            }
            else {
                result[scope] = provider.getPreferences();
            }
        }
        return result;
    }, {});
}
exports.getPreferences = getPreferences;
class PreferenceRegistryMainImpl {
    constructor(prc, container) {
        this.toDispose = new disposable_1.DisposableCollection();
        this.proxy = prc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.PREFERENCE_REGISTRY_EXT);
        this.preferenceService = container.get(preferences_1.PreferenceService);
        const preferenceProviderProvider = container.get(preferences_1.PreferenceProviderProvider);
        const preferenceServiceImpl = container.get(preferences_1.PreferenceServiceImpl);
        const workspaceService = container.get(browser_1.WorkspaceService);
        this.toDispose.push(preferenceServiceImpl.onPreferencesChanged(changes => {
            // it HAS to be synchronous to propagate changes before update/remove response
            const roots = workspaceService.tryGetRoots();
            const data = getPreferences(preferenceProviderProvider, roots);
            const eventData = Object.values(changes).map(({ scope, newValue, domain, preferenceName }) => {
                const extScope = scope === preferences_1.PreferenceScope.User ? undefined : domain === null || domain === void 0 ? void 0 : domain[0];
                return { preferenceName, newValue, scope: extScope };
            });
            this.proxy.$acceptConfigurationChanged(data, eventData);
        }));
    }
    dispose() {
        this.toDispose.dispose();
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async $updateConfigurationOption(target, key, value, resource, withLanguageOverride) {
        const scope = this.parseConfigurationTarget(target, resource);
        const effectiveKey = this.getEffectiveKey(key, scope, withLanguageOverride, resource);
        await this.preferenceService.set(effectiveKey, value, scope, resource);
    }
    async $removeConfigurationOption(target, key, resource, withLanguageOverride) {
        const scope = this.parseConfigurationTarget(target, resource);
        const effectiveKey = this.getEffectiveKey(key, scope, withLanguageOverride, resource);
        await this.preferenceService.set(effectiveKey, undefined, scope, resource);
    }
    parseConfigurationTarget(target, resource) {
        if (typeof target === 'boolean') {
            return target ? preferences_1.PreferenceScope.User : preferences_1.PreferenceScope.Workspace;
        }
        switch (target) {
            case types_impl_1.ConfigurationTarget.Global:
                return preferences_1.PreferenceScope.User;
            case types_impl_1.ConfigurationTarget.Workspace:
                return preferences_1.PreferenceScope.Workspace;
            case types_impl_1.ConfigurationTarget.WorkspaceFolder:
                return preferences_1.PreferenceScope.Folder;
            default:
                return resource ? preferences_1.PreferenceScope.Folder : preferences_1.PreferenceScope.Workspace;
        }
    }
    // If the caller does not set `withLanguageOverride = true`, we have to check whether the setting exists with that override already.
    getEffectiveKey(key, scope, withLanguageOverride, resource) {
        if (withLanguageOverride) {
            return key;
        }
        const overridden = this.preferenceService.overriddenPreferenceName(key);
        if (!overridden) {
            return key;
        }
        const value = this.preferenceService.inspectInScope(key, scope, resource, withLanguageOverride);
        return value === undefined ? overridden.preferenceName : key;
    }
}
exports.PreferenceRegistryMainImpl = PreferenceRegistryMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/quick-open-main.js"
/*!********************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/quick-open-main.js ***!
  \********************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QuickOpenMainImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const monaco_quick_input_service_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-quick-input-service */ "../../node_modules/@theia/monaco/lib/browser/monaco-quick-input-service.js");
const types_impl_1 = __webpack_require__(/*! ../../plugin/types-impl */ "../../node_modules/@theia/plugin-ext/lib/plugin/types-impl.js");
const themables_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/base/common/themables */ "../../node_modules/@theia/monaco-editor-core/esm/vs/base/common/themables.js");
const plugin_shared_style_1 = __webpack_require__(/*! ./plugin-shared-style */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-shared-style.js");
class QuickOpenMainImpl {
    constructor(rpc, container) {
        this.items = {};
        this.toDispose = new disposable_1.DisposableCollection();
        this.sessions = new Map();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.QUICK_OPEN_EXT);
        this.delegate = container.get(monaco_quick_input_service_1.MonacoQuickInputService);
        this.quickInputService = container.get(browser_1.QuickInputService);
        this.sharedStyle = container.get(plugin_shared_style_1.PluginSharedStyle);
    }
    dispose() {
        this.toDispose.dispose();
    }
    async $show(instance, options, token) {
        const contents = new Promise((resolve, reject) => {
            this.items[instance] = { resolve, reject };
        });
        const activeItem = await options.activeItem;
        const transformedOptions = {
            ...options,
            onDidFocus: (el) => {
                if (el) {
                    this.proxy.$onItemSelected(Number.parseInt(el.id));
                }
            },
            activeItem: this.isItem(activeItem) ? this.toQuickPickItem(activeItem) : undefined
        };
        const result = await this.delegate.pick(contents, transformedOptions, token);
        if (Array.isArray(result)) {
            return result.map(({ id }) => Number.parseInt(id));
        }
        else if (result) {
            return Number.parseInt(result.id);
        }
        return undefined;
    }
    isItem(item) {
        return (item === null || item === void 0 ? void 0 : item.kind) === 'item';
    }
    toIconClasses(path) {
        const iconClasses = [];
        if (themables_1.ThemeIcon.isThemeIcon(path)) {
            const codicon = (0, browser_1.codiconArray)(path.id);
            iconClasses.push(...codicon);
        }
        else if (path) {
            const iconReference = this.sharedStyle.toIconClass(path);
            this.toDispose.push(iconReference);
            iconClasses.push(iconReference.object.iconClass);
        }
        return iconClasses;
    }
    toIconClass(path) {
        return this.toIconClasses(path).join(' ');
    }
    toQuickPickItem(item) {
        if (!item) {
            return undefined;
        }
        else if (item.kind === 'separator') {
            return {
                type: 'separator',
                label: item.label
            };
        }
        return {
            type: 'item',
            id: item.handle.toString(),
            label: item.label,
            description: item.description,
            detail: item.detail,
            alwaysShow: item.alwaysShow,
            iconClasses: this.toIconClasses(item.iconUrl),
            buttons: item.buttons ? this.convertToQuickInputButtons(item.buttons) : undefined
        };
    }
    $setItems(instance, items) {
        if (this.items[instance]) {
            this.items[instance].resolve(items.map(item => this.toQuickPickItem(item)));
            delete this.items[instance];
        }
        return Promise.resolve();
    }
    $setError(instance, error) {
        if (this.items[instance]) {
            this.items[instance].reject(error);
            delete this.items[instance];
        }
        return Promise.resolve();
    }
    $input(options, validateInput, token) {
        var _a;
        const inputOptions = Object.create(null);
        if (options) {
            inputOptions.title = options.title;
            inputOptions.password = options.password;
            inputOptions.placeHolder = options.placeHolder;
            inputOptions.valueSelection = options.valueSelection;
            inputOptions.prompt = options.prompt;
            inputOptions.value = options.value;
            inputOptions.ignoreFocusLost = options.ignoreFocusOut;
        }
        if (validateInput) {
            inputOptions.validateInput = (val) => this.proxy.$validateInput(val);
        }
        return (_a = this.quickInputService) === null || _a === void 0 ? void 0 : _a.input(inputOptions, token);
    }
    async $showInputBox(options, validateInput) {
        return new Promise((resolve, reject) => {
            var _a;
            const sessionId = options.id;
            const toDispose = new disposable_1.DisposableCollection();
            const inputBox = (_a = this.quickInputService) === null || _a === void 0 ? void 0 : _a.createInputBox();
            inputBox.prompt = options.prompt;
            inputBox.placeholder = options.placeHolder;
            inputBox.value = options.value;
            if (options.busy) {
                inputBox.busy = options.busy;
            }
            if (options.enabled) {
                inputBox.enabled = options.enabled;
            }
            inputBox.ignoreFocusOut = options.ignoreFocusOut;
            inputBox.contextKey = options.contextKey;
            if (options.password) {
                inputBox.password = options.password;
            }
            inputBox.step = options.step;
            inputBox.title = options.title;
            inputBox.description = options.description;
            inputBox.totalSteps = options.totalSteps;
            inputBox.buttons = options.buttons ? this.convertToQuickInputButtons(options.buttons) : [];
            inputBox.validationMessage = options.validationMessage;
            if (validateInput) {
                options.validateInput = (val) => {
                    this.proxy.$validateInput(val);
                };
            }
            toDispose.push(inputBox.onDidAccept(() => {
                this.proxy.$acceptOnDidAccept(sessionId);
                resolve(inputBox.value);
            }));
            toDispose.push(inputBox.onDidChangeValue((value) => {
                this.proxy.$acceptDidChangeValue(sessionId, value);
                inputBox.validationMessage = options.validateInput(value);
            }));
            toDispose.push(inputBox.onDidTriggerButton((button) => {
                this.proxy.$acceptOnDidTriggerButton(sessionId, button);
            }));
            toDispose.push(inputBox.onDidHide(() => {
                if (toDispose.disposed) {
                    return;
                }
                this.proxy.$acceptOnDidHide(sessionId);
                toDispose.dispose();
                resolve(undefined);
            }));
            this.toDispose.push(toDispose);
            inputBox.show();
        });
    }
    $createOrUpdate(params) {
        const sessionId = params.id;
        let session;
        const candidate = this.sessions.get(sessionId);
        if (!candidate) {
            if (params.type === 'quickPick') {
                const quickPick = this.quickInputService.createQuickPick();
                quickPick.onDidAccept(() => {
                    this.proxy.$acceptOnDidAccept(sessionId);
                });
                quickPick.onDidChangeActive((items) => {
                    this.proxy.$onDidChangeActive(sessionId, items.map(item => Number.parseInt(item.id)));
                });
                quickPick.onDidChangeSelection((items) => {
                    this.proxy.$onDidChangeSelection(sessionId, items.map(item => Number.parseInt(item.id)));
                });
                quickPick.onDidTriggerButton((button) => {
                    this.proxy.$acceptOnDidTriggerButton(sessionId, button);
                });
                quickPick.onDidTriggerItemButton(e => {
                    this.proxy.$onDidTriggerItemButton(sessionId, Number.parseInt(e.item.id), e.button.handle);
                });
                quickPick.onDidChangeValue((value) => {
                    this.proxy.$acceptDidChangeValue(sessionId, value);
                });
                quickPick.onDidHide(() => {
                    this.proxy.$acceptOnDidHide(sessionId);
                });
                session = {
                    input: quickPick,
                    handlesToItems: new Map()
                };
            }
            else {
                const inputBox = this.quickInputService.createInputBox();
                inputBox.onDidAccept(() => {
                    this.proxy.$acceptOnDidAccept(sessionId);
                });
                inputBox.onDidTriggerButton((button) => {
                    this.proxy.$acceptOnDidTriggerButton(sessionId, button);
                });
                inputBox.onDidChangeValue((value) => {
                    this.proxy.$acceptDidChangeValue(sessionId, value);
                });
                inputBox.onDidHide(() => {
                    this.proxy.$acceptOnDidHide(sessionId);
                });
                session = {
                    input: inputBox,
                    handlesToItems: new Map()
                };
            }
            this.sessions.set(sessionId, session);
        }
        else {
            session = candidate;
        }
        if (session) {
            const { input, handlesToItems } = session;
            for (const param in params) {
                if (param === 'id' || param === 'type') {
                    continue;
                }
                if (param === 'visible') {
                    if (params.visible) {
                        input.show();
                    }
                    else {
                        input.hide();
                    }
                }
                else if (param === 'items') {
                    handlesToItems.clear();
                    const items = [];
                    params[param].forEach((transferItem) => {
                        const item = this.toQuickPickItem(transferItem);
                        items.push(item);
                        handlesToItems.set(transferItem.handle, item);
                    });
                    input[param] = items;
                }
                else if (param === 'activeItems' || param === 'selectedItems') {
                    input[param] = params[param]
                        .filter((handle) => handlesToItems.has(handle))
                        .map((handle) => handlesToItems.get(handle));
                }
                else if (param === 'buttons') {
                    input[param] = params.buttons.map(button => {
                        if (button.handle === -1) {
                            return this.quickInputService.backButton;
                        }
                        const { iconUrl, tooltip, handle } = button;
                        return {
                            tooltip,
                            handle,
                            iconClass: this.toIconClass(iconUrl)
                        };
                    });
                }
                else {
                    input[param] = params[param];
                }
            }
        }
        return Promise.resolve(undefined);
    }
    $hide() {
        this.delegate.hide();
    }
    $dispose(sessionId) {
        const session = this.sessions.get(sessionId);
        if (session) {
            session.input.dispose();
            this.sessions.delete(sessionId);
        }
        return Promise.resolve(undefined);
    }
    convertToQuickInputButtons(buttons) {
        return buttons.map((button, i) => ({
            iconClass: this.toIconClass(button.iconUrl),
            tooltip: button.tooltip,
            handle: button === types_impl_1.QuickInputButtons.Back ? -1 : i,
        }));
    }
}
exports.QuickOpenMainImpl = QuickOpenMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/scm-main.js"
/*!*************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/scm-main.js ***!
  \*************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2019-2021 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScmMainImpl = exports.PluginScmProvider = exports.PluginScmResource = exports.PluginScmResourceGroup = void 0;
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// code copied and modified from https://github.com/microsoft/vscode/blob/1.52.1/src/vs/workbench/api/browser/mainThreadSCM.ts
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const scm_service_1 = __webpack_require__(/*! @theia/scm/lib/browser/scm-service */ "../../node_modules/@theia/scm/lib/browser/scm-service.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../node_modules/@theia/core/lib/common/event.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../../node_modules/@theia/core/lib/common/uri.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../../node_modules/@theia/core/shared/vscode-uri/index.js");
const color_registry_1 = __webpack_require__(/*! @theia/core/lib/browser/color-registry */ "../../node_modules/@theia/core/lib/browser/color-registry.js");
const plugin_shared_style_1 = __webpack_require__(/*! ./plugin-shared-style */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-shared-style.js");
const themables_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/base/common/themables */ "../../node_modules/@theia/monaco-editor-core/esm/vs/base/common/themables.js");
class PluginScmResourceGroup {
    get hideWhenEmpty() { return !!this.features.hideWhenEmpty; }
    get contextValue() { return this.features.contextValue; }
    constructor(handle, provider, features, label, id) {
        this.handle = handle;
        this.provider = provider;
        this.features = features;
        this.label = label;
        this.id = id;
        this.resources = [];
        this.onDidSpliceEmitter = new event_1.Emitter();
        this.onDidSplice = this.onDidSpliceEmitter.event;
        this.onDidChangeEmitter = new event_1.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
    }
    splice(start, deleteCount, toInsert) {
        this.resources.splice(start, deleteCount, ...toInsert);
        this.onDidSpliceEmitter.fire({ start, deleteCount, toInsert });
    }
    updateGroup(features) {
        this.features = { ...this.features, ...features };
        this.onDidChangeEmitter.fire();
    }
    updateGroupLabel(label) {
        this.label = label;
        this.onDidChangeEmitter.fire();
    }
    dispose() { }
}
exports.PluginScmResourceGroup = PluginScmResourceGroup;
class PluginScmResource {
    constructor(proxy, sourceControlHandle, groupHandle, handle, sourceUri, group, decorations, contextValue, command) {
        this.proxy = proxy;
        this.sourceControlHandle = sourceControlHandle;
        this.groupHandle = groupHandle;
        this.handle = handle;
        this.sourceUri = sourceUri;
        this.group = group;
        this.decorations = decorations;
        this.contextValue = contextValue;
        this.command = command;
    }
    open() {
        return this.proxy.$executeResourceCommand(this.sourceControlHandle, this.groupHandle, this.handle);
    }
}
exports.PluginScmResource = PluginScmResource;
class PluginScmProvider {
    get id() { return this._id; }
    get handle() { return this._handle; }
    get label() { return this._label; }
    get rootUri() { return this._rootUri ? this._rootUri.toString() : ''; }
    get contextValue() { return this._contextValue; }
    get commitTemplate() { return this.features.commitTemplate || ''; }
    get acceptInputCommand() {
        const command = this.features.acceptInputCommand;
        if (command) {
            const scmCommand = command;
            scmCommand.command = command.id;
            return scmCommand;
        }
    }
    get statusBarCommands() {
        const commands = this.features.statusBarCommands;
        return commands === null || commands === void 0 ? void 0 : commands.map(command => {
            const scmCommand = command;
            scmCommand.command = command.id;
            return scmCommand;
        });
    }
    get count() { return this.features.count; }
    get onDidChangeStatusBarCommands() { return this.onDidChangeStatusBarCommandsEmitter.event; }
    constructor(proxy, colors, sharedStyle, _handle, _contextValue, _label, _rootUri, disposables) {
        this.proxy = proxy;
        this.colors = colors;
        this.sharedStyle = sharedStyle;
        this._handle = _handle;
        this._contextValue = _contextValue;
        this._label = _label;
        this._rootUri = _rootUri;
        this.disposables = disposables;
        this._id = this.contextValue;
        this.groups = [];
        this.groupsByHandle = Object.create(null);
        this.onDidChangeResourcesEmitter = new event_1.Emitter();
        this.onDidChangeResources = this.onDidChangeResourcesEmitter.event;
        this.features = {};
        this.onDidChangeCommitTemplateEmitter = new event_1.Emitter();
        this.onDidChangeCommitTemplate = this.onDidChangeCommitTemplateEmitter.event;
        this.onDidChangeStatusBarCommandsEmitter = new event_1.Emitter();
        this.onDidChangeEmitter = new event_1.Emitter();
        this.onDidChange = this.onDidChangeEmitter.event;
    }
    updateSourceControl(features) {
        this.features = { ...this.features, ...features };
        this.onDidChangeEmitter.fire();
        if (typeof features.commitTemplate !== 'undefined') {
            this.onDidChangeCommitTemplateEmitter.fire(this.commitTemplate);
        }
        if (typeof features.statusBarCommands !== 'undefined') {
            this.onDidChangeStatusBarCommandsEmitter.fire(this.statusBarCommands);
        }
    }
    registerGroups(resourceGroups) {
        const groups = resourceGroups.map(resourceGroup => {
            const { handle, id, label, features } = resourceGroup;
            const group = new PluginScmResourceGroup(handle, this, features, label, id);
            this.groupsByHandle[handle] = group;
            return group;
        });
        this.groups.splice(this.groups.length, 0, ...groups);
    }
    updateGroup(handle, features) {
        const group = this.groupsByHandle[handle];
        if (!group) {
            return;
        }
        group.updateGroup(features);
    }
    updateGroupLabel(handle, label) {
        const group = this.groupsByHandle[handle];
        if (!group) {
            return;
        }
        group.updateGroupLabel(label);
    }
    spliceGroupResourceStates(splices) {
        for (const splice of splices) {
            const groupHandle = splice.handle;
            const groupSlices = splice.splices;
            const group = this.groupsByHandle[groupHandle];
            if (!group) {
                console.warn(`SCM group ${groupHandle} not found in provider ${this.label}`);
                continue;
            }
            // reverse the splices sequence in order to apply them correctly
            groupSlices.reverse();
            for (const groupSlice of groupSlices) {
                const { start, deleteCount, rawResources } = groupSlice;
                const resources = rawResources.map(rawResource => {
                    const { handle, sourceUri, icons, tooltip, strikeThrough, faded, contextValue, command } = rawResource;
                    const icon = this.toIconClass(icons[0]);
                    const iconDark = this.toIconClass(icons[1]) || icon;
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const colorVariable = rawResource.colorId && this.colors.toCssVariableName(rawResource.colorId);
                    const decorations = {
                        icon,
                        iconDark,
                        tooltip,
                        strikeThrough,
                        // TODO remove the letter and colorId fields when the FileDecorationProvider is applied, see https://github.com/eclipse-theia/theia/pull/8911
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        letter: rawResource.letter || '',
                        color: colorVariable && `var(${colorVariable})`,
                        faded
                    };
                    return new PluginScmResource(this.proxy, this.handle, groupHandle, handle, new uri_1.default(vscode_uri_1.URI.revive(sourceUri)), group, decorations, contextValue || undefined, command);
                });
                group.splice(start, deleteCount, resources);
            }
        }
        this.onDidChangeResourcesEmitter.fire();
    }
    toIconClass(icon) {
        if (!icon) {
            return undefined;
        }
        if (themables_1.ThemeIcon.isThemeIcon(icon)) {
            return themables_1.ThemeIcon.asClassName(icon);
        }
        const reference = this.sharedStyle.toIconClass(icon);
        this.disposables.push(reference);
        return reference.object.iconClass;
    }
    unregisterGroup(handle) {
        const group = this.groupsByHandle[handle];
        if (!group) {
            return;
        }
        delete this.groupsByHandle[handle];
        this.groups.splice(this.groups.indexOf(group), 1);
    }
    dispose() { }
}
exports.PluginScmProvider = PluginScmProvider;
class ScmMainImpl {
    constructor(rpc, container) {
        this.repositories = new Map();
        this.repositoryDisposables = new Map();
        this.disposables = new disposable_1.DisposableCollection();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.SCM_EXT);
        this.scmService = container.get(scm_service_1.ScmService);
        this.colors = container.get(color_registry_1.ColorRegistry);
        this.sharedStyle = container.get(plugin_shared_style_1.PluginSharedStyle);
    }
    dispose() {
        this.repositories.forEach(r => r.dispose());
        this.repositories.clear();
        this.repositoryDisposables.forEach(d => d.dispose());
        this.repositoryDisposables.clear();
        this.disposables.dispose();
    }
    async $registerSourceControl(handle, id, label, rootUri) {
        const provider = new PluginScmProvider(this.proxy, this.colors, this.sharedStyle, handle, id, label, rootUri ? vscode_uri_1.URI.revive(rootUri) : undefined, this.disposables);
        const repository = this.scmService.registerScmProvider(provider, {
            input: {
                validator: async (value) => {
                    const result = await this.proxy.$validateInput(handle, value, value.length);
                    return result && { message: result[0], type: result[1] };
                }
            }
        });
        this.repositories.set(handle, repository);
        const disposables = new disposable_1.DisposableCollection(this.scmService.onDidChangeSelectedRepository(r => {
            if (r === repository) {
                this.proxy.$setSelectedSourceControl(handle);
            }
        }), repository.input.onDidChange(() => this.proxy.$onInputBoxValueChange(handle, repository.input.value)));
        if (this.scmService.selectedRepository === repository) {
            setTimeout(() => this.proxy.$setSelectedSourceControl(handle), 0);
        }
        if (repository.input.value) {
            setTimeout(() => this.proxy.$onInputBoxValueChange(handle, repository.input.value), 0);
        }
        this.repositoryDisposables.set(handle, disposables);
    }
    async $updateSourceControl(handle, features) {
        const repository = this.repositories.get(handle);
        if (!repository) {
            return;
        }
        const provider = repository.provider;
        provider.updateSourceControl(features);
    }
    async $unregisterSourceControl(handle) {
        const repository = this.repositories.get(handle);
        if (!repository) {
            return;
        }
        this.repositoryDisposables.get(handle).dispose();
        this.repositoryDisposables.delete(handle);
        repository.dispose();
        this.repositories.delete(handle);
    }
    $registerGroups(sourceControlHandle, groups, splices) {
        const repository = this.repositories.get(sourceControlHandle);
        if (!repository) {
            return;
        }
        const provider = repository.provider;
        provider.registerGroups(groups);
        provider.spliceGroupResourceStates(splices);
    }
    $updateGroup(sourceControlHandle, groupHandle, features) {
        const repository = this.repositories.get(sourceControlHandle);
        if (!repository) {
            return;
        }
        const provider = repository.provider;
        provider.updateGroup(groupHandle, features);
    }
    $updateGroupLabel(sourceControlHandle, groupHandle, label) {
        const repository = this.repositories.get(sourceControlHandle);
        if (!repository) {
            return;
        }
        const provider = repository.provider;
        provider.updateGroupLabel(groupHandle, label);
    }
    $spliceResourceStates(sourceControlHandle, splices) {
        const repository = this.repositories.get(sourceControlHandle);
        if (!repository) {
            return;
        }
        const provider = repository.provider;
        provider.spliceGroupResourceStates(splices);
    }
    $unregisterGroup(sourceControlHandle, handle) {
        const repository = this.repositories.get(sourceControlHandle);
        if (!repository) {
            return;
        }
        const provider = repository.provider;
        provider.unregisterGroup(handle);
    }
    $setInputBoxValue(sourceControlHandle, value) {
        const repository = this.repositories.get(sourceControlHandle);
        if (!repository) {
            return;
        }
        repository.input.value = value;
    }
    $setInputBoxPlaceholder(sourceControlHandle, placeholder) {
        const repository = this.repositories.get(sourceControlHandle);
        if (!repository) {
            return;
        }
        repository.input.placeholder = placeholder;
    }
    $setInputBoxVisible(sourceControlHandle, visible) {
        const repository = this.repositories.get(sourceControlHandle);
        if (!repository) {
            return;
        }
        repository.input.visible = visible;
    }
    $setInputBoxEnabled(sourceControlHandle, enabled) {
        const repository = this.repositories.get(sourceControlHandle);
        if (!repository) {
            return;
        }
        repository.input.enabled = enabled;
    }
}
exports.ScmMainImpl = ScmMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/secrets-main.js"
/*!*****************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/secrets-main.js ***!
  \*****************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SecretsMainImpl = void 0;
const common_1 = __webpack_require__(/*! ../../common */ "../../node_modules/@theia/plugin-ext/lib/common/index.js");
const credentials_service_1 = __webpack_require__(/*! @theia/core/lib/browser/credentials-service */ "../../node_modules/@theia/core/lib/browser/credentials-service.js");
class SecretsMainImpl {
    constructor(rpc, container) {
        this.proxy = rpc.getProxy(common_1.MAIN_RPC_CONTEXT.SECRETS_EXT);
        this.credentialsService = container.get(credentials_service_1.CredentialsService);
        this.credentialsService.onDidChangePassword(e => {
            const extensionId = e.service.substring(window.location.hostname.length + 1);
            this.proxy.$onDidChangePassword({ extensionId, key: e.account });
        });
    }
    static getFullKey(extensionId) {
        return `${window.location.hostname}-${extensionId}`;
    }
    async $getPassword(extensionId, key) {
        const fullKey = SecretsMainImpl.getFullKey(extensionId);
        const passwordData = await this.credentialsService.getPassword(fullKey, key);
        if (passwordData) {
            try {
                const data = JSON.parse(passwordData);
                if (data.extensionId === extensionId) {
                    return data.content;
                }
            }
            catch (e) {
                throw new Error('Cannot get password');
            }
        }
        return undefined;
    }
    async $setPassword(extensionId, key, value) {
        const fullKey = SecretsMainImpl.getFullKey(extensionId);
        const passwordData = JSON.stringify({
            extensionId,
            content: value
        });
        return this.credentialsService.setPassword(fullKey, key, passwordData);
    }
    async $deletePassword(extensionId, key) {
        try {
            const fullKey = SecretsMainImpl.getFullKey(extensionId);
            await this.credentialsService.deletePassword(fullKey, key);
        }
        catch (e) {
            throw new Error('Cannot delete password');
        }
    }
    async $getKeys(extensionId) {
        return this.doGetKeys(extensionId);
    }
    async doGetKeys(extensionId) {
        if (!this.credentialsService.keys) {
            throw new Error('CredentialsProvider does not support keys() method');
        }
        const fullKey = SecretsMainImpl.getFullKey(extensionId);
        const allKeys = await this.credentialsService.keys(fullKey);
        const keys = allKeys
            .map(key => this.parseKey(key))
            .filter((parsedKey) => parsedKey !== undefined && parsedKey.extensionId === extensionId)
            .map(({ key }) => key);
        return keys;
    }
    parseKey(key) {
        try {
            return JSON.parse(key);
        }
        catch {
            return undefined;
        }
    }
}
exports.SecretsMainImpl = SecretsMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/selection-provider-command.js"
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/selection-provider-command.js ***!
  \*******************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionProviderCommandContribution = exports.SelectionProviderCommands = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const uri_command_handler_1 = __webpack_require__(/*! @theia/core/lib/common/uri-command-handler */ "../../node_modules/@theia/core/lib/common/uri-command-handler.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
var SelectionProviderCommands;
(function (SelectionProviderCommands) {
    SelectionProviderCommands.GET_SELECTED_CONTEXT = {
        id: 'theia.plugin.workspace.selectedContext'
    };
})(SelectionProviderCommands || (exports.SelectionProviderCommands = SelectionProviderCommands = {}));
let SelectionProviderCommandContribution = class SelectionProviderCommandContribution {
    registerCommands(commands) {
        commands.registerCommand(SelectionProviderCommands.GET_SELECTED_CONTEXT, this.newMultiUriAwareCommandHandler({
            isEnabled: () => true,
            isVisible: () => false,
            execute: (selectedUris) => selectedUris.map(uri => uri.toComponents())
        }));
    }
    newMultiUriAwareCommandHandler(handler) {
        return uri_command_handler_1.UriAwareCommandHandler.MultiSelect(this.selectionService, handler);
    }
};
exports.SelectionProviderCommandContribution = SelectionProviderCommandContribution;
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.SelectionService),
    tslib_1.__metadata("design:type", core_1.SelectionService)
], SelectionProviderCommandContribution.prototype, "selectionService", void 0);
exports.SelectionProviderCommandContribution = SelectionProviderCommandContribution = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], SelectionProviderCommandContribution);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/status-bar-message-registry-main.js"
/*!*************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/status-bar-message-registry-main.js ***!
  \*************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatusBarMessageRegistryMainImpl = void 0;
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const types = __webpack_require__(/*! ../../plugin/types-impl */ "../../node_modules/@theia/plugin-ext/lib/plugin/types-impl.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const status_bar_1 = __webpack_require__(/*! @theia/core/lib/browser/status-bar/status-bar */ "../../node_modules/@theia/core/lib/browser/status-bar/status-bar.js");
const color_registry_1 = __webpack_require__(/*! @theia/core/lib/browser/color-registry */ "../../node_modules/@theia/core/lib/browser/color-registry.js");
class StatusBarMessageRegistryMainImpl {
    constructor(container, rpc) {
        this.entries = new Map();
        this.toDispose = new disposable_1.DisposableCollection(disposable_1.Disposable.create(() => { }));
        this.delegate = container.get(status_bar_1.StatusBar);
        this.colorRegistry = container.get(color_registry_1.ColorRegistry);
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.STATUS_BAR_MESSAGE_REGISTRY_EXT);
    }
    dispose() {
        this.toDispose.dispose();
    }
    async $setMessage(id, name, text, priority, alignment, color, backgroundColor, tooltip, command, accessibilityInformation, args) {
        const entry = {
            name,
            text: text || '',
            priority,
            alignment: alignment === types.StatusBarAlignment.Left ? status_bar_1.StatusBarAlignment.LEFT : status_bar_1.StatusBarAlignment.RIGHT,
            color: color && (this.colorRegistry.getCurrentColor(color) || color),
            // In contrast to color, the backgroundColor must be a theme color. Thus, do not hand in the plain string if it cannot be resolved.
            backgroundColor: backgroundColor && (this.colorRegistry.getCurrentColor(backgroundColor)),
            // true is used as a serializable sentinel value to indicate that the tooltip can be retrieved asynchronously
            tooltip: tooltip === true ? (token) => this.proxy.$getMessage(id, token) : tooltip,
            command,
            accessibilityInformation,
            arguments: args
        };
        const isNewEntry = !this.entries.has(id);
        this.entries.set(id, entry);
        await this.delegate.setElement(id, entry);
        if (this.toDispose.disposed) {
            this.$dispose(id);
        }
        else if (isNewEntry) {
            this.toDispose.push(disposable_1.Disposable.create(() => this.$dispose(id)));
        }
    }
    $dispose(id) {
        const entry = this.entries.get(id);
        if (entry) {
            this.entries.delete(id);
            this.delegate.removeElement(id);
        }
    }
}
exports.StatusBarMessageRegistryMainImpl = StatusBarMessageRegistryMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/tabs/tabs-main.js"
/*!*******************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/tabs/tabs-main.js ***!
  \*******************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TabsMainImpl = void 0;
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const editor_preview_widget_1 = __webpack_require__(/*! @theia/editor-preview/lib/browser/editor-preview-widget */ "../../node_modules/@theia/editor-preview/lib/browser/editor-preview-widget.js");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "../../node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
const monaco_diff_editor_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-diff-editor */ "../../node_modules/@theia/monaco/lib/browser/monaco-diff-editor.js");
const hierarchy_types_converters_1 = __webpack_require__(/*! ../hierarchy/hierarchy-types-converters */ "../../node_modules/@theia/plugin-ext/lib/main/browser/hierarchy/hierarchy-types-converters.js");
const terminal_widget_1 = __webpack_require__(/*! @theia/terminal/lib/browser/base/terminal-widget */ "../../node_modules/@theia/terminal/lib/browser/base/terminal-widget.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const browser_2 = __webpack_require__(/*! @theia/notebook/lib/browser */ "../../node_modules/@theia/notebook/lib/browser/index.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../../node_modules/@theia/core/lib/common/promise-util.js");
const merge_editor_1 = __webpack_require__(/*! @theia/scm/lib/browser/merge-editor/merge-editor */ "../../node_modules/@theia/scm/lib/browser/merge-editor/merge-editor.js");
class TabsMainImpl {
    constructor(rpc, container) {
        this.tabGroupModel = new Map();
        this.tabInfoLookup = new Map();
        this.waitQueue = new Map();
        this.disposableTabBarListeners = new core_1.DisposableCollection();
        this.disposableTitleListeners = new Map();
        this.toDisposeOnDestroy = new core_1.DisposableCollection();
        this.groupIdCounter = 1;
        this.tabGroupChanged = false;
        this.defaultTabGroup = {
            groupId: 0,
            tabs: [],
            isActive: true,
            viewColumn: 0
        };
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.TABS_EXT);
        this.applicationShell = container.get(browser_1.ApplicationShell);
        this.createTabsModel();
        const tabBars = this.applicationShell.mainPanel.tabBars();
        for (const tabBar of tabBars) {
            this.attachListenersToTabBar(tabBar);
        }
        this.toDisposeOnDestroy.push(this.applicationShell.mainPanelRenderer.onDidCreateTabBar(tabBar => {
            this.attachListenersToTabBar(tabBar);
            this.onTabGroupCreated(tabBar);
        }));
        this.connectToSignal(this.toDisposeOnDestroy, this.applicationShell.mainPanel.widgetAdded, (mainPanel, widget) => {
            if (this.tabGroupChanged || this.tabGroupModel.size === 0) {
                this.tabGroupChanged = false;
                this.createTabsModel();
                // tab Open event is done in backend
            }
            else {
                const tabBar = mainPanel.findTabBar(widget.title);
                const oldTabInfo = this.tabInfoLookup.get(widget.title);
                const group = this.tabGroupModel.get(tabBar);
                if (group !== (oldTabInfo === null || oldTabInfo === void 0 ? void 0 : oldTabInfo.group)) {
                    if (oldTabInfo) {
                        this.onTabClosed(oldTabInfo, widget.title);
                    }
                    this.onTabCreated(tabBar, { index: tabBar.titles.indexOf(widget.title), title: widget.title });
                }
            }
        });
        this.connectToSignal(this.toDisposeOnDestroy, this.applicationShell.mainPanel.widgetRemoved, (mainPanel, widget) => {
            if (!(widget instanceof browser_1.TabBar)) {
                const tabInfo = this.getOrRebuildModel(this.tabInfoLookup, widget.title);
                this.onTabClosed(tabInfo, widget.title);
                if (this.tabGroupChanged) {
                    this.tabGroupChanged = false;
                    this.createTabsModel();
                }
            }
        });
    }
    waitForWidget(widget) {
        const deferred = new promise_util_1.Deferred();
        this.waitQueue.set(widget, deferred);
        const timeout = setTimeout(() => {
            deferred.resolve(); // resolve to unblock the event
        }, 1000);
        deferred.promise.then(() => {
            clearTimeout(timeout);
        });
        return deferred.promise;
    }
    createTabsModel() {
        var _a, _b;
        if (this.applicationShell.mainAreaTabBars.length === 0) {
            this.proxy.$acceptEditorTabModel([this.defaultTabGroup]);
            return;
        }
        const newTabGroupModel = new Map();
        this.tabInfoLookup.clear();
        this.disposableTitleListeners.forEach(disposable => disposable.dispose());
        this.disposableTabBarListeners.dispose();
        this.applicationShell.mainAreaTabBars
            .forEach(tabBar => {
            this.attachListenersToTabBar(tabBar);
            const groupDto = this.createTabGroupDto(tabBar);
            tabBar.titles.forEach((title, index) => this.tabInfoLookup.set(title, { group: groupDto, tab: groupDto.tabs[index], tabIndex: index }));
            newTabGroupModel.set(tabBar, groupDto);
        });
        if (newTabGroupModel.size > 0 && Array.from(newTabGroupModel.values()).indexOf(this.currentActiveGroup) < 0) {
            this.currentActiveGroup = (_b = (_a = this.tabInfoLookup.get(this.applicationShell.mainPanel.currentTitle)) === null || _a === void 0 ? void 0 : _a.group) !== null && _b !== void 0 ? _b : newTabGroupModel.values().next().value;
            this.currentActiveGroup.isActive = true;
        }
        this.tabGroupModel = newTabGroupModel;
        this.proxy.$acceptEditorTabModel(Array.from(this.tabGroupModel.values()));
        // Resolve all waiting widget promises
        this.waitQueue.forEach(deferred => deferred.resolve());
        this.waitQueue.clear();
    }
    createTabDto(tabTitle, groupId, newTab = false) {
        var _a;
        const widget = tabTitle.owner;
        const active = newTab || ((_a = this.getTabBar(tabTitle)) === null || _a === void 0 ? void 0 : _a.currentTitle) === tabTitle;
        return {
            id: this.createTabId(tabTitle, groupId),
            label: tabTitle.label,
            input: this.evaluateTabDtoInput(widget),
            isActive: active,
            isPinned: tabTitle.className.includes(browser_1.PINNED_CLASS),
            isDirty: browser_1.Saveable.isDirty(widget),
            isPreview: widget instanceof editor_preview_widget_1.EditorPreviewWidget && widget.isPreview
        };
    }
    getTabBar(tabTitle) {
        return this.applicationShell.mainPanel.findTabBar(tabTitle);
    }
    createTabId(tabTitle, groupId) {
        return `${groupId}~${tabTitle.owner.id}`;
    }
    createTabGroupDto(tabBar) {
        var _a;
        const oldDto = this.tabGroupModel.get(tabBar);
        const groupId = (_a = oldDto === null || oldDto === void 0 ? void 0 : oldDto.groupId) !== null && _a !== void 0 ? _a : this.groupIdCounter++;
        const tabs = tabBar.titles.map(title => this.createTabDto(title, groupId));
        const viewColumn = 0; // TODO: Implement correct viewColumn handling
        return {
            groupId,
            tabs,
            isActive: false,
            viewColumn
        };
    }
    getTitleDisposables(title) {
        let disposable = this.disposableTitleListeners.get(title.owner.id);
        if (!disposable) {
            disposable = new core_1.DisposableCollection();
            this.disposableTitleListeners.set(title.owner.id, disposable);
        }
        return disposable;
    }
    attachListenersToTabBar(tabBar) {
        if (!tabBar) {
            return;
        }
        tabBar.titles.forEach(title => {
            this.connectToSignal(this.getTitleDisposables(title), title.changed, this.onTabTitleChanged);
        });
        this.connectToSignal(this.disposableTabBarListeners, tabBar.tabMoved, this.onTabMoved);
        this.connectToSignal(this.disposableTabBarListeners, tabBar.disposed, this.onTabGroupClosed);
    }
    evaluateTabDtoInput(widget) {
        var _a, _b;
        if (widget instanceof editor_preview_widget_1.EditorPreviewWidget) {
            if (widget.editor instanceof monaco_diff_editor_1.MonacoDiffEditor) {
                return {
                    kind: 2 /* TabInputKind.TextDiffInput */,
                    original: (0, hierarchy_types_converters_1.toUriComponents)(widget.editor.originalModel.uri),
                    modified: (0, hierarchy_types_converters_1.toUriComponents)(widget.editor.modifiedModel.uri)
                };
            }
            else {
                return {
                    kind: 1 /* TabInputKind.TextInput */,
                    uri: (0, hierarchy_types_converters_1.toUriComponents)(widget.editor.uri.toString())
                };
            }
        }
        else if (widget instanceof browser_1.ViewContainer) {
            return {
                kind: 7 /* TabInputKind.WebviewEditorInput */,
                viewType: widget.id
            };
        }
        else if (widget instanceof terminal_widget_1.TerminalWidget) {
            return {
                kind: 8 /* TabInputKind.TerminalEditorInput */
            };
        }
        else if (widget instanceof browser_2.NotebookEditorWidget) {
            return {
                kind: 4 /* TabInputKind.NotebookInput */,
                notebookType: widget.notebookType,
                uri: (0, hierarchy_types_converters_1.toUriComponents)((_b = (_a = widget.model) === null || _a === void 0 ? void 0 : _a.uri.toString()) !== null && _b !== void 0 ? _b : '')
            };
        }
        else if (widget instanceof merge_editor_1.MergeEditor) {
            return {
                kind: 3 /* TabInputKind.TextMergeInput */,
                base: (0, hierarchy_types_converters_1.toUriComponents)(widget.baseUri.toString()),
                input1: (0, hierarchy_types_converters_1.toUriComponents)(widget.side1Uri.toString()),
                input2: (0, hierarchy_types_converters_1.toUriComponents)(widget.side1Uri.toString()),
                result: (0, hierarchy_types_converters_1.toUriComponents)(widget.resultUri.toString())
            };
        }
        return { kind: 0 /* TabInputKind.UnknownInput */ };
    }
    connectToSignal(disposableList, signal, listener) {
        signal.connect(listener, this);
        disposableList.push(vscode_languageserver_protocol_1.Disposable.create(() => signal.disconnect(listener, this)));
    }
    tabDtosEqual(a, b) {
        return a.isActive === b.isActive &&
            a.isDirty === b.isDirty &&
            a.isPinned === b.isPinned &&
            a.isPreview === b.isPreview &&
            a.id === b.id;
    }
    getOrRebuildModel(map, key) {
        // something broke so we rebuild the model
        let item = map.get(key);
        if (!item) {
            this.createTabsModel();
            item = map.get(key);
        }
        return item;
    }
    // #region event listeners
    onTabCreated(tabBar, args) {
        var _a;
        const group = this.getOrRebuildModel(this.tabGroupModel, tabBar);
        this.connectToSignal(this.getTitleDisposables(args.title), args.title.changed, this.onTabTitleChanged);
        const tabDto = this.createTabDto(args.title, group.groupId, true);
        this.tabInfoLookup.set(args.title, { group, tab: tabDto, tabIndex: args.index });
        group.tabs.forEach(tab => tab.isActive = false);
        group.tabs.splice(args.index, 0, tabDto);
        this.proxy.$acceptTabOperation({
            kind: 0 /* TabModelOperationKind.TAB_OPEN */,
            index: args.index,
            tabDto,
            groupId: group.groupId
        });
        (_a = this.waitQueue.get(args.title.owner)) === null || _a === void 0 ? void 0 : _a.resolve();
        this.waitQueue.delete(args.title.owner);
    }
    onTabTitleChanged(title) {
        var _a;
        const tabInfo = this.getOrRebuildModel(this.tabInfoLookup, title);
        if (!tabInfo) {
            return;
        }
        const oldTabDto = tabInfo.tab;
        const newTabDto = this.createTabDto(title, tabInfo.group.groupId);
        if (!oldTabDto.isActive && newTabDto.isActive) {
            this.currentActiveGroup.tabs.filter(tab => tab.isActive).forEach(tab => tab.isActive = false);
        }
        if (newTabDto.isActive && !tabInfo.group.isActive) {
            tabInfo.group.isActive = true;
            this.currentActiveGroup.isActive = false;
            this.currentActiveGroup = tabInfo.group;
            this.proxy.$acceptTabGroupUpdate(tabInfo.group);
        }
        if (!this.tabDtosEqual(oldTabDto, newTabDto)) {
            tabInfo.group.tabs[tabInfo.tabIndex] = newTabDto;
            tabInfo.tab = newTabDto;
            this.proxy.$acceptTabOperation({
                kind: 2 /* TabModelOperationKind.TAB_UPDATE */,
                index: tabInfo.tabIndex,
                tabDto: newTabDto,
                groupId: tabInfo.group.groupId
            });
        }
        (_a = this.waitQueue.get(title.owner)) === null || _a === void 0 ? void 0 : _a.resolve();
        this.waitQueue.delete(title.owner);
    }
    onTabClosed(tabInfo, title) {
        var _a;
        (_a = this.disposableTitleListeners.get(title.owner.id)) === null || _a === void 0 ? void 0 : _a.dispose();
        this.disposableTitleListeners.delete(title.owner.id);
        tabInfo.group.tabs.splice(tabInfo.tabIndex, 1);
        this.tabInfoLookup.delete(title);
        this.updateTabIndices(tabInfo, tabInfo.tabIndex);
        this.proxy.$acceptTabOperation({
            kind: 1 /* TabModelOperationKind.TAB_CLOSE */,
            index: tabInfo.tabIndex,
            tabDto: this.createTabDto(title, tabInfo.group.groupId),
            groupId: tabInfo.group.groupId
        });
    }
    onTabMoved(tabBar, args) {
        const tabInfo = this.getOrRebuildModel(this.tabInfoLookup, args.title);
        tabInfo.tabIndex = args.toIndex;
        const tabDto = this.createTabDto(args.title, tabInfo.group.groupId);
        tabInfo.group.tabs.splice(args.fromIndex, 1);
        tabInfo.group.tabs.splice(args.toIndex, 0, tabDto);
        this.updateTabIndices(tabInfo, args.fromIndex);
        this.proxy.$acceptTabOperation({
            kind: 3 /* TabModelOperationKind.TAB_MOVE */,
            index: args.toIndex,
            tabDto,
            groupId: tabInfo.group.groupId,
            oldIndex: args.fromIndex
        });
    }
    onTabGroupCreated(tabBar) {
        this.tabGroupChanged = true;
    }
    onTabGroupClosed(tabBar) {
        this.tabGroupChanged = true;
    }
    // #endregion
    // #region Messages received from Ext Host
    $moveTab(tabId, index, viewColumn, preserveFocus) {
        return;
    }
    updateTabIndices(tabInfo, startIndex) {
        for (const tab of this.tabInfoLookup.values()) {
            if (tab.group === tabInfo.group && tab.tabIndex >= startIndex) {
                tab.tabIndex = tab.group.tabs.indexOf(tab.tab);
            }
        }
    }
    async $closeTab(tabIds, preserveFocus) {
        const widgets = [];
        for (const tabId of tabIds) {
            const cleanedId = tabId.substring(tabId.indexOf('~') + 1);
            const widget = this.applicationShell.getWidgetById(cleanedId);
            if (widget) {
                widgets.push(widget);
            }
        }
        await this.applicationShell.closeMany(widgets);
        return true;
    }
    async $closeGroup(groupIds, preserveFocus) {
        for (const groupId of groupIds) {
            tabGroupModel: for (const [bar, groupDto] of this.tabGroupModel) {
                if (groupDto.groupId === groupId) {
                    this.applicationShell.closeTabs(bar);
                    break tabGroupModel;
                }
            }
        }
        return true;
    }
    // #endregion
    dispose() {
        this.toDisposeOnDestroy.dispose();
        this.disposableTabBarListeners.dispose();
        this.disposableTitleListeners.forEach(disposable => disposable.dispose());
        this.disposableTitleListeners.clear();
    }
}
exports.TabsMainImpl = TabsMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/tasks-main.js"
/*!***************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/tasks-main.js ***!
  \***************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TasksMainImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../../node_modules/@theia/core/lib/common/index.js");
const task_contribution_1 = __webpack_require__(/*! @theia/task/lib/browser/task-contribution */ "../../node_modules/@theia/task/lib/browser/task-contribution.js");
const task_protocol_1 = __webpack_require__(/*! @theia/task/lib/common/task-protocol */ "../../node_modules/@theia/task/lib/common/task-protocol.js");
const task_watcher_1 = __webpack_require__(/*! @theia/task/lib/common/task-watcher */ "../../node_modules/@theia/task/lib/common/task-watcher.js");
const task_service_1 = __webpack_require__(/*! @theia/task/lib/browser/task-service */ "../../node_modules/@theia/task/lib/browser/task-service.js");
const browser_1 = __webpack_require__(/*! @theia/task/lib/browser */ "../../node_modules/@theia/task/lib/browser/index.js");
const revealKindMap = new Map([
    [1, task_protocol_1.RevealKind.Always],
    [2, task_protocol_1.RevealKind.Silent],
    [3, task_protocol_1.RevealKind.Never],
    [task_protocol_1.RevealKind.Always, 1],
    [task_protocol_1.RevealKind.Silent, 2],
    [task_protocol_1.RevealKind.Never, 3]
]);
const panelKindMap = new Map([
    [1, task_protocol_1.PanelKind.Shared],
    [2, task_protocol_1.PanelKind.Dedicated],
    [3, task_protocol_1.PanelKind.New],
    [task_protocol_1.PanelKind.Shared, 1],
    [task_protocol_1.PanelKind.Dedicated, 2],
    [task_protocol_1.PanelKind.New, 3]
]);
class TasksMainImpl {
    constructor(rpc, container) {
        this.taskProviders = new Map();
        this.toDispose = new common_1.DisposableCollection();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.TASKS_EXT);
        this.taskProviderRegistry = container.get(task_contribution_1.TaskProviderRegistry);
        this.taskResolverRegistry = container.get(task_contribution_1.TaskResolverRegistry);
        this.taskWatcher = container.get(task_watcher_1.TaskWatcher);
        this.taskService = container.get(task_service_1.TaskService);
        this.taskDefinitionRegistry = container.get(browser_1.TaskDefinitionRegistry);
        this.toDispose.push(this.taskWatcher.onTaskCreated((event) => {
            this.proxy.$onDidStartTask({
                id: event.taskId,
                task: this.fromTaskConfiguration(event.config)
            }, event.terminalId);
        }));
        this.toDispose.push(this.taskWatcher.onTaskExit((event) => {
            this.proxy.$onDidEndTask(event.taskId);
        }));
        this.toDispose.push(this.taskWatcher.onDidStartTaskProcess((event) => {
            if (event.processId !== undefined) {
                this.proxy.$onDidStartTaskProcess(event.processId, {
                    id: event.taskId,
                    task: this.fromTaskConfiguration(event.config)
                });
            }
        }));
        this.toDispose.push(this.taskWatcher.onDidEndTaskProcess((event) => {
            if (event.code !== undefined) {
                this.proxy.$onDidEndTaskProcess(event.code, event.taskId);
            }
        }));
        // Inform proxy about running tasks form previous session
        this.$taskExecutions().then(executions => {
            if (executions.length > 0) {
                this.proxy.$initLoadedTasks(executions);
            }
        });
    }
    dispose() {
        this.toDispose.dispose();
    }
    $registerTaskProvider(handle, type) {
        const taskProvider = this.createTaskProvider(handle);
        const taskResolver = this.createTaskResolver(handle);
        const toDispose = new common_1.DisposableCollection(this.taskProviderRegistry.register(type, taskProvider, handle), this.taskResolverRegistry.registerTaskResolver(type, taskResolver), common_1.Disposable.create(() => this.taskProviders.delete(handle)));
        this.taskProviders.set(handle, toDispose);
        this.toDispose.push(toDispose);
    }
    $unregister(handle) {
        const disposable = this.taskProviders.get(handle);
        if (disposable) {
            disposable.dispose();
        }
    }
    async $fetchTasks(taskVersion, taskType) {
        if (taskVersion && !taskVersion.startsWith('2.')) { // Theia does not support 1.x or earlier task versions
            return [];
        }
        const token = this.taskService.startUserAction();
        const [configured, provided] = await Promise.all([
            this.taskService.getConfiguredTasks(token),
            this.taskService.getProvidedTasks(token)
        ]);
        const result = [];
        for (const tasks of [configured, provided]) {
            for (const task of tasks) {
                if (!taskType || (!!this.taskDefinitionRegistry.getDefinition(task) ? task._source === taskType : task.type === taskType)) {
                    result.push(this.fromTaskConfiguration(task));
                }
            }
        }
        return result;
    }
    async $executeTask(taskDto) {
        const taskConfig = this.toTaskConfiguration(taskDto);
        const taskInfo = await this.taskService.runTask(taskConfig);
        if (taskInfo) {
            return {
                id: taskInfo.taskId,
                task: this.fromTaskConfiguration(taskInfo.config)
            };
        }
    }
    async $taskExecutions() {
        const runningTasks = await this.taskService.getRunningTasks();
        return runningTasks.map(taskInfo => ({
            id: taskInfo.taskId,
            task: this.fromTaskConfiguration(taskInfo.config)
        }));
    }
    $terminateTask(id) {
        this.taskService.kill(id);
    }
    async $customExecutionComplete(id, exitCode) {
        this.taskService.customExecutionComplete(id, exitCode);
    }
    createTaskProvider(handle) {
        return {
            provideTasks: () => this.proxy.$provideTasks(handle).then(tasks => tasks.map(taskDto => this.toTaskConfiguration(taskDto)))
        };
    }
    createTaskResolver(handle) {
        return {
            resolveTask: taskConfig => this.proxy.$resolveTask(handle, this.fromTaskConfiguration(taskConfig)).then(task => this.toTaskConfiguration(task))
        };
    }
    toTaskConfiguration(taskDto) {
        const { group, presentation, scope, source, runOptions, ...common } = taskDto !== null && taskDto !== void 0 ? taskDto : {};
        const partialConfig = {};
        if (presentation) {
            partialConfig.presentation = this.convertTaskPresentation(presentation);
        }
        if (group) {
            partialConfig.group = {
                kind: group.kind,
                isDefault: group.isDefault
            };
        }
        return {
            ...common,
            ...partialConfig,
            runOptions,
            _scope: scope,
            _source: source,
        };
    }
    fromTaskConfiguration(task) {
        const { group, presentation, _scope, _source, ...common } = task;
        const partialDto = {};
        if (presentation) {
            partialDto.presentation = this.convertTaskPresentation(presentation);
        }
        if (group === 'build' || group === 'test') {
            partialDto.group = {
                kind: group,
                isDefault: false
            };
        }
        else if (typeof group === 'object') {
            partialDto.group = group;
        }
        return {
            ...common,
            ...partialDto,
            scope: _scope,
            source: _source,
        };
    }
    convertTaskPresentation(presentationFrom) {
        if (presentationFrom) {
            const { reveal, panel, ...common } = presentationFrom;
            const presentationTo = {};
            if (reveal) {
                presentationTo.reveal = revealKindMap.get(reveal);
            }
            if (panel) {
                presentationTo.panel = panelKindMap.get(panel);
            }
            return {
                ...common,
                ...presentationTo,
            };
        }
    }
}
exports.TasksMainImpl = TasksMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/terminal-main.js"
/*!******************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/terminal-main.js ***!
  \******************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TerminalServiceMainImpl = void 0;
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const terminal_widget_1 = __webpack_require__(/*! @theia/terminal/lib/browser/base/terminal-widget */ "../../node_modules/@theia/terminal/lib/browser/base/terminal-widget.js");
const terminal_profile_service_1 = __webpack_require__(/*! @theia/terminal/lib/browser/terminal-profile-service */ "../../node_modules/@theia/terminal/lib/browser/terminal-profile-service.js");
const terminal_service_1 = __webpack_require__(/*! @theia/terminal/lib/browser/base/terminal-service */ "../../node_modules/@theia/terminal/lib/browser/base/terminal-service.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const shell_terminal_protocol_1 = __webpack_require__(/*! @theia/terminal/lib/common/shell-terminal-protocol */ "../../node_modules/@theia/terminal/lib/common/shell-terminal-protocol.js");
const terminal_link_provider_1 = __webpack_require__(/*! @theia/terminal/lib/browser/terminal-link-provider */ "../../node_modules/@theia/terminal/lib/browser/terminal-link-provider.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../../node_modules/@theia/core/lib/common/uri.js");
const plugin_terminal_registry_1 = __webpack_require__(/*! ./plugin-terminal-registry */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-terminal-registry.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const hosted_plugin_1 = __webpack_require__(/*! ../../hosted/browser/hosted-plugin */ "../../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin.js");
const plugin_shared_style_1 = __webpack_require__(/*! ./plugin-shared-style */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-shared-style.js");
const debounce = __webpack_require__(/*! @theia/core/shared/lodash.debounce */ "../../node_modules/@theia/core/shared/lodash.debounce/index.js");
/**
 * Plugin api service allows working with terminal emulator.
 */
class TerminalServiceMainImpl {
    constructor(rpc, container) {
        this.terminalLinkProviders = [];
        this.toDispose = new disposable_1.DisposableCollection();
        this.observers = new Map();
        this.terminals = container.get(terminal_service_1.TerminalService);
        this.terminalProfileService = container.get(terminal_profile_service_1.TerminalProfileService);
        this.pluginTerminalRegistry = container.get(plugin_terminal_registry_1.PluginTerminalRegistry);
        this.hostedPluginSupport = container.get(hosted_plugin_1.HostedPluginSupport);
        this.sharedStyle = container.get(plugin_shared_style_1.PluginSharedStyle);
        this.shell = container.get(browser_1.ApplicationShell);
        this.shellTerminalServer = container.get(shell_terminal_protocol_1.ShellTerminalServerProxy);
        this.extProxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.TERMINAL_EXT);
        this.toDispose.push(this.terminals.onDidCreateTerminal(terminal => this.trackTerminal(terminal)));
        for (const terminal of this.terminals.all) {
            this.trackTerminal(terminal);
        }
        this.toDispose.push(this.terminals.onDidChangeCurrentTerminal(() => this.updateCurrentTerminal()));
        this.updateCurrentTerminal();
        this.shellTerminalServer.getEnvVarCollections().then(collections => this.extProxy.$initEnvironmentVariableCollections(collections));
        this.pluginTerminalRegistry.startCallback = id => this.startProfile(id);
        container.bind(terminal_link_provider_1.TerminalLinkProvider).toDynamicValue(() => this);
        this.toDispose.push(this.terminalProfileService.onDidChangeDefaultShell(shell => {
            this.extProxy.$setShell(shell);
        }));
    }
    async startProfile(id) {
        await this.hostedPluginSupport.activateByTerminalProfile(id);
        return this.extProxy.$startProfile(id, core_1.CancellationToken.None);
    }
    $setEnvironmentVariableCollection(persistent, extensionIdentifier, rootUri, collection) {
        if (collection) {
            this.shellTerminalServer.setCollection(extensionIdentifier, rootUri, persistent, collection, collection.description);
        }
        else {
            this.shellTerminalServer.deleteCollection(extensionIdentifier);
        }
    }
    dispose() {
        this.toDispose.dispose();
    }
    updateCurrentTerminal() {
        const { currentTerminal } = this.terminals;
        this.extProxy.$currentTerminalChanged(currentTerminal && currentTerminal.id);
    }
    async trackTerminal(terminal) {
        let name = terminal.title.label;
        this.extProxy.$terminalCreated(terminal.id, name);
        const updateTitle = () => {
            if (name !== terminal.title.label) {
                name = terminal.title.label;
                this.extProxy.$terminalNameChanged(terminal.id, name);
            }
        };
        terminal.title.changed.connect(updateTitle);
        this.toDispose.push(disposable_1.Disposable.create(() => terminal.title.changed.disconnect(updateTitle)));
        const updateProcessId = () => terminal.processId.then(processId => this.extProxy.$terminalOpened(terminal.id, processId, terminal.terminalId, terminal.dimensions.cols, terminal.dimensions.rows), () => { });
        updateProcessId();
        this.toDispose.push(terminal.onDidOpen(() => updateProcessId()));
        this.toDispose.push(terminal.onTerminalDidClose(term => this.extProxy.$terminalClosed(term.id, term.exitStatus)));
        this.toDispose.push(terminal.onSizeChanged(({ cols, rows }) => {
            this.extProxy.$terminalSizeChanged(terminal.id, cols, rows);
        }));
        this.toDispose.push(terminal.onData(data => {
            this.extProxy.$terminalOnInput(terminal.id, data);
            this.extProxy.$terminalOnInteraction(terminal.id);
        }));
        this.toDispose.push(terminal.onShellTypeChanged(shellType => {
            this.extProxy.$terminalShellTypeChanged(terminal.id, shellType);
        }));
        this.observers.forEach((observer, id) => this.observeTerminal(id, terminal, observer));
    }
    $write(id, data) {
        const terminal = this.terminals.getById(id);
        if (!terminal) {
            return;
        }
        terminal.write(data);
    }
    $resize(id, cols, rows) {
        const terminal = this.terminals.getById(id);
        if (!terminal) {
            return;
        }
        terminal.resize(cols, rows);
    }
    async $createTerminal(id, options, parentId, isPseudoTerminal) {
        var _a;
        const terminal = await this.terminals.newTerminal({
            id,
            title: options.name,
            iconClass: this.toIconClass(options),
            shellPath: options.shellPath,
            shellArgs: options.shellArgs,
            cwd: options.cwd ? new uri_1.URI(options.cwd) : undefined,
            env: options.env,
            strictEnv: options.strictEnv,
            destroyTermOnClose: true,
            useServerTitle: false,
            attributes: options.attributes,
            hideFromUser: options.hideFromUser,
            location: this.getTerminalLocation(options, parentId),
            isPseudoTerminal,
            isTransient: options.isTransient,
            shellIntegrationNonce: (_a = options.shellIntegrationNonce) !== null && _a !== void 0 ? _a : undefined
        });
        if (options.message) {
            terminal.writeLine(options.message);
        }
        terminal.start();
        return terminal.id;
    }
    getTerminalLocation(options, parentId) {
        if (typeof options.location === 'number' && Object.values(terminal_widget_1.TerminalLocation).includes(options.location)) {
            return options.location;
        }
        else if (options.location && typeof options.location === 'object') {
            if ('parentTerminal' in options.location) {
                if (!parentId) {
                    throw new Error('parentTerminal is set but no parentId is provided');
                }
                return { 'parentTerminal': parentId };
            }
            else {
                return options.location;
            }
        }
        return undefined;
    }
    $sendText(id, text, shouldExecute) {
        const terminal = this.terminals.getById(id);
        if (terminal) {
            text = text.replace(/\r?\n/g, '\r');
            if (shouldExecute && text.charAt(text.length - 1) !== '\r') {
                text += '\r';
            }
            terminal.sendText(text);
        }
    }
    $show(id, preserveFocus) {
        const terminal = this.terminals.getById(id);
        if (terminal) {
            const options = {};
            if (preserveFocus) {
                options.mode = 'reveal';
            }
            this.terminals.open(terminal, options);
        }
    }
    $hide(id) {
        const terminal = this.terminals.getById(id);
        if (terminal && terminal.isVisible) {
            const area = this.shell.getAreaFor(terminal);
            if (area) {
                this.shell.collapsePanel(area);
            }
        }
    }
    $dispose(id) {
        const terminal = this.terminals.getById(id);
        if (terminal) {
            terminal.dispose();
        }
    }
    $setName(id, name) {
        var _a;
        (_a = this.terminals.getById(id)) === null || _a === void 0 ? void 0 : _a.setTitle(name);
    }
    $sendTextByTerminalId(id, text, addNewLine) {
        const terminal = this.terminals.getByTerminalId(id);
        if (terminal) {
            text = text.replace(/\r?\n/g, '\r');
            if (addNewLine && text.charAt(text.length - 1) !== '\r') {
                text += '\r';
            }
            terminal.sendText(text);
        }
    }
    $writeByTerminalId(id, data) {
        const terminal = this.terminals.getByTerminalId(id);
        if (!terminal) {
            return;
        }
        terminal.write(data);
    }
    $resizeByTerminalId(id, cols, rows) {
        const terminal = this.terminals.getByTerminalId(id);
        if (!terminal) {
            return;
        }
        terminal.resize(cols, rows);
    }
    $showByTerminalId(id, preserveFocus) {
        const terminal = this.terminals.getByTerminalId(id);
        if (terminal) {
            const options = {};
            if (preserveFocus) {
                options.mode = 'reveal';
            }
            this.terminals.open(terminal, options);
        }
    }
    $hideByTerminalId(id) {
        const terminal = this.terminals.getByTerminalId(id);
        if (terminal && terminal.isVisible) {
            const area = this.shell.getAreaFor(terminal);
            if (area) {
                this.shell.collapsePanel(area);
            }
        }
    }
    $disposeByTerminalId(id, waitOnExit) {
        const terminal = this.terminals.getByTerminalId(id);
        if (terminal) {
            if (waitOnExit) {
                terminal.waitOnExit(waitOnExit);
                return;
            }
            terminal.dispose();
        }
    }
    $setNameByTerminalId(id, name) {
        var _a;
        (_a = this.terminals.getByTerminalId(id)) === null || _a === void 0 ? void 0 : _a.setTitle(name);
    }
    async $registerTerminalLinkProvider(providerId) {
        this.terminalLinkProviders.push(providerId);
    }
    async $unregisterTerminalLinkProvider(providerId) {
        const index = this.terminalLinkProviders.indexOf(providerId);
        if (index > -1) {
            this.terminalLinkProviders.splice(index, 1);
        }
    }
    $registerTerminalObserver(id, nrOfLinesToMatch, outputMatcherRegex) {
        const observerData = {
            nrOfLinesToMatch: nrOfLinesToMatch,
            outputMatcherRegex: new RegExp(outputMatcherRegex, 'm'),
            disposables: new disposable_1.DisposableCollection()
        };
        this.observers.set(id, observerData);
        this.terminals.all.forEach(terminal => {
            this.observeTerminal(id, terminal, observerData);
        });
    }
    observeTerminal(observerId, terminal, observerData) {
        const doMatch = debounce(() => {
            const lineCount = Math.min(observerData.nrOfLinesToMatch, terminal.buffer.length);
            const lines = terminal.buffer.getLines(terminal.buffer.length - lineCount, lineCount);
            const result = lines.join('\n').match(observerData.outputMatcherRegex);
            if (result) {
                this.extProxy.$reportOutputMatch(observerId, result.map(value => value));
            }
        });
        observerData.disposables.push(terminal.onOutput(output => {
            doMatch();
        }));
    }
    toIconClass(options) {
        const iconColor = (0, core_1.isObject)(options.color) && typeof options.color.id === 'string' ? options.color.id : undefined;
        let iconClass;
        if (options.iconUrl) {
            if (typeof options.iconUrl === 'object' && 'id' in options.iconUrl) {
                iconClass = (0, browser_1.codicon)(options.iconUrl.id);
            }
            else {
                const iconReference = this.sharedStyle.toIconClass(options.iconUrl);
                this.toDispose.push(iconReference);
                iconClass = iconReference.object.iconClass;
            }
        }
        else {
            iconClass = (0, browser_1.codicon)('terminal');
        }
        return iconColor ? { id: iconClass, color: { id: iconColor } } : iconClass;
    }
    $unregisterTerminalObserver(id) {
        const observer = this.observers.get(id);
        if (observer) {
            observer.disposables.dispose();
            this.observers.delete(id);
        }
        else {
            throw new Error(`Unregistering unknown terminal observer: ${id}`);
        }
    }
    async provideLinks(line, terminal, cancellationToken) {
        if (this.terminalLinkProviders.length < 1) {
            return [];
        }
        const links = await this.extProxy.$provideTerminalLinks(line, terminal.id, cancellationToken !== null && cancellationToken !== void 0 ? cancellationToken : core_1.CancellationToken.None);
        return links.map(link => ({ ...link, handle: () => this.extProxy.$handleTerminalLink(link) }));
    }
}
exports.TerminalServiceMainImpl = TerminalServiceMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/test-main.js"
/*!**************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/test-main.js ***!
  \**************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 ST Microelectronics, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestingMainImpl = exports.TestItemImpl = exports.TestItemCollection = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const collections_1 = __webpack_require__(/*! @theia/test/lib/common/collections */ "../../node_modules/@theia/test/lib/common/collections.js");
const test_service_1 = __webpack_require__(/*! @theia/test/lib/browser/test-service */ "../../node_modules/@theia/test/lib/browser/test-service.js");
const test_execution_progress_service_1 = __webpack_require__(/*! @theia/test/lib/browser/test-execution-progress-service */ "../../node_modules/@theia/test/lib/browser/test-execution-progress-service.js");
const tree_delta_1 = __webpack_require__(/*! @theia/test/lib/common/tree-delta */ "../../node_modules/@theia/test/lib/common/tree-delta.js");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! @theia/core/shared/vscode-languageserver-protocol */ "../../node_modules/@theia/core/shared/vscode-languageserver-protocol/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const common_1 = __webpack_require__(/*! ../../common */ "../../node_modules/@theia/plugin-ext/lib/common/index.js");
const test_types_1 = __webpack_require__(/*! ../../common/test-types */ "../../node_modules/@theia/plugin-ext/lib/common/test-types.js");
class TestItemCollection extends collections_1.TreeCollection {
    add(item) {
        item.realParent = this.owner;
        return super.add(item);
    }
}
exports.TestItemCollection = TestItemCollection;
class TestItemImpl {
    update(value) {
        if ('label' in value) {
            this.label = value.label;
        }
        if ('range' in value) {
            this.range = convertRange(value.range);
        }
        if ('sortKey' in value) {
            this.sortKey = value.sortKey;
        }
        if ('tags' in value) {
            this.tags = value.tags;
        }
        if ('busy' in value) {
            this.busy = value.busy;
        }
        if ('sortKey' in value) {
            this.sortKey = value.sortKey;
        }
        if ('canResolveChildren' in value) {
            this.canResolveChildren = value.canResolveChildren;
        }
        if ('description' in value) {
            this.description = value.description;
        }
        if ('error' in value) {
            this.error = value.error;
        }
    }
    constructor(uri, id) {
        this.uri = uri;
        this.id = id;
        this.label = '';
        this.tags = [];
        this.busy = false;
        this.canResolveChildren = false;
        this.items = new TestItemCollection(this, (v) => v.path, (v) => v.deltaBuilder);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    notifyPropertyChange(property, value) {
        var _a;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const val = {};
        val[property] = value;
        if (this.path) {
            (_a = this.deltaBuilder) === null || _a === void 0 ? void 0 : _a.reportChanged(this.path, val);
        }
    }
    get deltaBuilder() {
        if (this._deltaBuilder) {
            return this._deltaBuilder;
        }
        else if (this.realParent) {
            this._deltaBuilder = this.realParent.deltaBuilder;
            return this._deltaBuilder;
        }
        else {
            return undefined;
        }
    }
    get path() {
        if (this._path) {
            return this._path;
        }
        else if (this.realParent instanceof TestItemImpl) {
            this._path = [...this.realParent.path, this.id];
            return this._path;
        }
        else {
            return [this.id];
        }
    }
    ;
    get parent() {
        const realParent = this.realParent;
        if (realParent instanceof TestItemImpl) {
            return realParent;
        }
        return undefined;
    }
    get realParent() {
        return this._parent;
    }
    set realParent(v) {
        this.iterate(item => {
            item._path = undefined;
            return true;
        });
        this._parent = v;
    }
    get controller() {
        var _a;
        return (_a = this.realParent) === null || _a === void 0 ? void 0 : _a.controller;
    }
    iterate(toDo) {
        if (toDo(this)) {
            for (let i = 0; i < this.items.values.length; i++) {
                if (!this.items.values[i].iterate(toDo)) {
                    return false;
                }
            }
            return true;
        }
        else {
            return false;
        }
    }
    get tests() {
        return this.items.values;
    }
    resolveChildren() {
        var _a;
        if (this.canResolveChildren) {
            (_a = this.controller) === null || _a === void 0 ? void 0 : _a.resolveChildren(this);
        }
    }
}
exports.TestItemImpl = TestItemImpl;
tslib_1.__decorate([
    (0, collections_1.observableProperty)('notifyPropertyChange'),
    tslib_1.__metadata("design:type", String)
], TestItemImpl.prototype, "label", void 0);
tslib_1.__decorate([
    (0, collections_1.observableProperty)('notifyPropertyChange'),
    tslib_1.__metadata("design:type", Object)
], TestItemImpl.prototype, "range", void 0);
tslib_1.__decorate([
    (0, collections_1.observableProperty)('notifyPropertyChange'),
    tslib_1.__metadata("design:type", Object)
], TestItemImpl.prototype, "sortKey", void 0);
tslib_1.__decorate([
    (0, collections_1.observableProperty)('notifyPropertyChange'),
    tslib_1.__metadata("design:type", Array)
], TestItemImpl.prototype, "tags", void 0);
tslib_1.__decorate([
    (0, collections_1.observableProperty)('notifyPropertyChange'),
    tslib_1.__metadata("design:type", Boolean)
], TestItemImpl.prototype, "busy", void 0);
tslib_1.__decorate([
    (0, collections_1.observableProperty)('notifyPropertyChange'),
    tslib_1.__metadata("design:type", Boolean)
], TestItemImpl.prototype, "canResolveChildren", void 0);
tslib_1.__decorate([
    (0, collections_1.observableProperty)('notifyPropertyChange'),
    tslib_1.__metadata("design:type", Object)
], TestItemImpl.prototype, "description", void 0);
tslib_1.__decorate([
    (0, collections_1.observableProperty)('notifyPropertyChange'),
    tslib_1.__metadata("design:type", Object)
], TestItemImpl.prototype, "error", void 0);
function itemToPath(item) {
    if (!(item instanceof TestItemImpl)) {
        throw new Error(`Not a TestItemImpl: ${item.id}`);
    }
    return item.path;
}
class TestRunProfileImpl {
    set isDefault(isDefault) {
        this._isDefault = isDefault;
        this.proxy.$onDidChangeDefault(this.controllerId, this.id, isDefault);
    }
    get isDefault() {
        return this._isDefault;
    }
    update(update) {
        if ('label' in update) {
            this.label = update.label;
        }
        if ('isDefault' in update) {
            this._isDefault = update.isDefault;
        }
        if ('tag' in update) {
            this.tag = update.tag;
        }
        if ('canConfigure' in update) {
            this.canConfigure = update.canConfigure;
        }
    }
    constructor(proxy, controllerId, id, kind, label, isDefault, tag) {
        this.proxy = proxy;
        this.controllerId = controllerId;
        this.id = id;
        this.kind = kind;
        this.label = label;
        this.isDefault = isDefault;
        this.tag = tag;
    }
    configure() {
        this.proxy.$onConfigureRunProfile(this.controllerId, this.id);
    }
    run(name, included, excluded, preserveFocus) {
        this.proxy.$onRunControllerTests([{
                controllerId: this.controllerId,
                name,
                profileId: this.id,
                includedTests: included.map(item => itemToPath(item)),
                excludedTests: excluded.map(item => itemToPath(item)),
                preserveFocus
            }]);
    }
}
class TestRunImpl {
    constructor(controller, proxy, id, name) {
        this.controller = controller;
        this.proxy = proxy;
        this.id = id;
        this.testStates = new Map();
        this.outputIndices = new Map();
        this.outputs = [];
        this.onDidChangePropertyEmitter = new vscode_languageserver_protocol_1.Emitter();
        this.onDidChangeProperty = this.onDidChangePropertyEmitter.event;
        this.onDidChangeTestStateEmitter = new vscode_languageserver_protocol_1.Emitter();
        this.onDidChangeTestState = this.onDidChangeTestStateEmitter.event;
        this.onDidChangeTestOutputEmitter = new vscode_languageserver_protocol_1.Emitter();
        this.onDidChangeTestOutput = this.onDidChangeTestOutputEmitter.event;
        this.name = name;
        this.isRunning = false;
    }
    ended() {
        const stateEvents = [];
        this.testStates.forEach((state, item) => {
            if (state.state <= test_types_1.TestExecutionState.Running) {
                stateEvents.push({
                    oldState: state,
                    newState: undefined,
                    test: item
                });
                this.testStates.delete(item);
            }
        });
        if (stateEvents.length > 0) {
            this.onDidChangeTestStateEmitter.fire(stateEvents);
        }
        this.isRunning = false;
    }
    notifyPropertyChange(property, value) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const val = {};
        val[property] = value;
        this.onDidChangePropertyEmitter.fire(val);
    }
    cancel() {
        this.proxy.$onCancelTestRun(this.controller.id, this.id);
    }
    getTestState(item) {
        return this.testStates.get(item);
    }
    getOutput(item) {
        if (!item) {
            return this.outputs;
        }
        else {
            const indices = this.outputIndices.get(item);
            if (!indices) {
                return [];
            }
            else {
                return indices.map(index => this.outputs[index]);
            }
        }
    }
    applyChanges(stateChanges, outputChanges) {
        const stateEvents = [];
        stateChanges.forEach(change => {
            const item = this.controller.findItem(change.itemPath);
            if (item) {
                const oldState = this.testStates.get(item);
                this.testStates.set(item, change);
                stateEvents.push({ test: item, oldState: oldState, newState: change });
            }
        });
        const outputEvents = [];
        outputChanges.forEach(change => {
            const output = {
                output: change.output,
                location: convertLocation(change.location)
            };
            this.outputs.push(output);
            let item = undefined;
            if (change.itemPath) {
                item = this.controller.findItem(change.itemPath);
                if (item) {
                    let indices = this.outputIndices.get(item);
                    if (!indices) {
                        indices = [];
                        this.outputIndices.set(item, indices);
                    }
                    indices.push(this.outputs.length - 1);
                }
            }
            outputEvents.push([item, output]);
        });
        this.onDidChangeTestStateEmitter.fire(stateEvents);
        this.onDidChangeTestOutputEmitter.fire(outputEvents);
    }
    get items() {
        return [...this.testStates.keys()];
    }
}
tslib_1.__decorate([
    (0, collections_1.observableProperty)('notifyPropertyChange'),
    tslib_1.__metadata("design:type", Boolean)
], TestRunImpl.prototype, "isRunning", void 0);
tslib_1.__decorate([
    (0, collections_1.observableProperty)('notifyPropertyChange'),
    tslib_1.__metadata("design:type", String)
], TestRunImpl.prototype, "name", void 0);
function convertLocation(location) {
    if (!location) {
        return undefined;
    }
    return {
        uri: location.uri.toString(),
        range: convertRange(location.range)
    };
}
function convertRange(range) {
    if (range) {
        return {
            start: {
                line: range.startLineNumber,
                character: range.startColumn
            }, end: {
                line: range.endLineNumber,
                character: range.endColumn
            }
        };
    }
    return undefined;
}
class TestControllerImpl {
    constructor(proxy, id, label) {
        this.proxy = proxy;
        this.id = id;
        this.label = label;
        this._profiles = new collections_1.SimpleObservableCollection();
        this._runs = new collections_1.SimpleObservableCollection();
        this.deltaBuilder = new tree_delta_1.AccumulatingTreeDeltaEmitter(300);
        this.canResolveChildren = false;
        this.items = new TestItemCollection(this, item => item.path, () => this.deltaBuilder);
        this.onProfilesChanged = this._profiles.onChanged;
        this.onRunsChanged = this._runs.onChanged;
        this.onItemsChanged = this.deltaBuilder.onDidFlush;
    }
    refreshTests(token) {
        return this.proxy.$refreshTests(this.id, token);
    }
    applyDelta(diff) {
        this.applyDeltasToCollection(this, diff);
    }
    withProfile(profileId) {
        const profile = this._profiles.values.find(p => p.id === profileId);
        if (!profile) {
            throw new Error(`No test profile ${profileId} found in controller with id ${this.id} found`);
        }
        return profile;
    }
    withRun(runId) {
        const run = this._runs.values.find(p => p.id === runId);
        if (!run) {
            throw new Error(`No test profile ${runId} found in controller with id ${this.id} found`);
        }
        return run;
    }
    applyDeltasToCollection(root, deltas) {
        deltas.forEach(delta => this.applyDeltaToCollection(root, delta));
    }
    applyDeltaToCollection(root, delta) {
        if (delta.type === tree_delta_1.DeltaKind.ADDED || delta.type === tree_delta_1.DeltaKind.REMOVED) {
            const node = this.findNodeInRoot(root, delta.path.slice(0, delta.path.length - 1), 0);
            if (node) {
                if (delta.type === tree_delta_1.DeltaKind.ADDED) {
                    node.items.add(this.createTestItem(delta.value));
                }
                else {
                    node.items.remove(delta.path[delta.path.length - 1]);
                }
            }
        }
        else {
            const node = this.findNodeInRoot(root, delta.path, 0);
            if (node) {
                if (delta.type === tree_delta_1.DeltaKind.CHANGED) {
                    node.update(delta.value);
                }
                if (delta.childDeltas) {
                    this.applyDeltasToCollection(node, delta.childDeltas);
                }
            }
        }
    }
    findItem(path) {
        if (path.length === 0) {
            console.warn('looking for item with zero-path');
            return undefined;
        }
        return this.findNodeInRoot(this, path, 0);
    }
    findNodeInRoot(root, path, startIndex) {
        if (startIndex >= path.length) {
            return root;
        }
        const child = root.items.get(path[startIndex]);
        if (!child) {
            return undefined;
        }
        return this.findNodeInRoot(child, path, startIndex + 1);
    }
    createTestItem(value) {
        var _a;
        const item = new TestItemImpl(core_1.URI.fromComponents(value.uri), value === null || value === void 0 ? void 0 : value.id);
        item.update(value);
        (_a = value.children) === null || _a === void 0 ? void 0 : _a.forEach(child => item.items.add(this.createTestItem(child)));
        return item;
    }
    get controller() {
        return this;
    }
    get testRunProfiles() {
        return this._profiles.values;
    }
    update(change) {
        if ('canRefresh' in change) {
            this.canRefresh = change.canRefresh;
        }
        if ('canResolve' in change) {
            this.canResolveChildren = change.canResolve;
        }
        if ('label' in change) {
            this.label = change.label;
        }
    }
    addProfile(profile) {
        this._profiles.add(profile);
    }
    addRun(runId, runName, isRunning) {
        const run = new TestRunImpl(this, this.proxy, runId, runName);
        run.isRunning = isRunning;
        this._runs.add(run);
        return run;
    }
    removeProfile(profileId) {
        this._profiles.remove(this.withProfile(profileId));
    }
    get testRuns() {
        return this._runs.values;
    }
    get tests() {
        return this.items.values;
    }
    resolveChildren(item) {
        if (this.canResolveChildren) {
            this.proxy.$onResolveChildren(this.id, itemToPath(item));
        }
    }
    clearRuns() {
        this._runs.clear();
    }
}
class TestingMainImpl {
    constructor(rpc, container, commandRegistry) {
        this.controllerRegistrations = new Map();
        this.testService = container.get(test_service_1.TestService);
        this.testExecutionProgressService = container.get(test_execution_progress_service_1.TestExecutionProgressService);
        this.proxy = rpc.getProxy(common_1.MAIN_RPC_CONTEXT.TESTING_EXT);
        commandRegistry.registerArgumentProcessor({
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            processArgument(arg) {
                if (arg instanceof TestItemImpl) {
                    if (!arg.controller || !arg.path) {
                        throw new Error(`Passing unattached test item ${arg.id} as a command argument`);
                    }
                    return test_types_1.TestItemReference.create(arg.controller.id, arg.path);
                }
                return arg;
            }
        });
    }
    $registerTestController(controllerId, label) {
        const controller = new TestControllerImpl(this.proxy, controllerId, label);
        this.controllerRegistrations.set(controllerId, [controller, this.testService.registerTestController(controller)]);
    }
    $updateController(controllerId, patch) {
        this.withController(controllerId).update(patch);
    }
    $unregisterTestController(controllerId) {
        const registered = this.controllerRegistrations.get(controllerId);
        if (registered) {
            this.controllerRegistrations.delete(controllerId);
            registered[1].dispose();
        }
    }
    withController(controllerId) {
        const registration = this.controllerRegistrations.get(controllerId);
        if (!registration) {
            throw new Error(`No test controller with id ${controllerId} found`);
        }
        return registration[0];
    }
    $notifyDelta(controllerId, diff) {
        this.withController(controllerId).applyDelta(diff);
    }
    $notifyTestRunProfileCreated(controllerId, profile) {
        const registration = this.controllerRegistrations.get(controllerId);
        if (!registration) {
            throw new Error(`No test controller with id ${controllerId} found`);
        }
        registration[0].addProfile(new TestRunProfileImpl(this.proxy, controllerId, profile.id, profile.kind, profile.label, profile.isDefault, profile.tag));
    }
    $updateTestRunProfile(controllerId, profileId, update) {
        this.withController(controllerId).withProfile(profileId).update(update);
    }
    $removeTestRunProfile(controllerId, profileId) {
        this.withController(controllerId).removeProfile(profileId);
    }
    $notifyTestRunCreated(controllerId, run, preserveFocus) {
        this.testExecutionProgressService.onTestRunRequested(preserveFocus);
        this.withController(controllerId).addRun(run.id, run.name, run.isRunning);
    }
    $notifyTestStateChanged(controllerId, runId, stateChanges, outputChanges) {
        this.withController(controllerId).withRun(runId).applyChanges(stateChanges, outputChanges);
    }
    $notifyTestRunEnded(controllerId, runId) {
        this.withController(controllerId).withRun(runId).ended();
    }
}
exports.TestingMainImpl = TestingMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/text-editor-main.js"
/*!*********************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/text-editor-main.js ***!
  \*********************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2017 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextEditorPropertiesMain = exports.TextEditorMain = void 0;
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const monaco_editor_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-editor */ "../../node_modules/@theia/monaco/lib/browser/monaco-editor.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const editor_options_1 = __webpack_require__(/*! ../../common/editor-options */ "../../node_modules/@theia/plugin-ext/lib/common/editor-options.js");
const types_impl_1 = __webpack_require__(/*! ../../plugin/types-impl */ "../../node_modules/@theia/plugin-ext/lib/plugin/types-impl.js");
const simple_monaco_editor_1 = __webpack_require__(/*! @theia/monaco/lib/browser/simple-monaco-editor */ "../../node_modules/@theia/monaco/lib/browser/simple-monaco-editor.js");
const monaco_diff_editor_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-diff-editor */ "../../node_modules/@theia/monaco/lib/browser/monaco-diff-editor.js");
class TextEditorMain {
    constructor(id, model, editor) {
        this.id = id;
        this.model = model;
        this.onPropertiesChangedEmitter = new core_1.Emitter();
        this.toDispose = new disposable_1.DisposableCollection(disposable_1.Disposable.create(() => this.properties = undefined), this.onPropertiesChangedEmitter);
        this.toDisposeOnEditor = new disposable_1.DisposableCollection();
        this.toDispose.push(this.model.onDidChangeOptions(() => this.updateProperties(undefined)));
        this.setEditor(editor);
        this.updateProperties(undefined);
    }
    dispose() {
        this.toDispose.dispose();
    }
    updateProperties(source) {
        this.setProperties(TextEditorPropertiesMain.readFromEditor(this.properties, this.model, this.editor), source);
    }
    setProperties(newProperties, source) {
        const result = newProperties.generateDelta(this.properties, source);
        this.properties = newProperties;
        if (result) {
            this.onPropertiesChangedEmitter.fire(result);
        }
    }
    setEditor(editor) {
        if (this.editor === editor) {
            return;
        }
        this.toDisposeOnEditor.dispose();
        this.toDispose.push(this.toDisposeOnEditor);
        this.editor = editor;
        this.toDisposeOnEditor.push(disposable_1.Disposable.create(() => this.editor = undefined));
        if (this.editor) {
            const monacoEditor = this.editor.getControl();
            this.toDisposeOnEditor.push(this.editor.onSelectionChanged(_ => {
                this.updateProperties();
            }));
            this.toDisposeOnEditor.push(monacoEditor.onDidChangeModel(() => {
                this.setEditor(undefined);
            }));
            this.toDisposeOnEditor.push(monacoEditor.onDidChangeCursorSelection(e => {
                this.updateProperties(e.source);
            }));
            this.toDisposeOnEditor.push(monacoEditor.onDidChangeConfiguration(() => {
                this.updateProperties();
            }));
            this.toDisposeOnEditor.push(monacoEditor.onDidLayoutChange(() => {
                this.updateProperties();
            }));
            this.toDisposeOnEditor.push(monacoEditor.onDidScrollChange(() => {
                this.updateProperties();
            }));
            this.updateProperties();
        }
    }
    getId() {
        return this.id;
    }
    getModel() {
        return this.model;
    }
    getProperties() {
        return this.properties;
    }
    get onPropertiesChangedEvent() {
        return this.onPropertiesChangedEmitter.event;
    }
    get diffInformation() {
        if (!(this.editor instanceof monaco_diff_editor_1.MonacoDiffEditor)) {
            return [];
        }
        return this.editor.diffInformation;
    }
    setSelections(selections) {
        if (this.editor) {
            this.editor.getControl().setSelections(selections);
            return;
        }
        const monacoSelections = selections.map(TextEditorMain.toMonacoSelections);
        this.setProperties(new TextEditorPropertiesMain(monacoSelections, this.properties.options, this.properties.visibleRanges), undefined);
    }
    setConfiguration(newConfiguration) {
        this.setIndentConfiguration(newConfiguration);
        if (!this.editor) {
            return;
        }
        if (newConfiguration.cursorStyle) {
            const newCursorStyle = (0, editor_options_1.cursorStyleToString)(newConfiguration.cursorStyle);
            this.editor.getControl().updateOptions({
                cursorStyle: newCursorStyle
            });
        }
        if (typeof newConfiguration.lineNumbers !== 'undefined') {
            let lineNumbers;
            switch (newConfiguration.lineNumbers) {
                case types_impl_1.TextEditorLineNumbersStyle.On:
                    lineNumbers = 'on';
                    break;
                case types_impl_1.TextEditorLineNumbersStyle.Relative:
                    lineNumbers = 'relative';
                    break;
                case types_impl_1.TextEditorLineNumbersStyle.Interval:
                    lineNumbers = 'interval';
                    break;
                default:
                    lineNumbers = 'off';
            }
            this.editor.getControl().updateOptions({
                lineNumbers: lineNumbers
            });
        }
    }
    setIndentConfiguration(newConfiguration) {
        if (newConfiguration.tabSize === 'auto' || newConfiguration.insertSpaces === 'auto') {
            const creationOpts = this.model.getOptions();
            let insertSpaces = creationOpts.insertSpaces;
            let tabSize = creationOpts.tabSize;
            if (newConfiguration.insertSpaces !== 'auto' && typeof newConfiguration.insertSpaces !== 'undefined') {
                insertSpaces = newConfiguration.insertSpaces;
            }
            if (newConfiguration.tabSize !== 'auto' && typeof newConfiguration.tabSize !== 'undefined') {
                tabSize = newConfiguration.tabSize;
            }
            this.model.detectIndentation(insertSpaces, tabSize);
            return;
        }
        const newOpts = {};
        if (typeof newConfiguration.insertSpaces !== 'undefined') {
            newOpts.insertSpaces = newConfiguration.insertSpaces;
        }
        if (typeof newConfiguration.tabSize !== 'undefined') {
            newOpts.tabSize = newConfiguration.tabSize;
        }
        if (typeof newConfiguration.indentSize !== 'undefined') {
            if (newConfiguration.indentSize === 'tabSize') {
                newOpts.indentSize = newConfiguration.tabSize;
            }
            else if (typeof newConfiguration.indentSize == 'number') {
                newOpts.indentSize = newConfiguration.indentSize;
            }
        }
        this.model.updateOptions(newOpts);
    }
    revealRange(range, revealType) {
        if (!this.editor || this.editor instanceof simple_monaco_editor_1.SimpleMonacoEditor) {
            return;
        }
        switch (revealType) {
            case plugin_api_rpc_1.TextEditorRevealType.Default:
                this.editor.getControl().revealRange(range, monaco.editor.ScrollType.Smooth);
                break;
            case plugin_api_rpc_1.TextEditorRevealType.InCenter:
                this.editor.getControl().revealRangeInCenter(range, monaco.editor.ScrollType.Smooth);
                break;
            case plugin_api_rpc_1.TextEditorRevealType.InCenterIfOutsideViewport:
                this.editor.getControl().revealRangeInCenterIfOutsideViewport(range, monaco.editor.ScrollType.Smooth);
                break;
            case plugin_api_rpc_1.TextEditorRevealType.AtTop:
                this.editor.getControl().revealRangeAtTop(range, monaco.editor.ScrollType.Smooth);
                break;
            default:
                console.warn(`Unknown revealType: ${revealType}`);
                break;
        }
    }
    applyEdits(versionId, edits, opts) {
        if (this.model.getVersionId() !== versionId) {
            // model changed in the meantime
            return false;
        }
        if (!this.editor) {
            return false;
        }
        if (opts.setEndOfLine === types_impl_1.EndOfLine.CRLF && !this.isSimpleWidget(this.model)) {
            this.model.setEOL(monaco.editor.EndOfLineSequence.CRLF);
        }
        else if (opts.setEndOfLine === types_impl_1.EndOfLine.LF && !this.isSimpleWidget(this.model)) {
            this.model.setEOL(monaco.editor.EndOfLineSequence.LF);
        }
        else if (opts.setEndOfLine === types_impl_1.EndOfLine.CRLF && this.isSimpleWidget(this.model)) {
            this.model.setEOL(1 /* EndOfLineSequence.CRLF */);
        }
        else if (opts.setEndOfLine === types_impl_1.EndOfLine.LF && this.isSimpleWidget(this.model)) {
            this.model.setEOL(1 /* EndOfLineSequence.CRLF */);
        }
        const editOperations = [];
        for (const edit of edits) {
            const { range, text } = edit;
            if (!range && !text) {
                continue;
            }
            if (range && range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn && !edit.text) {
                continue;
            }
            editOperations.push({
                range: range ? monaco.Range.lift(range) : this.editor.getControl().getModel().getFullModelRange(),
                /* eslint-disable-next-line no-null/no-null */
                text: text || null,
                forceMoveMarkers: edit.forceMoveMarkers
            });
        }
        if (opts.undoStopBefore) {
            this.editor.getControl().pushUndoStop();
        }
        this.editor.getControl().executeEdits('MainThreadTextEditor', editOperations);
        if (opts.undoStopAfter) {
            this.editor.getControl().pushUndoStop();
        }
        return true;
    }
    insertSnippet(template, ranges, opts) {
        var _a;
        const snippetController = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.getControl().getContribution('snippetController2');
        if (!snippetController || !this.editor) {
            return false;
        }
        const selections = ranges.map(r => new monaco.Selection(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn));
        this.editor.getControl().setSelections(selections);
        this.editor.focus();
        snippetController.insert(template, {
            undoStopBefore: opts.undoStopBefore,
            undoStopAfter: opts.undoStopAfter,
            adjustWhitespace: !opts.keepWhitespace,
            overwriteBefore: 0,
            overwriteAfter: 0
        });
        return true;
    }
    setDecorations(key, ranges) {
        if (!this.editor) {
            return;
        }
        this.editor.getControl()
            .setDecorationsByType('Plugin decorations', key, ranges.map(option => Object.assign(option, { color: undefined })));
    }
    setDecorationsFast(key, _ranges) {
        if (!this.editor) {
            return;
        }
        const ranges = [];
        const len = Math.floor(_ranges.length / 4);
        for (let i = 0; i < len; i++) {
            ranges[i] = new monaco.Range(_ranges[4 * i], _ranges[4 * i + 1], _ranges[4 * i + 2], _ranges[4 * i + 3]);
        }
        this.editor.getControl().setDecorationsByTypeFast(key, ranges);
    }
    static toMonacoSelections(selection) {
        return new monaco.Selection(selection.selectionStartLineNumber, selection.selectionStartColumn, selection.positionLineNumber, selection.positionColumn);
    }
    isSimpleWidget(model) {
        return !!model.isForSimpleWidget;
    }
}
exports.TextEditorMain = TextEditorMain;
class TextEditorPropertiesMain {
    constructor(selections, options, visibleRanges) {
        this.selections = selections;
        this.options = options;
        this.visibleRanges = visibleRanges;
    }
    generateDelta(old, source) {
        const result = {
            options: undefined,
            selections: undefined,
            visibleRanges: undefined
        };
        if (!old || !TextEditorPropertiesMain.selectionsEqual(old.selections, this.selections)) {
            result.selections = {
                selections: this.selections,
                source: source
            };
        }
        if (!old || !TextEditorPropertiesMain.optionsEqual(old.options, this.options)) {
            result.options = this.options;
        }
        if (!old || !TextEditorPropertiesMain.rangesEqual(old.visibleRanges, this.visibleRanges)) {
            result.visibleRanges = this.visibleRanges;
        }
        if (result.selections || result.visibleRanges || result.options) {
            return result;
        }
        return undefined;
    }
    static readFromEditor(prevProperties, model, editor) {
        const selections = TextEditorPropertiesMain.getSelectionsFromEditor(prevProperties, editor);
        const options = TextEditorPropertiesMain.getOptionsFromEditor(prevProperties, model, editor);
        const visibleRanges = TextEditorPropertiesMain.getVisibleRangesFromEditor(prevProperties, editor);
        return new TextEditorPropertiesMain(selections, options, visibleRanges);
    }
    static getSelectionsFromEditor(prevProperties, editor) {
        var _a;
        let result = undefined;
        if (editor && editor instanceof monaco_editor_1.MonacoEditor) {
            result = editor.getControl().getSelections() || undefined;
        }
        else if (editor && editor instanceof simple_monaco_editor_1.SimpleMonacoEditor) {
            result = (_a = editor.getControl().getSelections()) === null || _a === void 0 ? void 0 : _a.map(selection => {
                const monacoSelection = new monaco.Selection(selection.selectionStartLineNumber, selection.selectionStartColumn, selection.positionLineNumber, selection.positionColumn);
                monacoSelection.setStartPosition(selection.startLineNumber, selection.startColumn);
                monacoSelection.setEndPosition(selection.endLineNumber, selection.endColumn);
                return monacoSelection;
            });
        }
        if (!result && prevProperties) {
            result = prevProperties.selections;
        }
        if (!result) {
            result = [new monaco.Selection(1, 1, 1, 1)];
        }
        return result;
    }
    static getOptionsFromEditor(prevProperties, model, editor) {
        if (model.isDisposed()) {
            return prevProperties.options;
        }
        let cursorStyle;
        let lineNumbers;
        if (editor && editor instanceof monaco_editor_1.MonacoEditor) {
            const editorOptions = editor.getControl().getOptions();
            const lineNumbersOpts = editorOptions.get(monaco.editor.EditorOption.lineNumbers);
            cursorStyle = editorOptions.get(monaco.editor.EditorOption.cursorStyle);
            switch (lineNumbersOpts.renderType) {
                case monaco.editor.RenderLineNumbersType.Off:
                    lineNumbers = types_impl_1.TextEditorLineNumbersStyle.Off;
                    break;
                case monaco.editor.RenderLineNumbersType.Relative:
                    lineNumbers = types_impl_1.TextEditorLineNumbersStyle.Relative;
                    break;
                case monaco.editor.RenderLineNumbersType.Interval:
                    lineNumbers = types_impl_1.TextEditorLineNumbersStyle.Interval;
                    break;
                default:
                    lineNumbers = types_impl_1.TextEditorLineNumbersStyle.On;
                    break;
            }
        }
        else if (editor && editor instanceof simple_monaco_editor_1.SimpleMonacoEditor) {
            const editorOptions = editor.getControl().getOptions();
            const lineNumbersOpts = editorOptions.get(69 /* EditorOption.lineNumbers */);
            cursorStyle = editorOptions.get(28 /* EditorOption.cursorStyle */);
            switch (lineNumbersOpts.renderType) {
                case 0 /* RenderLineNumbersType.Off */:
                    lineNumbers = types_impl_1.TextEditorLineNumbersStyle.Off;
                    break;
                case 2 /* RenderLineNumbersType.Relative */:
                    lineNumbers = types_impl_1.TextEditorLineNumbersStyle.Relative;
                    break;
                case 3 /* RenderLineNumbersType.Interval */:
                    lineNumbers = types_impl_1.TextEditorLineNumbersStyle.Interval;
                    break;
                default:
                    lineNumbers = types_impl_1.TextEditorLineNumbersStyle.On;
                    break;
            }
        }
        else if (prevProperties) {
            cursorStyle = prevProperties.options.cursorStyle;
            lineNumbers = prevProperties.options.lineNumbers;
        }
        else {
            cursorStyle = editor_options_1.TextEditorCursorStyle.Line;
            lineNumbers = types_impl_1.TextEditorLineNumbersStyle.On;
        }
        const modelOptions = model.getOptions();
        return {
            insertSpaces: modelOptions.insertSpaces,
            indentSize: modelOptions.indentSize,
            tabSize: modelOptions.tabSize,
            cursorStyle,
            lineNumbers,
        };
    }
    static getVisibleRangesFromEditor(prevProperties, editor) {
        if (editor) {
            return editor.getControl().getVisibleRanges();
        }
        return [];
    }
    static selectionsEqual(a, b) {
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0; i < a.length; i++) {
            if (!a[i].equalsSelection(b[i])) {
                return false;
            }
        }
        return true;
    }
    static optionsEqual(a, b) {
        if (a && !b || !a && b) {
            return false;
        }
        if (!a && !b) {
            return true;
        }
        return (a.tabSize === b.tabSize
            && a.insertSpaces === b.insertSpaces
            && a.indentSize === b.indentSize
            && a.cursorStyle === b.cursorStyle
            && a.lineNumbers === b.lineNumbers);
    }
    static rangesEqual(a, b) {
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0; i < a.length; i++) {
            if (!a[i].equalsRange(b[i])) {
                return false;
            }
        }
        return true;
    }
}
exports.TextEditorPropertiesMain = TextEditorPropertiesMain;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/text-editor-model-service.js"
/*!******************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/text-editor-model-service.js ***!
  \******************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EditorModelService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const monaco_text_model_service_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-text-model-service */ "../../node_modules/@theia/monaco/lib/browser/monaco-text-model-service.js");
const monaco_workspace_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-workspace */ "../../node_modules/@theia/monaco/lib/browser/monaco-workspace.js");
const uri_components_1 = __webpack_require__(/*! ../../common/uri-components */ "../../node_modules/@theia/plugin-ext/lib/common/uri-components.js");
let EditorModelService = class EditorModelService {
    constructor(monacoModelService, monacoWorkspace) {
        this.modelModeChangedEmitter = new core_1.Emitter();
        this.onModelRemovedEmitter = new core_1.Emitter();
        this.modelDirtyEmitter = new core_1.Emitter();
        this.modelEncodingEmitter = new core_1.Emitter();
        this.modelSavedEmitter = new core_1.Emitter();
        this.onModelWillSaveListeners = new core_1.ListenerList();
        this.onModelDirtyChanged = this.modelDirtyEmitter.event;
        this.onModelEncodingChanged = this.modelEncodingEmitter.event;
        this.onModelWillSave = this.onModelWillSaveListeners.registration;
        this.onModelSaved = this.modelSavedEmitter.event;
        this.onModelModeChanged = this.modelModeChangedEmitter.event;
        this.onModelRemoved = this.onModelRemovedEmitter.event;
        this.monacoModelService = monacoModelService;
        monacoModelService.models.forEach(model => this.modelCreated(model));
        monacoModelService.onDidCreate(this.modelCreated, this);
        monacoWorkspace.onDidCloseTextDocument(model => {
            setTimeout(() => {
                this.onModelRemovedEmitter.fire(model);
            }, 1);
        });
    }
    modelCreated(model) {
        model.textEditorModel.onDidChangeLanguage(e => {
            this.modelModeChangedEmitter.fire({ model, oldModeId: e.oldLanguage });
        });
        model.onDidSaveModel(_ => {
            this.modelSavedEmitter.fire(model);
        });
        model.onModelWillSaveModel(async (e) => {
            await core_1.Listener.awaitAll(e, this.onModelWillSaveListeners);
        });
        model.onDirtyChanged(_ => {
            this.modelDirtyEmitter.fire(model);
        });
        model.onDidChangeEncoding(encoding => {
            this.modelEncodingEmitter.fire({ model, encoding });
        });
    }
    get onModelAdded() {
        return this.monacoModelService.onDidCreate;
    }
    getModels() {
        return this.monacoModelService.models;
    }
    async save(uri) {
        const model = this.monacoModelService.get(uri.toString());
        if (model) {
            await model.save();
            return true;
        }
        return false;
    }
    async saveAll(includeUntitled) {
        const saves = [];
        for (const model of this.monacoModelService.models) {
            const { uri } = model.textEditorModel;
            if (model.dirty && (includeUntitled || uri.scheme !== uri_components_1.Schemes.untitled)) {
                saves.push((async () => {
                    try {
                        await model.save();
                        return true;
                    }
                    catch (e) {
                        console.error('Failed to save ', uri.toString(), e);
                        return false;
                    }
                })());
            }
        }
        const results = await Promise.all(saves);
        return results.reduce((a, b) => a && b, true);
    }
    async createModelReference(uri) {
        return this.monacoModelService.createModelReference(uri);
    }
};
exports.EditorModelService = EditorModelService;
exports.EditorModelService = EditorModelService = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(monaco_text_model_service_1.MonacoTextModelService)),
    tslib_1.__param(1, (0, inversify_1.inject)(monaco_workspace_1.MonacoWorkspace)),
    tslib_1.__metadata("design:paramtypes", [monaco_text_model_service_1.MonacoTextModelService,
        monaco_workspace_1.MonacoWorkspace])
], EditorModelService);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/text-editors-main.js"
/*!**********************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/text-editors-main.js ***!
  \**********************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextEditorsMainImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const errors_1 = __webpack_require__(/*! ../../common/errors */ "../../node_modules/@theia/plugin-ext/lib/common/errors.js");
const languages_main_1 = __webpack_require__(/*! ./languages-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/languages-main.js");
const monaco_bulk_edit_service_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-bulk-edit-service */ "../../node_modules/@theia/monaco/lib/browser/monaco-bulk-edit-service.js");
const endpoint_1 = __webpack_require__(/*! @theia/core/lib/browser/endpoint */ "../../node_modules/@theia/core/lib/browser/endpoint.js");
const monaco = __webpack_require__(/*! @theia/monaco-editor-core */ "../../node_modules/@theia/monaco-editor-core/esm/vs/editor/editor.main.js");
const bulkEditService_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/browser/services/bulkEditService */ "../../node_modules/@theia/monaco-editor-core/esm/vs/editor/browser/services/bulkEditService.js");
const standaloneServices_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices */ "../../node_modules/@theia/monaco-editor-core/esm/vs/editor/standalone/browser/standaloneServices.js");
const codeEditorService_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/editor/browser/services/codeEditorService */ "../../node_modules/@theia/monaco-editor-core/esm/vs/editor/browser/services/codeEditorService.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const notebooks_main_1 = __webpack_require__(/*! ./notebooks/notebooks-main */ "../../node_modules/@theia/plugin-ext/lib/main/browser/notebooks/notebooks-main.js");
const browser_1 = __webpack_require__(/*! @theia/notebook/lib/browser */ "../../node_modules/@theia/notebook/lib/browser/index.js");
class TextEditorsMainImpl {
    constructor(editorsAndDocuments, documents, rpc, container) {
        this.editorsAndDocuments = editorsAndDocuments;
        this.documents = documents;
        this.toDispose = new disposable_1.DisposableCollection();
        this.editorsToDispose = new Map();
        this.fileEndpoint = new endpoint_1.Endpoint({ path: 'file' }).getRestUrl();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.TEXT_EDITORS_EXT);
        this.bulkEditService = container.get(monaco_bulk_edit_service_1.MonacoBulkEditService);
        this.notebookService = container.get(browser_1.NotebookService);
        this.toDispose.push(editorsAndDocuments);
        this.toDispose.push(editorsAndDocuments.onTextEditorAdd(editors => editors.forEach(this.onTextEditorAdd, this)));
        this.toDispose.push(editorsAndDocuments.onTextEditorRemove(editors => editors.forEach(this.onTextEditorRemove, this)));
    }
    dispose() {
        this.toDispose.dispose();
    }
    onTextEditorAdd(editor) {
        const id = editor.getId();
        const toDispose = new disposable_1.DisposableCollection(editor.onPropertiesChangedEvent(e => {
            this.proxy.$acceptEditorPropertiesChanged(id, e);
        }), disposable_1.Disposable.create(() => this.editorsToDispose.delete(id)));
        this.editorsToDispose.set(id, toDispose);
        this.toDispose.push(toDispose);
    }
    onTextEditorRemove(id) {
        const disposables = this.editorsToDispose.get(id);
        if (disposables) {
            disposables.dispose();
        }
    }
    $tryShowTextDocument(uri, options) {
        return this.documents.$tryShowDocument(uri, options);
    }
    $trySetOptions(id, options) {
        if (!this.editorsAndDocuments.getEditor(id)) {
            return Promise.reject((0, errors_1.disposed)(`TextEditor: ${id}`));
        }
        this.editorsAndDocuments.getEditor(id).setConfiguration(options);
        return Promise.resolve();
    }
    $trySetSelections(id, selections) {
        if (!this.editorsAndDocuments.getEditor(id)) {
            return Promise.reject((0, errors_1.disposed)(`TextEditor: ${id}`));
        }
        this.editorsAndDocuments.getEditor(id).setSelections(selections);
        return Promise.resolve();
    }
    $tryRevealRange(id, range, revealType) {
        if (!this.editorsAndDocuments.getEditor(id)) {
            return Promise.reject((0, errors_1.disposed)(`TextEditor(${id})`));
        }
        this.editorsAndDocuments.getEditor(id).revealRange(new monaco.Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn), revealType);
        return Promise.resolve();
    }
    $tryApplyEdits(id, modelVersionId, edits, opts) {
        if (!this.editorsAndDocuments.getEditor(id)) {
            return Promise.reject((0, errors_1.disposed)(`TextEditor(${id})`));
        }
        return Promise.resolve(this.editorsAndDocuments.getEditor(id).applyEdits(modelVersionId, edits, opts));
    }
    async $tryApplyWorkspaceEdit(dto, metadata) {
        const [notebookEdits, monacoEdits] = core_1.ArrayUtils.partition(dto.edits, edit => plugin_api_rpc_1.WorkspaceNotebookCellEditDto.is(edit));
        try {
            if (notebookEdits.length > 0) {
                const workspaceEdit = (0, notebooks_main_1.toNotebookWorspaceEdit)({ edits: notebookEdits });
                return this.notebookService.applyWorkspaceEdit(workspaceEdit);
            }
            if (monacoEdits.length > 0) {
                const workspaceEdit = (0, languages_main_1.toMonacoWorkspaceEdit)({ edits: monacoEdits });
                const edits = bulkEditService_1.ResourceEdit.convert(workspaceEdit);
                const { isApplied } = await this.bulkEditService.apply(edits, { respectAutoSaveConfig: metadata === null || metadata === void 0 ? void 0 : metadata.isRefactoring });
                return isApplied;
            }
            return false;
        }
        catch {
            return false;
        }
    }
    $tryInsertSnippet(id, template, ranges, opts) {
        if (!this.editorsAndDocuments.getEditor(id)) {
            return Promise.reject((0, errors_1.disposed)(`TextEditor(${id})`));
        }
        return Promise.resolve(this.editorsAndDocuments.getEditor(id).insertSnippet(template, ranges, opts));
    }
    $registerTextEditorDecorationType(key, options) {
        this.injectRemoteUris(options);
        standaloneServices_1.StandaloneServices.get(codeEditorService_1.ICodeEditorService).registerDecorationType('Plugin decoration', key, options);
        this.toDispose.push(disposable_1.Disposable.create(() => this.$removeTextEditorDecorationType(key)));
    }
    injectRemoteUris(options) {
        if (options.before) {
            options.before.contentIconPath = this.toRemoteUri(options.before.contentIconPath);
        }
        if (options.after) {
            options.after.contentIconPath = this.toRemoteUri(options.after.contentIconPath);
        }
        if ('gutterIconPath' in options) {
            options.gutterIconPath = this.toRemoteUri(options.gutterIconPath);
        }
        if ('dark' in options && options.dark) {
            this.injectRemoteUris(options.dark);
        }
        if ('light' in options && options.light) {
            this.injectRemoteUris(options.light);
        }
    }
    toRemoteUri(uri) {
        if (uri && uri.scheme === 'file') {
            return this.fileEndpoint.withQuery(core_1.URI.fromComponents(uri).toString()).toComponents();
        }
        return uri;
    }
    $removeTextEditorDecorationType(key) {
        standaloneServices_1.StandaloneServices.get(codeEditorService_1.ICodeEditorService).removeDecorationType(key);
    }
    $tryHideEditor(id) {
        return this.editorsAndDocuments.hideEditor(id);
    }
    $trySetDecorations(id, key, ranges) {
        if (!this.editorsAndDocuments.getEditor(id)) {
            return Promise.reject((0, errors_1.disposed)(`TextEditor(${id})`));
        }
        this.editorsAndDocuments.getEditor(id).setDecorations(key, ranges);
        return Promise.resolve();
    }
    $trySetDecorationsFast(id, key, ranges) {
        if (!this.editorsAndDocuments.getEditor(id)) {
            return Promise.reject((0, errors_1.disposed)(`TextEditor(${id})`));
        }
        this.editorsAndDocuments.getEditor(id).setDecorationsFast(key, ranges);
        return Promise.resolve();
    }
    $save(uri) {
        return this.editorsAndDocuments.save(core_1.URI.fromComponents(uri)).then(u => u === null || u === void 0 ? void 0 : u.toComponents());
    }
    $saveAs(uri) {
        return this.editorsAndDocuments.saveAs(core_1.URI.fromComponents(uri)).then(u => u === null || u === void 0 ? void 0 : u.toComponents());
    }
    $saveAll(includeUntitled) {
        return this.editorsAndDocuments.saveAll(includeUntitled);
    }
    $getDiffInformation(id) {
        return Promise.resolve(this.editorsAndDocuments.getDiffInformation(id));
    }
}
exports.TextEditorsMainImpl = TextEditorsMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/theme-icon-override.js"
/*!************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/theme-icon-override.js ***!
  \************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const iconRegistry_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/platform/theme/common/iconRegistry */ "../../node_modules/@theia/monaco-editor-core/esm/vs/platform/theme/common/iconRegistry.js");
// @monaco-uplift
// Keep this up-to-date with the table at https://code.visualstudio.com/api/references/icons-in-labels#icon-listing
const codeIconMap = {
    'accounts-view-bar-icon': 'account',
    'breakpoints-activate': 'activate-breakpoints',
    'breakpoints-remove-all': 'close-all',
    'breakpoints-view-icon': 'debug-alt',
    'callhierarchy-incoming': 'call-incoming',
    'callhierarchy-outgoing': 'call-outgoing',
    'callstack-view-icon': 'debug-alt',
    'callstack-view-session': 'bug',
    'chat-editor-label-icon': 'comment-discussion',
    'comments-view-icon': 'comment-discussion',
    'debug-breakpoint': 'debug-breakpoint',
    'debug-breakpoint-conditional': 'debug-breakpoint-conditional',
    'debug-breakpoint-conditional-disabled': 'debug-breakpoint-conditional-disabled',
    'debug-breakpoint-conditional-unverified': 'debug-breakpoint-conditional-unverified',
    'debug-breakpoint-data': 'debug-breakpoint-data',
    'debug-breakpoint-data-disabled': 'debug-breakpoint-data-disabled',
    'debug-breakpoint-data-unverified': 'debug-breakpoint-data-unverified',
    'debug-breakpoint-disabled': 'debug-breakpoint-disabled',
    'debug-breakpoint-function': 'debug-breakpoint-function',
    'debug-breakpoint-function-disabled': 'debug-breakpoint-function-disabled',
    'debug-breakpoint-function-unverified': 'debug-breakpoint-function-unverified',
    'debug-breakpoint-log': 'debug-breakpoint-log',
    'debug-breakpoint-log-disabled': 'debug-breakpoint-log-disabled',
    'debug-breakpoint-log-unverified': 'debug-breakpoint-log-unverified',
    'debug-breakpoint-unsupported': 'debug-breakpoint-unsupported',
    'debug-breakpoint-unverified': 'debug-breakpoint-unverified',
    'debug-collapse-all': 'collapse-all',
    'debug-configure': 'gear',
    'debug-console-clear-all': 'clear-all',
    'debug-console-evaluation-input': 'arrow-small-right',
    'debug-console-evaluation-prompt': 'chevron-right',
    'debug-console-view-icon': 'debug-console',
    'debug-continue': 'debug-continue',
    'debug-disconnect': 'debug-disconnect',
    'debug-gripper': 'gripper',
    'debug-hint': 'debug-hint',
    'debug-pause': 'debug-pause',
    'debug-restart': 'debug-restart',
    'debug-restart-frame': 'debug-restart-frame',
    'debug-reverse-continue': 'debug-reverse-continue',
    'debug-stackframe': 'debug-stackframe',
    'debug-stackframe-focused': 'debug-stackframe-focused',
    'debug-start': 'debug-start',
    'debug-step-back': 'debug-step-back',
    'debug-step-into': 'debug-step-into',
    'debug-step-out': 'debug-step-out',
    'debug-step-over': 'debug-step-over',
    'debug-stop': 'debug-stop',
    'default-view-icon': 'window',
    'diff-editor-next-change': 'arrow-down',
    'diff-editor-previous-change': 'arrow-up',
    'diff-editor-toggle-whitespace': 'whitespace',
    'diff-insert': 'add',
    'diff-remove': 'remove',
    'diff-review-close': 'close',
    'diff-review-insert': 'add',
    'diff-review-remove': 'remove',
    'explorer-view-icon': 'files',
    'extensions-clear-search-results': 'clear-all',
    'extensions-configure-recommended': 'pencil',
    'extensions-filter': 'filter',
    'extensions-info-message': 'info',
    'extensions-install-count': 'cloud-download',
    'extensions-install-local-in-remote': 'cloud-download',
    'extensions-install-workspace-recommended': 'cloud-download',
    'extensions-manage': 'gear',
    'extensions-rating': 'star',
    'extensions-refresh': 'refresh',
    'extensions-remote': 'remote',
    'extensions-star-empty': 'star-empty',
    'extensions-star-full': 'star-full',
    'extensions-star-half': 'star-half',
    'extensions-sync-enabled': 'sync',
    'extensions-sync-ignored': 'sync-ignored',
    'extensions-view-icon': 'extensions',
    'extensions-warning-message': 'warning',
    'find-collapsed': 'chevron-right',
    'find-expanded': 'chevron-down',
    'find-next-match': 'arrow-down',
    'find-previous-match': 'arrow-up',
    'find-replace': 'replace',
    'find-replace-all': 'replace-all',
    'find-selection': 'selection',
    'folding-collapsed': 'chevron-right',
    'folding-expanded': 'chevron-down',
    'getting-started-beginner': 'lightbulb',
    'getting-started-codespaces': 'github',
    'getting-started-item-checked': 'pass-filled',
    'getting-started-item-unchecked': 'circle-large-outline',
    'getting-started-setup': 'heart',
    'goto-next-location': 'arrow-down',
    'goto-previous-location': 'arrow-up',
    'keybindings-add': 'add',
    'keybindings-edit': 'edit',
    'keybindings-record-keys': 'record-keys',
    'keybindings-sort': 'sort-precedence',
    'loaded-scripts-view-icon': 'debug-alt',
    'marker-navigation-next': 'chevron-down',
    'marker-navigation-previous': 'chevron-up',
    'markers-view-filter': 'filter',
    'markers-view-icon': 'warning',
    'markers-view-multi-line-collapsed': 'chevron-down',
    'markers-view-multi-line-expanded': 'chevron-up',
    'notebook-clear': 'clear-all',
    'notebook-collapsed': 'chevron-right',
    'notebook-delete-cell': 'trash',
    'notebook-edit': 'pencil',
    'notebook-execute': 'play',
    'notebook-execute-all': 'run-all',
    'notebook-expanded': 'chevron-down',
    'notebook-kernel-configure': 'settings-gear',
    'notebook-kernel-select': 'server-environment',
    'notebook-mimetype': 'code',
    'notebook-move-down': 'arrow-down',
    'notebook-move-up': 'arrow-up',
    'notebook-open-as-text': 'file-code',
    'notebook-render-output': 'preview',
    'notebook-revert': 'discard',
    'notebook-split-cell': 'split-vertical',
    'notebook-state-error': 'error',
    'notebook-state-success': 'check',
    'notebook-stop': 'primitive-square',
    'notebook-stop-edit': 'check',
    'notebook-unfold': 'unfold',
    'notifications-clear': 'close',
    'notifications-clear-all': 'clear-all',
    'notifications-collapse': 'chevron-down',
    'notifications-configure': 'gear',
    'notifications-expand': 'chevron-up',
    'notifications-hide': 'chevron-down',
    'open-editors-view-icon': 'book',
    'outline-view-icon': 'symbol-class',
    'output-view-icon': 'output',
    'panel-close': 'close',
    'panel-maximize': 'chevron-up',
    'panel-restore': 'chevron-down',
    'parameter-hints-next': 'chevron-down',
    'parameter-hints-previous': 'chevron-up',
    'ports-forward-icon': 'plus',
    'ports-open-browser-icon': 'globe',
    'ports-stop-forward-icon': 'x',
    'ports-view-icon': 'plug',
    'preferences-clear-input': 'clear-all',
    'preferences-open-settings': 'go-to-file',
    'private-ports-view-icon': 'lock',
    'public-ports-view-icon': 'eye',
    'refactor-preview-view-icon': 'lightbulb',
    'remote-explorer-documentation': 'book',
    'remote-explorer-feedback': 'twitter',
    'remote-explorer-get-started': 'star',
    'remote-explorer-report-issues': 'comment',
    'remote-explorer-review-issues': 'issues',
    'remote-explorer-view-icon': 'remote-explorer',
    'review-comment-collapse': 'chevron-up',
    'run-view-icon': 'debug-alt',
    'runtime-extensions-editor-label-icon': ' extensions',
    'search-clear-results': 'clear-all',
    'search-collapse-results': 'collapse-all',
    'search-details': 'ellipsis',
    'search-editor-label-icon': 'search',
    'search-expand-results': 'expand-all',
    'search-hide-replace': 'chevron-right',
    'search-new-editor': 'new-file',
    'search-refresh': 'refresh',
    'search-remove': 'close',
    'search-replace': 'replace',
    'search-replace-all': 'replace-all',
    'search-show-context': 'list-selection',
    'search-show-replace': 'chevron-down',
    'search-stop': 'search-stop',
    'search-view-icon': 'search',
    'settings-add': 'add',
    'settings-discard': 'discard',
    'settings-edit': 'edit',
    'settings-editor-label-icon': 'settings',
    'settings-folder-dropdown': 'triangle-down',
    'settings-group-collapsed': 'chevron-right',
    'settings-group-expanded': 'chevron-down',
    'settings-more-action': 'gear',
    'settings-remove': 'close',
    'settings-sync-view-icon': 'sync',
    'settings-view-bar-icon': 'settings-gear',
    'source-control-view-icon': 'source-control',
    'suggest-more-info': 'chevron-right',
    'tasks-list-configure': 'gear',
    'tasks-remove': 'close',
    'terminal-kill': 'trash',
    'terminal-new': 'add',
    'terminal-rename': 'gear',
    'terminal-view-icon': 'terminal',
    'test-view-icon': 'beaker',
    'testing-cancel-icon': 'close',
    'testing-debug-icon': 'debug-alt',
    'testing-error-icon': 'warning',
    'testing-failed-icon': 'close',
    'testing-passed-icon': 'pass',
    'testing-queued-icon': 'watch',
    'testing-run-all-icon': 'run-all',
    'testing-run-icon': 'run',
    'testing-show-as-list-icon': 'list-tree',
    'testing-skipped-icon': 'debug-step-over',
    'testing-unset-icon': 'circle-outline',
    'timeline-open': 'history',
    'timeline-pin': 'pin',
    'timeline-refresh': 'refresh',
    'timeline-unpin': 'pinned',
    'timeline-view-icon': 'history',
    'variables-view-icon': 'debug-alt',
    'view-pane-container-collapsed': 'chevron-right',
    'view-pane-container-expanded': 'chevron-down',
    'watch-expressions-add': 'add',
    'watch-expressions-add-function-breakpoint': 'add',
    'watch-expressions-remove-all': 'close-all',
    'watch-view-icon': 'debug-alt',
    'widget-close': 'close',
    'workspace-trust-editor-label-icon': ' shield'
};
const registry = (0, iconRegistry_1.getIconRegistry)();
for (const key in codeIconMap) {
    if (codeIconMap.hasOwnProperty(key)) {
        registry.registerIcon(key, { id: codeIconMap[key] }, key);
    }
}


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/theming-main.js"
/*!*****************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/theming-main.js ***!
  \*****************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ThemingMainImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/bafca191f55a234fad20ab67bb689aacc80e7a1a/src/vs/workbench/api/browser/mainThreadTheming.ts
class ThemingMainImpl {
    constructor(rpc, themeService) {
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.THEMING_EXT);
        this.themeChangeListener = themeService.onDidColorThemeChange(e => this.proxy.$onColorThemeChange(e.newTheme.type));
        this.proxy.$onColorThemeChange(themeService.getCurrentTheme().type);
    }
    dispose() {
        this.themeChangeListener.dispose();
    }
}
exports.ThemingMainImpl = ThemingMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/timeline-main.js"
/*!******************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/timeline-main.js ***!
  \******************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimelineMainImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const timeline_service_1 = __webpack_require__(/*! @theia/timeline/lib/browser/timeline-service */ "../../node_modules/@theia/timeline/lib/browser/timeline-service.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../../node_modules/@theia/core/lib/common/index.js");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/afacd2bdfe7060f09df9b9139521718915949757/src/vs/workbench/api/browser/mainThreadTimeline.ts
class TimelineMainImpl {
    constructor(rpc, container) {
        this.providerEmitters = new Map();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.TIMELINE_EXT);
        this.timelineService = container.get(timeline_service_1.TimelineService);
    }
    async $registerTimelineProvider(provider) {
        const proxy = this.proxy;
        const emitters = this.providerEmitters;
        let onDidChange = emitters.get(provider.id);
        if (onDidChange === undefined) {
            onDidChange = new common_1.Emitter();
            emitters.set(provider.id, onDidChange);
        }
        this.timelineService.registerTimelineProvider({
            ...provider,
            onDidChange: onDidChange.event,
            provideTimeline(uri, options, internalOptions) {
                return proxy.$getTimeline(provider.id, uri, options, internalOptions);
            },
            dispose() {
                emitters.delete(provider.id);
                if (onDidChange) {
                    onDidChange.dispose();
                }
            }
        });
    }
    async $unregisterTimelineProvider(id) {
        this.timelineService.unregisterTimelineProvider(id);
    }
    async $fireTimelineChanged(e) {
        const emitter = this.providerEmitters.get(e.id);
        if (emitter) {
            emitter.fire(e);
        }
    }
}
exports.TimelineMainImpl = TimelineMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/uri-main.js"
/*!*************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/uri-main.js ***!
  \*************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2024 STMicroelectronics.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UriMainImpl = void 0;
const common_1 = __webpack_require__(/*! ../../common */ "../../node_modules/@theia/plugin-ext/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const frontend_application_config_provider_1 = __webpack_require__(/*! @theia/core/lib/browser/frontend-application-config-provider */ "../../node_modules/@theia/core/lib/browser/frontend-application-config-provider.js");
const hosted_plugin_1 = __webpack_require__(/*! ../../hosted/browser/hosted-plugin */ "../../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin.js");
class UriMainImpl {
    constructor(rpc, container) {
        var _a, _b;
        this.handlers = new Set();
        this.proxy = rpc.getProxy(common_1.MAIN_RPC_CONTEXT.URI_EXT);
        this.openerService = container.get(browser_1.OpenerService);
        this.pluginSupport = container.get(hosted_plugin_1.HostedPluginSupport);
        this.openHandler = {
            id: 'theia-plugin-open-handler',
            canHandle: async (uri, options) => {
                if (uri.scheme !== frontend_application_config_provider_1.FrontendApplicationConfigProvider.get().electron.uriScheme) {
                    return 0;
                }
                await this.pluginSupport.activateByUri(uri.scheme, uri.authority);
                if (this.handlers.has(uri.authority)) {
                    return 500;
                }
                return 0;
            },
            open: async (uri, options) => {
                if (!this.handlers.has(uri.authority)) {
                    throw new Error(`No plugin to handle this uri: : '${uri}'`);
                }
                this.proxy.$handleExternalUri(uri.toComponents());
            }
        };
        (_b = (_a = this.openerService).addHandler) === null || _b === void 0 ? void 0 : _b.call(_a, this.openHandler);
    }
    dispose() {
        var _a, _b;
        (_b = (_a = this.openerService).removeHandler) === null || _b === void 0 ? void 0 : _b.call(_a, this.openHandler);
        this.handlers.clear();
    }
    async $registerUriHandler(pluginId, extensionDisplayName) {
        this.handlers.add(pluginId);
    }
    async $unregisterUriHandler(pluginId) {
        this.handlers.delete(pluginId);
    }
}
exports.UriMainImpl = UriMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/dnd-file-content-store.js"
/*!********************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/view/dnd-file-content-store.js ***!
  \********************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var DnDFileContentStore_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DnDFileContentStore = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
let DnDFileContentStore = DnDFileContentStore_1 = class DnDFileContentStore {
    constructor() {
        this.files = new Map();
    }
    addFile(f) {
        const id = (DnDFileContentStore_1.id++).toString();
        this.files.set(id, f);
        return id;
    }
    removeFile(id) {
        return this.files.delete(id);
    }
    getFile(id) {
        const file = this.files.get(id);
        if (file) {
            return file;
        }
        throw new Error(`File with id ${id} not found in dnd operation`);
    }
};
exports.DnDFileContentStore = DnDFileContentStore;
DnDFileContentStore.id = 0;
exports.DnDFileContentStore = DnDFileContentStore = DnDFileContentStore_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], DnDFileContentStore);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-tree-view-node-label-provider.js"
/*!**********************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-tree-view-node-label-provider.js ***!
  \**********************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginTreeViewNodeLabelProvider = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../../node_modules/@theia/core/lib/common/uri.js");
const label_provider_1 = __webpack_require__(/*! @theia/core/lib/browser/label-provider */ "../../node_modules/@theia/core/lib/browser/label-provider.js");
const tree_label_provider_1 = __webpack_require__(/*! @theia/core/lib/browser/tree/tree-label-provider */ "../../node_modules/@theia/core/lib/browser/tree/tree-label-provider.js");
const tree_1 = __webpack_require__(/*! @theia/core/lib/browser/tree/tree */ "../../node_modules/@theia/core/lib/browser/tree/tree.js");
const themables_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/base/common/themables */ "../../node_modules/@theia/monaco-editor-core/esm/vs/base/common/themables.js");
let PluginTreeViewNodeLabelProvider = class PluginTreeViewNodeLabelProvider {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    canHandle(element) {
        if (tree_1.TreeNode.is(element) && ('resourceUri' in element || 'themeIcon' in element)) {
            return Number.MAX_SAFE_INTEGER - 512;
        }
        return 0;
    }
    getIcon(node) {
        if (node.icon) {
            return node.icon;
        }
        if (node.themeIcon) {
            if (node.themeIcon.id === 'file' || node.themeIcon.id === 'folder') {
                const uri = node.resourceUri && new uri_1.default(node.resourceUri) || undefined;
                if (uri) {
                    return this.labelProvider.getIcon(label_provider_1.URIIconReference.create(node.themeIcon.id, uri));
                }
            }
            return themables_1.ThemeIcon.asClassName(node.themeIcon);
        }
        if (node.resourceUri) {
            return this.labelProvider.getIcon(new uri_1.default(node.resourceUri));
        }
        return undefined;
    }
    getName(node) {
        if (node.name) {
            return node.name;
        }
        if (node.resourceUri) {
            return this.labelProvider.getName(new uri_1.default(node.resourceUri));
        }
        return undefined;
    }
    getLongName(node) {
        if (typeof node.description === 'string') {
            return node.description;
        }
        if (node.description === true && node.resourceUri) {
            return this.labelProvider.getLongName(new uri_1.default(node.resourceUri));
        }
        return undefined;
    }
};
exports.PluginTreeViewNodeLabelProvider = PluginTreeViewNodeLabelProvider;
tslib_1.__decorate([
    (0, inversify_1.inject)(label_provider_1.LabelProvider),
    tslib_1.__metadata("design:type", label_provider_1.LabelProvider)
], PluginTreeViewNodeLabelProvider.prototype, "labelProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(tree_label_provider_1.TreeLabelProvider),
    tslib_1.__metadata("design:type", tree_label_provider_1.TreeLabelProvider)
], PluginTreeViewNodeLabelProvider.prototype, "treeLabelProvider", void 0);
exports.PluginTreeViewNodeLabelProvider = PluginTreeViewNodeLabelProvider = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginTreeViewNodeLabelProvider);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-registry.js"
/*!******************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-registry.js ***!
  \******************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
var PluginViewRegistry_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginViewRegistry = exports.PLUGIN_VIEW_DATA_FACTORY_ID = exports.PLUGIN_VIEW_CONTAINER_FACTORY_ID = exports.PLUGIN_VIEW_FACTORY_ID = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const common_1 = __webpack_require__(/*! ../../../common */ "../../node_modules/@theia/plugin-ext/lib/common/index.js");
const plugin_shared_style_1 = __webpack_require__(/*! ../plugin-shared-style */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-shared-style.js");
const debug_widget_1 = __webpack_require__(/*! @theia/debug/lib/browser/view/debug-widget */ "../../node_modules/@theia/debug/lib/browser/view/debug-widget.js");
const plugin_view_widget_1 = __webpack_require__(/*! ./plugin-view-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-widget.js");
const scm_contribution_1 = __webpack_require__(/*! @theia/scm/lib/browser/scm-contribution */ "../../node_modules/@theia/scm/lib/browser/scm-contribution.js");
const browser_2 = __webpack_require__(/*! @theia/navigator/lib/browser */ "../../node_modules/@theia/navigator/lib/browser/index.js");
const navigator_contribution_1 = __webpack_require__(/*! @theia/navigator/lib/browser/navigator-contribution */ "../../node_modules/@theia/navigator/lib/browser/navigator-contribution.js");
const debug_frontend_application_contribution_1 = __webpack_require__(/*! @theia/debug/lib/browser/debug-frontend-application-contribution */ "../../node_modules/@theia/debug/lib/browser/debug-frontend-application-contribution.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const command_1 = __webpack_require__(/*! @theia/core/lib/common/command */ "../../node_modules/@theia/core/lib/common/command.js");
const menu_1 = __webpack_require__(/*! @theia/core/lib/common/menu */ "../../node_modules/@theia/core/lib/common/menu/index.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../node_modules/@theia/core/lib/common/event.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../../node_modules/@theia/core/lib/browser/context-key-service.js");
const view_context_key_service_1 = __webpack_require__(/*! ./view-context-key-service */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/view-context-key-service.js");
const problem_widget_1 = __webpack_require__(/*! @theia/markers/lib/browser/problem/problem-widget */ "../../node_modules/@theia/markers/lib/browser/problem/problem-widget.js");
const output_widget_1 = __webpack_require__(/*! @theia/output/lib/browser/output-widget */ "../../node_modules/@theia/output/lib/browser/output-widget.js");
const debug_console_contribution_1 = __webpack_require__(/*! @theia/debug/lib/browser/console/debug-console-contribution */ "../../node_modules/@theia/debug/lib/browser/console/debug-console-contribution.js");
const search_in_workspace_factory_1 = __webpack_require__(/*! @theia/search-in-workspace/lib/browser/search-in-workspace-factory */ "../../node_modules/@theia/search-in-workspace/lib/browser/search-in-workspace-factory.js");
const test_view_contribution_1 = __webpack_require__(/*! @theia/test/lib/browser/view/test-view-contribution */ "../../node_modules/@theia/test/lib/browser/view/test-view-contribution.js");
const webview_1 = __webpack_require__(/*! ../webview/webview */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview.js");
const cancellation_1 = __webpack_require__(/*! @theia/core/lib/common/cancellation */ "../../node_modules/@theia/core/lib/common/cancellation.js");
const uuid_1 = __webpack_require__(/*! @theia/core/lib/common/uuid */ "../../node_modules/@theia/core/lib/common/uuid.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../../node_modules/@theia/core/lib/common/promise-util.js");
const themables_1 = __webpack_require__(/*! @theia/monaco-editor-core/esm/vs/base/common/themables */ "../../node_modules/@theia/monaco-editor-core/esm/vs/base/common/themables.js");
exports.PLUGIN_VIEW_FACTORY_ID = 'plugin-view';
exports.PLUGIN_VIEW_CONTAINER_FACTORY_ID = 'plugin-view-container';
exports.PLUGIN_VIEW_DATA_FACTORY_ID = 'plugin-view-data';
let PluginViewRegistry = PluginViewRegistry_1 = class PluginViewRegistry {
    constructor() {
        this.onDidExpandViewEmitter = new event_1.Emitter();
        this.onDidExpandView = this.onDidExpandViewEmitter.event;
        this.views = new Map();
        this.viewsWelcome = new Map();
        this.viewContainers = new Map();
        this.containerViews = new Map();
        this.viewClauseContexts = new Map();
        this.viewDataProviders = new Map();
        this.viewDataState = new Map();
        this.webviewViewResolvers = new Map();
        this.onNewResolverRegisteredEmitter = new event_1.Emitter();
        this.onNewResolverRegistered = this.onNewResolverRegisteredEmitter.event;
        this.webviewViewRevivals = new Map();
        this.nextViewContainerId = 0;
    }
    init() {
        // TODO workbench.panel.comments - Theia does not have a proper comments view yet
        this.updateFocusedView();
        this.shell.onDidChangeActiveWidget(() => this.updateFocusedView());
        this.widgetManager.onWillCreateWidget(({ factoryId, widget, waitUntil }) => {
            if (factoryId === browser_2.EXPLORER_VIEW_CONTAINER_ID && widget instanceof browser_1.ViewContainer) {
                waitUntil(this.prepareViewContainer('explorer', widget));
            }
            if (factoryId === scm_contribution_1.SCM_VIEW_CONTAINER_ID && widget instanceof browser_1.ViewContainer) {
                waitUntil(this.prepareViewContainer('scm', widget));
            }
            if (factoryId === search_in_workspace_factory_1.SEARCH_VIEW_CONTAINER_ID && widget instanceof browser_1.ViewContainer) {
                waitUntil(this.prepareViewContainer('search', widget));
            }
            if (factoryId === test_view_contribution_1.TEST_VIEW_CONTAINER_ID && widget instanceof browser_1.ViewContainer) {
                waitUntil(this.prepareViewContainer('test', widget));
            }
            if (factoryId === debug_widget_1.DebugWidget.ID && widget instanceof debug_widget_1.DebugWidget) {
                const viewContainer = widget['sessionWidget']['viewContainer'];
                waitUntil(this.prepareViewContainer('debug', viewContainer));
            }
            if (factoryId === exports.PLUGIN_VIEW_CONTAINER_FACTORY_ID && widget instanceof browser_1.ViewContainer) {
                waitUntil(this.prepareViewContainer(this.toViewContainerId(widget.options), widget));
            }
            if (factoryId === exports.PLUGIN_VIEW_FACTORY_ID && widget instanceof plugin_view_widget_1.PluginViewWidget) {
                waitUntil(this.prepareView(widget));
            }
        });
        this.widgetManager.onDidCreateWidget(event => {
            if (event.widget instanceof browser_2.FileNavigatorWidget) {
                const disposable = new disposable_1.DisposableCollection();
                disposable.push(this.registerViewWelcome({
                    view: 'explorer',
                    content: core_1.nls.localizeByDefault('You have not yet opened a folder.\n{0}', `[${core_1.nls.localizeByDefault('Open Folder')}](command:workbench.action.files.openFolder)`),
                    order: 0
                }));
                disposable.push(event.widget.onDidDispose(() => disposable.dispose()));
            }
        });
        this.contextKeyService.onDidChange(e => {
            for (const [, view] of this.views.values()) {
                const clauseContext = this.viewClauseContexts.get(view.id);
                if (clauseContext && e.affects(clauseContext)) {
                    this.updateViewVisibility(view.id);
                }
            }
            for (const [viewId, viewWelcomes] of this.viewsWelcome) {
                for (const [index] of viewWelcomes.entries()) {
                    const viewWelcomeId = this.toViewWelcomeId(index, viewId);
                    const clauseContext = this.viewClauseContexts.get(viewWelcomeId);
                    if (clauseContext && e.affects(clauseContext)) {
                        this.updateViewWelcomeVisibility(viewId);
                    }
                }
            }
        });
        const hookDockPanelKey = (panel, key) => {
            let toDisposeOnActivate = new disposable_1.DisposableCollection();
            panel.onDidChangeCurrent(title => {
                toDisposeOnActivate.dispose();
                toDisposeOnActivate = new disposable_1.DisposableCollection();
                if (title && title.owner instanceof browser_1.BaseWidget) {
                    const widget = title.owner;
                    let value = PluginViewRegistry_1.ID_MAPPINGS.get(widget.id);
                    if (!value) {
                        if (widget.id.startsWith(exports.PLUGIN_VIEW_CONTAINER_FACTORY_ID)) {
                            value = this.toViewContainerId({ id: widget.id });
                        }
                    }
                    const setKey = () => {
                        if (widget.isVisible && value) {
                            key.set(value);
                        }
                        else {
                            key.reset();
                        }
                    };
                    toDisposeOnActivate.push(widget.onDidChangeVisibility(() => {
                        setKey();
                    }));
                    setKey();
                }
            });
        };
        this.shell.initialized.then(() => {
            hookDockPanelKey(this.shell.leftPanelHandler.dockPanel, this.viewContextKeys.activeViewlet);
            hookDockPanelKey(this.shell.rightPanelHandler.dockPanel, this.viewContextKeys.activeAuxiliary);
            hookDockPanelKey(this.shell.bottomPanel, this.viewContextKeys.activePanel);
        });
    }
    async updateViewWelcomeVisibility(viewId) {
        const widget = await this.getTreeViewWelcomeWidget(viewId);
        if (widget) {
            widget.handleWelcomeContextChange();
        }
    }
    async updateViewVisibility(viewId) {
        const widget = await this.getView(viewId);
        if (!widget) {
            if (this.isViewVisible(viewId)) {
                await this.openView(viewId);
            }
            return;
        }
        const viewInfo = this.views.get(viewId);
        if (!viewInfo) {
            return;
        }
        const [viewContainerId] = viewInfo;
        const viewContainer = await this.getPluginViewContainer(viewContainerId);
        if (!viewContainer) {
            return;
        }
        const part = viewContainer.getPartFor(widget);
        if (!part) {
            return;
        }
        widget.updateViewVisibility(() => part.setHidden(!this.isViewVisible(viewId)));
    }
    isViewVisible(viewId) {
        const viewInfo = this.views.get(viewId);
        if (!viewInfo) {
            return false;
        }
        const [, view] = viewInfo;
        return view.when === undefined || view.when === 'true' || this.contextKeyService.match(view.when);
    }
    registerViewContainer(location, viewContainer) {
        var _a;
        const containerId = `workbench.view.extension.${viewContainer.id}`;
        if (this.viewContainers.has(containerId)) {
            console.warn('view container such id already registered: ', JSON.stringify(viewContainer));
            return disposable_1.Disposable.NULL;
        }
        const toDispose = new disposable_1.DisposableCollection();
        const containerClass = 'theia-plugin-view-container';
        let themeIconClass = '';
        const iconClass = 'plugin-view-container-icon-' + this.nextViewContainerId++; // having dots in class would not work for css, so we need to generate an id.
        if (viewContainer.themeIcon) {
            const icon = themables_1.ThemeIcon.fromString(viewContainer.themeIcon);
            if (icon) {
                themeIconClass = (_a = themables_1.ThemeIcon.asClassName(icon)) !== null && _a !== void 0 ? _a : '';
            }
        }
        if (!themeIconClass) {
            const iconUrl = plugin_shared_style_1.PluginSharedStyle.toExternalIconUrl(viewContainer.iconUrl);
            toDispose.push(this.style.insertRule('.' + containerClass + '.' + iconClass, () => `
                mask: url('${iconUrl}') no-repeat 50% 50%;
                -webkit-mask: url('${iconUrl}') no-repeat 50% 50%;
            `));
        }
        toDispose.push(this.doRegisterViewContainer(containerId, location, {
            label: viewContainer.title,
            // The container class automatically sets a mask; if we're using a theme icon, we don't want one.
            iconClass: (themeIconClass || containerClass) + ' ' + iconClass,
            closeable: true
        }));
        return toDispose;
    }
    async toggleViewContainer(id) {
        let widget = await this.getPluginViewContainer(id);
        if (widget && widget.isAttached) {
            widget.dispose();
        }
        else {
            widget = await this.openViewContainer(id);
            if (widget) {
                this.shell.activateWidget(widget.id);
            }
        }
    }
    doRegisterViewContainer(id, location, options) {
        const toDispose = new disposable_1.DisposableCollection();
        toDispose.push(disposable_1.Disposable.create(() => this.viewContainers.delete(id)));
        const toggleCommandId = `plugin.view-container.${id}.toggle`;
        // Some plugins may register empty view containers.
        // We should not register commands for them immediately, as that leads to bad UX.
        // Instead, we register commands the first time we add a view to them.
        let activate = () => {
            var _a;
            toDispose.push(this.commands.registerCommand({
                id: toggleCommandId,
                category: core_1.nls.localizeByDefault('View'),
                label: core_1.nls.localizeByDefault('Toggle {0}', options.label)
            }, {
                execute: () => this.toggleViewContainer(id)
            }));
            toDispose.push(this.menus.registerMenuAction(browser_1.CommonMenus.VIEW_VIEWS, {
                commandId: toggleCommandId,
                label: options.label
            }));
            toDispose.push((_a = this.quickView) === null || _a === void 0 ? void 0 : _a.registerItem({
                label: options.label,
                open: async () => {
                    const widget = await this.openViewContainer(id);
                    if (widget) {
                        this.shell.activateWidget(widget.id);
                    }
                }
            }));
            toDispose.push(disposable_1.Disposable.create(async () => {
                const widget = await this.getPluginViewContainer(id);
                if (widget) {
                    widget.dispose();
                }
            }));
            // Ignore every subsequent activation call
            activate = () => { };
        };
        this.viewContainers.set(id, {
            id,
            location,
            options,
            onViewAdded: () => activate()
        });
        return toDispose;
    }
    getContainerViews(viewContainerId) {
        return this.containerViews.get(viewContainerId) || [];
    }
    registerView(viewContainerId, view) {
        var _a, _b;
        if (!PluginViewRegistry_1.BUILTIN_VIEW_CONTAINERS.has(viewContainerId)) {
            // if it's not a built-in view container, it must be a contributed view container, see https://github.com/eclipse-theia/theia/issues/13249
            viewContainerId = `workbench.view.extension.${viewContainerId}`;
        }
        if (this.views.has(view.id)) {
            console.warn('view with such id already registered: ', JSON.stringify(view));
            return disposable_1.Disposable.NULL;
        }
        const toDispose = new disposable_1.DisposableCollection();
        view.when = (_a = view.when) === null || _a === void 0 ? void 0 : _a.trim();
        this.views.set(view.id, [viewContainerId, view]);
        toDispose.push(disposable_1.Disposable.create(() => this.views.delete(view.id)));
        const containerInfo = this.viewContainers.get(viewContainerId);
        if (containerInfo) {
            containerInfo.onViewAdded();
        }
        const containerViews = this.getContainerViews(viewContainerId);
        containerViews.push(view.id);
        this.containerViews.set(viewContainerId, containerViews);
        toDispose.push(disposable_1.Disposable.create(() => {
            const index = containerViews.indexOf(view.id);
            if (index !== -1) {
                containerViews.splice(index, 1);
            }
        }));
        if (view.when && view.when !== 'false' && view.when !== 'true') {
            const keys = this.contextKeyService.parseKeys(view.when);
            if (keys) {
                this.viewClauseContexts.set(view.id, keys);
                toDispose.push(disposable_1.Disposable.create(() => this.viewClauseContexts.delete(view.id)));
            }
        }
        toDispose.push((_b = this.quickView) === null || _b === void 0 ? void 0 : _b.registerItem({
            label: view.name,
            when: view.when,
            open: () => this.openView(view.id, { activate: true })
        }));
        toDispose.push(this.commands.registerCommand({ id: `${view.id}.focus` }, {
            execute: async () => { await this.openView(view.id, { activate: true }); }
        }));
        toDispose.push(this.commands.registerCommand({ id: `${view.id}.open` }, {
            execute: async () => { await this.openView(view.id, { activate: true }); }
        }));
        return toDispose;
    }
    async resolveWebviewView(viewId, webview, cancellation) {
        const resolver = this.webviewViewResolvers.get(viewId);
        if (resolver) {
            return resolver.resolve(webview, cancellation);
        }
        const pendingRevival = this.webviewViewRevivals.get(viewId);
        if (pendingRevival) {
            return pendingRevival.revival.promise;
        }
        const pending = new promise_util_1.Deferred();
        this.webviewViewRevivals.set(viewId, { webview, revival: pending });
        return pending.promise;
    }
    async registerWebviewView(viewId, resolver) {
        if (this.webviewViewResolvers.has(viewId)) {
            throw new Error(`View resolver already registered for ${viewId}`);
        }
        this.webviewViewResolvers.set(viewId, resolver);
        this.onNewResolverRegisteredEmitter.fire({ viewType: viewId });
        const toDispose = new disposable_1.DisposableCollection(disposable_1.Disposable.create(() => this.webviewViewResolvers.delete(viewId)));
        this.initView(viewId, toDispose);
        const pendingRevival = this.webviewViewRevivals.get(viewId);
        if (pendingRevival) {
            resolver.resolve(pendingRevival.webview, cancellation_1.CancellationToken.None).then(() => {
                this.webviewViewRevivals.delete(viewId);
                pendingRevival.revival.resolve();
            });
        }
        return toDispose;
    }
    async createNewWebviewView(viewId) {
        const webview = await this.widgetManager.getOrCreateWidget(webview_1.WebviewWidget.FACTORY_ID, {
            id: (0, uuid_1.generateUuid)(),
            viewId,
        });
        webview.setContentOptions({ allowScripts: true });
        let _description;
        let _resolved = false;
        let _pendingResolution;
        const webviewView = {
            webview,
            get onDidChangeVisibility() { return webview.onDidChangeVisibility; },
            get onDidDispose() { return webview.onDidDispose; },
            get title() { return webview.title.label; },
            set title(value) { webview.title.label = value || ''; },
            get description() { return _description; },
            set description(value) { _description = value; },
            dispose: () => {
                _resolved = false;
                webview.dispose();
                toDispose.dispose();
            },
            resolve: async () => {
                if (_resolved) {
                    return;
                }
                if (_pendingResolution) {
                    return _pendingResolution;
                }
                _pendingResolution = this.resolveWebviewView(viewId, webviewView, cancellation_1.CancellationToken.None).then(() => {
                    _resolved = true;
                    _pendingResolution = undefined;
                });
                return _pendingResolution;
            },
            show: webview.show
        };
        const toDispose = this.onNewResolverRegistered(resolver => {
            if (resolver.viewType === viewId) {
                // Potentially re-activate if we have a new resolver
                webviewView.resolve();
            }
        });
        webviewView.resolve();
        return webviewView;
    }
    registerViewWelcome(viewWelcome) {
        const toDispose = new disposable_1.DisposableCollection();
        const viewsWelcome = this.viewsWelcome.get(viewWelcome.view) || [];
        if (viewsWelcome.some(e => e.content === viewWelcome.content)) {
            return toDispose;
        }
        viewsWelcome.push(viewWelcome);
        this.viewsWelcome.set(viewWelcome.view, viewsWelcome);
        this.handleViewWelcomeChange(viewWelcome.view);
        toDispose.push(disposable_1.Disposable.create(() => {
            const index = viewsWelcome.indexOf(viewWelcome);
            if (index !== -1) {
                viewsWelcome.splice(index, 1);
            }
            this.handleViewWelcomeChange(viewWelcome.view);
        }));
        if (viewWelcome.when) {
            const index = viewsWelcome.indexOf(viewWelcome);
            const viewWelcomeId = this.toViewWelcomeId(index, viewWelcome.view);
            this.viewClauseContexts.set(viewWelcomeId, this.contextKeyService.parseKeys(viewWelcome.when));
            toDispose.push(disposable_1.Disposable.create(() => this.viewClauseContexts.delete(viewWelcomeId)));
        }
        return toDispose;
    }
    async handleViewWelcomeChange(viewId) {
        const widget = await this.getTreeViewWelcomeWidget(viewId);
        if (widget) {
            widget.handleViewWelcomeContentChange(this.getViewWelcomes(viewId));
        }
    }
    async getTreeViewWelcomeWidget(viewId) {
        switch (viewId) {
            case 'explorer':
                return this.widgetManager.getWidget(browser_2.FILE_NAVIGATOR_ID);
            default:
                return this.widgetManager.getWidget(exports.PLUGIN_VIEW_DATA_FACTORY_ID, { id: viewId });
        }
    }
    getViewWelcomes(viewId) {
        return this.viewsWelcome.get(viewId) || [];
    }
    async getView(viewId) {
        if (!this.views.has(viewId)) {
            return undefined;
        }
        return this.widgetManager.getWidget(exports.PLUGIN_VIEW_FACTORY_ID, this.toPluginViewWidgetIdentifier(viewId));
    }
    async openView(viewId, options) {
        const view = await this.doOpenView(viewId);
        if (view && options) {
            if (options.activate === true) {
                await this.shell.activateWidget(view.id);
            }
            else if (options.reveal === true) {
                await this.shell.revealWidget(view.id);
            }
        }
        return view;
    }
    async doOpenView(viewId) {
        const widget = await this.getView(viewId);
        if (widget) {
            return widget;
        }
        const data = this.views.get(viewId);
        if (!data) {
            return undefined;
        }
        const [containerId] = data;
        await this.openViewContainer(containerId);
        return this.getView(viewId);
    }
    async prepareView(widget) {
        var _a;
        const data = this.views.get(widget.options.viewId);
        if (!data) {
            return;
        }
        const [, view] = data;
        if (!widget.title.label) {
            widget.title.label = view.name;
        }
        const currentDataWidget = widget.widgets[0];
        const webviewId = currentDataWidget instanceof webview_1.WebviewWidget ? (_a = currentDataWidget.identifier) === null || _a === void 0 ? void 0 : _a.id : undefined;
        const viewDataWidget = await this.createViewDataWidget(view.id, webviewId);
        if (widget.isDisposed) {
            viewDataWidget === null || viewDataWidget === void 0 ? void 0 : viewDataWidget.dispose();
            return;
        }
        if (currentDataWidget !== viewDataWidget) {
            if (currentDataWidget) {
                currentDataWidget.dispose();
            }
            if (viewDataWidget) {
                widget.addWidget(viewDataWidget);
            }
        }
    }
    getOrCreateViewContainerWidget(containerId) {
        const identifier = this.toViewContainerIdentifier(containerId);
        return this.widgetManager.getOrCreateWidget(exports.PLUGIN_VIEW_CONTAINER_FACTORY_ID, identifier);
    }
    async openViewContainer(containerId) {
        if (containerId === 'explorer') {
            const widget = await this.explorer.openView();
            if (widget.parent instanceof browser_1.ViewContainer) {
                return widget.parent;
            }
            return undefined;
        }
        if (containerId === 'scm') {
            const widget = await this.scm.openView();
            if (widget.parent instanceof browser_1.ViewContainer) {
                return widget.parent;
            }
            return undefined;
        }
        if (containerId === 'debug') {
            const widget = await this.debug.openView();
            return widget['sessionWidget']['viewContainer'];
        }
        const data = this.viewContainers.get(containerId);
        if (!data) {
            return undefined;
        }
        const { location } = data;
        const containerWidget = await this.getOrCreateViewContainerWidget(containerId);
        if (!containerWidget.isAttached) {
            await this.shell.addWidget(containerWidget, {
                area: browser_1.ApplicationShell.isSideArea(location) ? location : 'left',
                rank: Number.MAX_SAFE_INTEGER
            });
        }
        return containerWidget;
    }
    async prepareViewContainer(viewContainerId, containerWidget) {
        const data = this.viewContainers.get(viewContainerId);
        if (data) {
            const { options } = data;
            containerWidget.setTitleOptions(options);
        }
        for (const viewId of this.getContainerViews(viewContainerId)) {
            const identifier = this.toPluginViewWidgetIdentifier(viewId);
            // Keep existing widget in its current container and reregister its part to the plugin view widget events.
            const existingWidget = this.widgetManager.tryGetWidget(exports.PLUGIN_VIEW_FACTORY_ID, identifier);
            if (existingWidget && existingWidget.currentViewContainerId) {
                const currentContainer = await this.getPluginViewContainer(existingWidget.currentViewContainerId);
                if (currentContainer && this.registerWidgetPartEvents(existingWidget, currentContainer)) {
                    continue;
                }
            }
            const widget = await this.widgetManager.getOrCreateWidget(exports.PLUGIN_VIEW_FACTORY_ID, identifier);
            if (containerWidget.getTrackableWidgets().indexOf(widget) === -1) {
                containerWidget.addWidget(widget, {
                    initiallyCollapsed: !!containerWidget.getParts().length,
                    initiallyHidden: !this.isViewVisible(viewId)
                });
            }
            this.registerWidgetPartEvents(widget, containerWidget);
        }
    }
    registerWidgetPartEvents(widget, containerWidget) {
        const part = containerWidget.getPartFor(widget);
        if (part) {
            widget.currentViewContainerId = this.getViewContainerId(containerWidget);
            part.onDidMove(event => { widget.currentViewContainerId = this.getViewContainerId(event); });
            // if a view is explicitly hidden then suppress updating visibility based on `when` closure
            part.onDidChangeVisibility(() => widget.suppressUpdateViewVisibility = part.isHidden);
            const tryFireOnDidExpandView = () => {
                if (widget.widgets.length === 0) {
                    if (!part.collapsed && part.isVisible) {
                        const viewId = this.toViewId(widget.options);
                        this.onDidExpandViewEmitter.fire(viewId);
                    }
                }
                else {
                    toFire.dispose();
                }
            };
            const toFire = new disposable_1.DisposableCollection(part.onCollapsed(tryFireOnDidExpandView), part.onDidChangeVisibility(tryFireOnDidExpandView));
            tryFireOnDidExpandView();
            return part;
        }
    }
    ;
    getViewContainerId(container) {
        var _a;
        const description = this.widgetManager.getDescription(container);
        switch (description === null || description === void 0 ? void 0 : description.factoryId) {
            case browser_2.EXPLORER_VIEW_CONTAINER_ID: return 'explorer';
            case scm_contribution_1.SCM_VIEW_CONTAINER_ID: return 'scm';
            case search_in_workspace_factory_1.SEARCH_VIEW_CONTAINER_ID: return 'search';
            case test_view_contribution_1.TEST_VIEW_CONTAINER_ID: return 'test';
            case undefined: return ((_a = container.parent) === null || _a === void 0 ? void 0 : _a.parent) instanceof debug_widget_1.DebugWidget ? 'debug' : container.id;
            case exports.PLUGIN_VIEW_CONTAINER_FACTORY_ID: return this.toViewContainerId(description.options);
            default: return container.id;
        }
    }
    async getPluginViewContainer(viewContainerId) {
        if (viewContainerId === 'explorer') {
            return this.widgetManager.getWidget(browser_2.EXPLORER_VIEW_CONTAINER_ID);
        }
        if (viewContainerId === 'scm') {
            return this.widgetManager.getWidget(scm_contribution_1.SCM_VIEW_CONTAINER_ID);
        }
        if (viewContainerId === 'search') {
            return this.widgetManager.getWidget(search_in_workspace_factory_1.SEARCH_VIEW_CONTAINER_ID);
        }
        if (viewContainerId === 'test') {
            return this.widgetManager.getWidget(test_view_contribution_1.TEST_VIEW_CONTAINER_ID);
        }
        if (viewContainerId === 'debug') {
            const debug = await this.widgetManager.getWidget(debug_widget_1.DebugWidget.ID);
            if (debug instanceof debug_widget_1.DebugWidget) {
                return debug['sessionWidget']['viewContainer'];
            }
        }
        const identifier = this.toViewContainerIdentifier(viewContainerId);
        return this.widgetManager.getWidget(exports.PLUGIN_VIEW_CONTAINER_FACTORY_ID, identifier);
    }
    async initViewContainer(containerId) {
        let viewContainer = await this.getPluginViewContainer(containerId);
        if (!viewContainer) {
            viewContainer = await this.openViewContainer(containerId);
            if (viewContainer && !viewContainer.getParts().filter(part => !part.isHidden).length) {
                // close view containers without any visible view parts
                viewContainer.dispose();
            }
        }
        else {
            await this.prepareViewContainer(this.toViewContainerId(viewContainer.options), viewContainer);
        }
    }
    async initWidgets() {
        const promises = [];
        for (const id of this.viewContainers.keys()) {
            promises.push((async () => {
                await this.initViewContainer(id);
            })().catch(console.error));
        }
        promises.push((async () => {
            const explorer = await this.widgetManager.getWidget(browser_2.EXPLORER_VIEW_CONTAINER_ID);
            if (explorer instanceof browser_1.ViewContainer) {
                await this.prepareViewContainer('explorer', explorer);
            }
        })().catch(console.error));
        promises.push((async () => {
            const scm = await this.widgetManager.getWidget(scm_contribution_1.SCM_VIEW_CONTAINER_ID);
            if (scm instanceof browser_1.ViewContainer) {
                await this.prepareViewContainer('scm', scm);
            }
        })().catch(console.error));
        promises.push((async () => {
            const search = await this.widgetManager.getWidget(search_in_workspace_factory_1.SEARCH_VIEW_CONTAINER_ID);
            if (search instanceof browser_1.ViewContainer) {
                await this.prepareViewContainer('search', search);
            }
        })().catch(console.error));
        promises.push((async () => {
            const test = await this.widgetManager.getWidget(test_view_contribution_1.TEST_VIEW_CONTAINER_ID);
            if (test instanceof browser_1.ViewContainer) {
                await this.prepareViewContainer('test', test);
            }
        })().catch(console.error));
        promises.push((async () => {
            const debug = await this.widgetManager.getWidget(debug_widget_1.DebugWidget.ID);
            if (debug instanceof debug_widget_1.DebugWidget) {
                const viewContainer = debug['sessionWidget']['viewContainer'];
                await this.prepareViewContainer('debug', viewContainer);
            }
        })().catch(console.error));
        await Promise.all(promises);
    }
    async removeStaleWidgets() {
        const views = this.widgetManager.getWidgets(exports.PLUGIN_VIEW_FACTORY_ID);
        for (const view of views) {
            if (view instanceof plugin_view_widget_1.PluginViewWidget) {
                const id = this.toViewId(view.options);
                if (!this.views.has(id)) {
                    view.dispose();
                }
            }
        }
        const viewContainers = this.widgetManager.getWidgets(exports.PLUGIN_VIEW_CONTAINER_FACTORY_ID);
        for (const viewContainer of viewContainers) {
            if (viewContainer instanceof browser_1.ViewContainer) {
                const id = this.toViewContainerId(viewContainer.options);
                if (!this.viewContainers.has(id)) {
                    viewContainer.dispose();
                }
            }
        }
    }
    toViewContainerIdentifier(viewContainerId) {
        return { id: exports.PLUGIN_VIEW_CONTAINER_FACTORY_ID + ':' + viewContainerId, progressLocationId: viewContainerId };
    }
    toViewContainerId(identifier) {
        return identifier.id.substring(exports.PLUGIN_VIEW_CONTAINER_FACTORY_ID.length + 1);
    }
    toPluginViewWidgetIdentifier(viewId) {
        return { id: exports.PLUGIN_VIEW_FACTORY_ID + ':' + viewId, viewId };
    }
    toViewId(identifier) {
        return identifier.viewId;
    }
    toViewWelcomeId(index, viewId) {
        return `view-welcome.${viewId}.${index}`;
    }
    /**
     * retrieve restored layout state from previous user session but close widgets
     * widgets should be opened only when view data providers are registered
     */
    onDidInitializeLayout() {
        const widgets = this.widgetManager.getWidgets(exports.PLUGIN_VIEW_DATA_FACTORY_ID);
        for (const widget of widgets) {
            if (browser_1.StatefulWidget.is(widget)) {
                const state = widget.storeState();
                if (state) {
                    this.viewDataState.set(widget.id, state);
                }
            }
            widget.dispose();
        }
    }
    registerViewDataProvider(viewId, provider) {
        if (this.viewDataProviders.has(viewId)) {
            console.error(`data provider for '${viewId}' view is already registered`);
            return disposable_1.Disposable.NULL;
        }
        this.viewDataProviders.set(viewId, provider);
        const toDispose = new disposable_1.DisposableCollection(disposable_1.Disposable.create(() => {
            this.viewDataProviders.delete(viewId);
            this.viewDataState.delete(viewId);
        }));
        this.initView(viewId, toDispose);
        return toDispose;
    }
    async initView(viewId, toDispose) {
        const view = await this.getView(viewId);
        if (toDispose.disposed) {
            return;
        }
        if (view) {
            if (view.isVisible) {
                await this.prepareView(view);
            }
            else {
                const toDisposeOnDidExpandView = new disposable_1.DisposableCollection(this.onDidExpandView(async (id) => {
                    if (id === viewId) {
                        unsubscribe();
                        await this.prepareView(view);
                    }
                }));
                const unsubscribe = () => toDisposeOnDidExpandView.dispose();
                view.disposed.connect(unsubscribe);
                toDisposeOnDidExpandView.push(disposable_1.Disposable.create(() => view.disposed.disconnect(unsubscribe)));
                toDispose.push(toDisposeOnDidExpandView);
            }
        }
    }
    async createViewDataWidget(viewId, webviewId) {
        var _a;
        const view = this.views.get(viewId);
        if (((_a = view === null || view === void 0 ? void 0 : view[1]) === null || _a === void 0 ? void 0 : _a.type) === common_1.PluginViewType.Webview) {
            return this.createWebviewWidget(viewId, webviewId);
        }
        const provider = this.viewDataProviders.get(viewId);
        if (!view || !provider) {
            return undefined;
        }
        const [, viewInfo] = view;
        const state = this.viewDataState.get(viewId);
        const widget = await provider({ state, viewInfo });
        widget.handleViewWelcomeContentChange(this.getViewWelcomes(viewId));
        if (browser_1.StatefulWidget.is(widget)) {
            this.storeViewDataStateOnDispose(viewId, widget);
        }
        else {
            this.viewDataState.delete(viewId);
        }
        return widget;
    }
    async createWebviewWidget(viewId, webviewId) {
        if (!webviewId) {
            const webviewView = await this.createNewWebviewView(viewId);
            webviewId = webviewView.webview.identifier.id;
        }
        const webviewWidget = this.widgetManager.getWidget(webview_1.WebviewWidget.FACTORY_ID, { id: webviewId, viewId });
        return webviewWidget;
    }
    storeViewDataStateOnDispose(viewId, widget) {
        const dispose = widget.dispose.bind(widget);
        widget.dispose = () => {
            const state = widget.storeState();
            if (state) {
                this.viewDataState.set(viewId, state);
            }
            dispose();
        };
    }
    isVisibleWidget(widget) {
        return !widget.isDisposed && widget.isVisible;
    }
    updateFocusedView() {
        const widget = this.shell.activeWidget;
        if (widget instanceof plugin_view_widget_1.PluginViewWidget) {
            this.viewContextKeys.focusedView.set(widget.options.viewId);
        }
        else {
            this.viewContextKeys.focusedView.reset();
        }
    }
};
exports.PluginViewRegistry = PluginViewRegistry;
PluginViewRegistry.BUILTIN_VIEW_CONTAINERS = new Set([
    'explorer',
    'scm',
    'search',
    'test',
    'debug'
]);
PluginViewRegistry.ID_MAPPINGS = new Map([
    // VS Code Viewlets
    [browser_2.EXPLORER_VIEW_CONTAINER_ID, 'workbench.view.explorer'],
    [scm_contribution_1.SCM_VIEW_CONTAINER_ID, 'workbench.view.scm'],
    [search_in_workspace_factory_1.SEARCH_VIEW_CONTAINER_ID, 'workbench.view.search'],
    [debug_widget_1.DebugWidget.ID, 'workbench.view.debug'],
    ['vsx-extensions-view-container', 'workbench.view.extensions'], // cannot use the id from 'vsx-registry' package because of circular dependency
    [problem_widget_1.PROBLEMS_WIDGET_ID, 'workbench.panel.markers'],
    [test_view_contribution_1.TEST_VIEW_CONTAINER_ID, 'workbench.view.testing'],
    [output_widget_1.OutputWidget.ID, 'workbench.panel.output'],
    [debug_console_contribution_1.DebugConsoleContribution.options.id, 'workbench.panel.repl'],
    // Theia does not have a single terminal widget, but instead each terminal gets its own widget. Therefore "the terminal widget is active" doesn't make sense in Theia
    // [TERMINAL_WIDGET_FACTORY_ID, 'workbench.panel.terminal'],
    // [?? , 'workbench.panel.comments'] not sure what this mean: we don't show comments in sidebars nor the bottom
]);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ApplicationShell),
    tslib_1.__metadata("design:type", browser_1.ApplicationShell)
], PluginViewRegistry.prototype, "shell", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_shared_style_1.PluginSharedStyle),
    tslib_1.__metadata("design:type", plugin_shared_style_1.PluginSharedStyle)
], PluginViewRegistry.prototype, "style", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.WidgetManager),
    tslib_1.__metadata("design:type", browser_1.WidgetManager)
], PluginViewRegistry.prototype, "widgetManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(scm_contribution_1.ScmContribution),
    tslib_1.__metadata("design:type", scm_contribution_1.ScmContribution)
], PluginViewRegistry.prototype, "scm", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(navigator_contribution_1.FileNavigatorContribution),
    tslib_1.__metadata("design:type", navigator_contribution_1.FileNavigatorContribution)
], PluginViewRegistry.prototype, "explorer", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(debug_frontend_application_contribution_1.DebugFrontendApplicationContribution),
    tslib_1.__metadata("design:type", debug_frontend_application_contribution_1.DebugFrontendApplicationContribution)
], PluginViewRegistry.prototype, "debug", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(command_1.CommandRegistry),
    tslib_1.__metadata("design:type", command_1.CommandRegistry)
], PluginViewRegistry.prototype, "commands", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(menu_1.MenuModelRegistry),
    tslib_1.__metadata("design:type", menu_1.MenuModelRegistry)
], PluginViewRegistry.prototype, "menus", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.QuickViewService),
    (0, inversify_1.optional)(),
    tslib_1.__metadata("design:type", browser_1.QuickViewService)
], PluginViewRegistry.prototype, "quickView", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], PluginViewRegistry.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(view_context_key_service_1.ViewContextKeyService),
    tslib_1.__metadata("design:type", view_context_key_service_1.ViewContextKeyService)
], PluginViewRegistry.prototype, "viewContextKeys", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], PluginViewRegistry.prototype, "init", null);
exports.PluginViewRegistry = PluginViewRegistry = PluginViewRegistry_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginViewRegistry);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-widget.js"
/*!****************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-widget.js ***!
  \****************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginViewWidget = exports.PluginViewWidgetIdentifier = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const widgets_1 = __webpack_require__(/*! @theia/core/shared/@lumino/widgets */ "../../node_modules/@theia/core/shared/@lumino/widgets/index.js");
const menu_1 = __webpack_require__(/*! @theia/core/lib/common/menu */ "../../node_modules/@theia/core/lib/common/menu/index.js");
const command_1 = __webpack_require__(/*! @theia/core/lib/common/command */ "../../node_modules/@theia/core/lib/common/command.js");
const tree_view_widget_1 = __webpack_require__(/*! ./tree-view-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/tree-view-widget.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../../node_modules/@theia/core/lib/common/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../../node_modules/@theia/core/lib/browser/context-key-service.js");
let PluginViewWidgetIdentifier = class PluginViewWidgetIdentifier {
};
exports.PluginViewWidgetIdentifier = PluginViewWidgetIdentifier;
exports.PluginViewWidgetIdentifier = PluginViewWidgetIdentifier = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginViewWidgetIdentifier);
let PluginViewWidget = class PluginViewWidget extends widgets_1.Panel {
    get onDidChangeToolbarItems() {
        return this.onDidChangeToolbarItemsEmitter.event;
    }
    constructor() {
        super();
        this._description = '';
        this._suppressUpdateViewVisibility = false;
        this.updatingViewVisibility = false;
        this.onDidChangeDescriptionEmitter = new common_1.Emitter();
        this.toDispose = new common_1.DisposableCollection(this.onDidChangeDescriptionEmitter);
        this.onDidChangeToolbarItemsEmitter = new common_1.Emitter();
        this.node.tabIndex = -1;
        this.node.style.height = '100%';
    }
    init() {
        this.id = this.options.id;
        const localContext = this.contextKeyService.createScoped(this.node);
        localContext.setContext('view', this.options.viewId);
    }
    get onDidChangeDescription() {
        return this.onDidChangeDescriptionEmitter.event;
    }
    onActivateRequest(msg) {
        super.onActivateRequest(msg);
        const widget = this.widgets[0];
        if (widget) {
            widget.activate();
            this.updateWidgetMessage();
        }
        else {
            this.node.focus();
        }
    }
    storeState() {
        return {
            label: this.title.label,
            message: this.message,
            widgets: this.widgets,
            suppressUpdateViewVisibility: this._suppressUpdateViewVisibility,
            currentViewContainerId: this.currentViewContainerId
        };
    }
    restoreState(state) {
        this.title.label = state.label;
        this.message = state.message;
        this.suppressUpdateViewVisibility = state.suppressUpdateViewVisibility;
        this.currentViewContainerId = state.currentViewContainerId;
        for (const widget of state.widgets) {
            this.addWidget(widget);
        }
    }
    set suppressUpdateViewVisibility(suppressUpdateViewVisibility) {
        this._suppressUpdateViewVisibility = !this.updatingViewVisibility && suppressUpdateViewVisibility;
    }
    updateViewVisibility(cb) {
        if (this._suppressUpdateViewVisibility) {
            return;
        }
        try {
            this.updatingViewVisibility = true;
            cb();
        }
        finally {
            this.updatingViewVisibility = false;
        }
    }
    get message() {
        return this._message;
    }
    set message(message) {
        this._message = message;
        this.updateWidgetMessage();
    }
    get description() {
        return this._description;
    }
    set description(description) {
        this._description = description;
        this.onDidChangeDescriptionEmitter.fire();
    }
    updateWidgetMessage() {
        const widget = this.widgets[0];
        if (widget) {
            if (widget instanceof tree_view_widget_1.TreeViewWidget) {
                widget.message = this._message;
            }
        }
    }
    addWidget(widget) {
        super.addWidget(widget);
        this.updateWidgetMessage();
        this.onDidChangeToolbarItemsEmitter.fire();
    }
    insertWidget(index, widget) {
        super.insertWidget(index, widget);
        this.updateWidgetMessage();
        this.onDidChangeToolbarItemsEmitter.fire();
    }
    dispose() {
        this.toDispose.dispose();
        super.dispose();
    }
};
exports.PluginViewWidget = PluginViewWidget;
tslib_1.__decorate([
    (0, inversify_1.inject)(menu_1.MenuModelRegistry),
    tslib_1.__metadata("design:type", menu_1.MenuModelRegistry)
], PluginViewWidget.prototype, "menus", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(command_1.CommandRegistry),
    tslib_1.__metadata("design:type", command_1.CommandRegistry)
], PluginViewWidget.prototype, "commands", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], PluginViewWidget.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(PluginViewWidgetIdentifier),
    tslib_1.__metadata("design:type", PluginViewWidgetIdentifier)
], PluginViewWidget.prototype, "options", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], PluginViewWidget.prototype, "init", null);
exports.PluginViewWidget = PluginViewWidget = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], PluginViewWidget);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/tree-view-decorator-service.js"
/*!*************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/view/tree-view-decorator-service.js ***!
  \*************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/********************************************************************************
 * Copyright (C) 2021 1C-Soft LLC and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
 ********************************************************************************/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bindTreeViewDecoratorUtilities = exports.TreeViewDecoratorService = exports.TreeViewDecoratorAdapter = exports.TreeViewDecorator = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const tree_decorator_1 = __webpack_require__(/*! @theia/core/lib/browser/tree/tree-decorator */ "../../node_modules/@theia/core/lib/browser/tree/tree-decorator.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../../node_modules/@theia/core/lib/common/uri.js");
const browser_1 = __webpack_require__(/*! @theia/filesystem/lib/browser */ "../../node_modules/@theia/filesystem/lib/browser/index.js");
exports.TreeViewDecorator = Symbol('TreeViewDecorator');
let TreeViewDecoratorAdapter = class TreeViewDecoratorAdapter extends browser_1.FileTreeDecoratorAdapter {
    getUriForNode(node) {
        if (this.isTreeItem(node)) {
            return new uri_1.default(node.resourceUri).toString();
        }
    }
    isTreeItem(node) {
        return (0, core_1.isObject)(node) && !!node.resourceUri;
    }
};
exports.TreeViewDecoratorAdapter = TreeViewDecoratorAdapter;
exports.TreeViewDecoratorAdapter = TreeViewDecoratorAdapter = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TreeViewDecoratorAdapter);
let TreeViewDecoratorService = class TreeViewDecoratorService extends tree_decorator_1.AbstractTreeDecoratorService {
    constructor(contributions) {
        super(contributions.getContributions());
    }
};
exports.TreeViewDecoratorService = TreeViewDecoratorService;
exports.TreeViewDecoratorService = TreeViewDecoratorService = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__param(0, (0, inversify_1.inject)(core_1.ContributionProvider)),
    tslib_1.__param(0, (0, inversify_1.named)(exports.TreeViewDecorator)),
    tslib_1.__metadata("design:paramtypes", [Object])
], TreeViewDecoratorService);
function bindTreeViewDecoratorUtilities(bind) {
    bind(TreeViewDecoratorAdapter).toSelf().inSingletonScope();
    (0, core_1.bindContributionProvider)(bind, exports.TreeViewDecorator);
    bind(exports.TreeViewDecorator).toService(TreeViewDecoratorAdapter);
}
exports.bindTreeViewDecoratorUtilities = bindTreeViewDecoratorUtilities;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/tree-view-widget.js"
/*!**************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/view/tree-view-widget.js ***!
  \**************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018-2019 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TreeViewWidget = exports.PluginTreeModel = exports.PluginTree = exports.TreeViewWidgetOptions = exports.CompositeTreeViewNode = exports.ResolvableCompositeTreeViewNode = exports.ResolvableTreeViewNode = exports.TreeViewNode = exports.VIEW_ITEM_INLINE_MENU = exports.VIEW_ITEM_CONTEXT_MENU = exports.TREE_NODE_HYPERLINK = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const menu_1 = __webpack_require__(/*! @theia/core/lib/common/menu */ "../../node_modules/@theia/core/lib/common/menu/index.js");
const React = __webpack_require__(/*! @theia/core/shared/react */ "../../node_modules/@theia/core/shared/react/index.js");
const plugin_shared_style_1 = __webpack_require__(/*! ../plugin-shared-style */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-shared-style.js");
const widget_1 = __webpack_require__(/*! @theia/core/lib/browser/widgets/widget */ "../../node_modules/@theia/core/lib/browser/widgets/widget.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../node_modules/@theia/core/lib/common/event.js");
const message_service_1 = __webpack_require__(/*! @theia/core/lib/common/message-service */ "../../node_modules/@theia/core/lib/common/message-service.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../../node_modules/@theia/core/lib/common/uri.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../../node_modules/@theia/core/lib/browser/context-key-service.js");
const markdown_rendering_1 = __webpack_require__(/*! @theia/core/lib/common/markdown-rendering */ "../../node_modules/@theia/core/lib/common/markdown-rendering/index.js");
const color_registry_1 = __webpack_require__(/*! @theia/core/lib/browser/color-registry */ "../../node_modules/@theia/core/lib/browser/color-registry.js");
const tree_decorator_1 = __webpack_require__(/*! @theia/core/lib/browser/tree/tree-decorator */ "../../node_modules/@theia/core/lib/browser/tree/tree-decorator.js");
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../../node_modules/@theia/core/lib/common/index.js");
const types_1 = __webpack_require__(/*! ../../../common/types */ "../../node_modules/@theia/plugin-ext/lib/common/types.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../../node_modules/@theia/core/lib/common/promise-util.js");
const dnd_file_content_store_1 = __webpack_require__(/*! ./dnd-file-content-store */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/dnd-file-content-store.js");
exports.TREE_NODE_HYPERLINK = 'theia-TreeNodeHyperlink';
exports.VIEW_ITEM_CONTEXT_MENU = ['view-item-context-menu'];
exports.VIEW_ITEM_INLINE_MENU = ['view-item-context-menu', 'inline'];
var TreeViewNode;
(function (TreeViewNode) {
    function is(arg) {
        return !!arg && browser_1.SelectableTreeNode.is(arg) && tree_decorator_1.DecoratedTreeNode.is(arg);
    }
    TreeViewNode.is = is;
})(TreeViewNode || (exports.TreeViewNode = TreeViewNode = {}));
class ResolvableTreeViewNode {
    constructor(treeViewNode, resolve) {
        this._resolved = false;
        (0, types_1.mixin)(this, treeViewNode);
        this.resolve = async (token) => {
            var _a, _b;
            if (this.resolving) {
                return this.resolving.promise;
            }
            if (!this._resolved) {
                this.resolving = new promise_util_1.Deferred();
                const resolvedTreeItem = await resolve(token);
                if (resolvedTreeItem) {
                    this.command = (_a = this.command) !== null && _a !== void 0 ? _a : resolvedTreeItem.command;
                    this.tooltip = (_b = this.tooltip) !== null && _b !== void 0 ? _b : resolvedTreeItem.tooltip;
                }
                this.resolving.resolve();
                this.resolving = undefined;
            }
            if (!token.isCancellationRequested) {
                this._resolved = true;
            }
        };
    }
    reset() {
        this._resolved = false;
        this.resolving = undefined;
        this.command = undefined;
        this.tooltip = undefined;
    }
    get resolved() {
        return this._resolved;
    }
}
exports.ResolvableTreeViewNode = ResolvableTreeViewNode;
class ResolvableCompositeTreeViewNode extends ResolvableTreeViewNode {
    constructor(treeViewNode, resolve) {
        super(treeViewNode, resolve);
        this.expanded = treeViewNode.expanded;
        this.children = treeViewNode.children;
    }
}
exports.ResolvableCompositeTreeViewNode = ResolvableCompositeTreeViewNode;
var CompositeTreeViewNode;
(function (CompositeTreeViewNode) {
    function is(arg) {
        return TreeViewNode.is(arg) && browser_1.ExpandableTreeNode.is(arg) && browser_1.CompositeTreeNode.is(arg);
    }
    CompositeTreeViewNode.is = is;
})(CompositeTreeViewNode || (exports.CompositeTreeViewNode = CompositeTreeViewNode = {}));
let TreeViewWidgetOptions = class TreeViewWidgetOptions {
};
exports.TreeViewWidgetOptions = TreeViewWidgetOptions;
exports.TreeViewWidgetOptions = TreeViewWidgetOptions = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TreeViewWidgetOptions);
let PluginTree = class PluginTree extends browser_1.TreeImpl {
    constructor() {
        super(...arguments);
        this.onDidChangeWelcomeStateEmitter = new event_1.Emitter();
        this.onDidChangeWelcomeState = this.onDidChangeWelcomeStateEmitter.event;
        this._hasTreeItemResolve = Promise.resolve(false);
    }
    set proxy(proxy) {
        this._proxy = proxy;
        if (proxy) {
            this._hasTreeItemResolve = proxy.$hasResolveTreeItem(this.options.id);
        }
        else {
            this._hasTreeItemResolve = Promise.resolve(false);
        }
    }
    get proxy() {
        return this._proxy;
    }
    get hasTreeItemResolve() {
        return this._hasTreeItemResolve;
    }
    set viewInfo(viewInfo) {
        this._viewInfo = viewInfo;
    }
    get isEmpty() {
        return this._isEmpty;
    }
    async resolveChildren(parent) {
        if (!this._proxy) {
            return super.resolveChildren(parent);
        }
        const children = await this.fetchChildren(this._proxy, parent);
        const hasResolve = await this.hasTreeItemResolve;
        return children.map(value => hasResolve ? this.createResolvableTreeNode(value, parent) : this.createTreeNode(value, parent));
    }
    async fetchChildren(proxy, parent) {
        try {
            const children = await proxy.$getChildren(this.options.id, parent.id);
            const oldEmpty = this._isEmpty;
            this._isEmpty = !parent.id && (!children || children.length === 0);
            if (oldEmpty !== this._isEmpty) {
                this.onDidChangeWelcomeStateEmitter.fire();
            }
            return children || [];
        }
        catch (e) {
            if (e) {
                console.error(`Failed to fetch children for '${this.options.id}'`, e);
                const label = this._viewInfo ? this._viewInfo.name : this.options.id;
                this.notification.error(`${label}: ${e.message}`);
            }
            return [];
        }
    }
    createTreeNode(item, parent) {
        const update = this.createTreeNodeUpdate(item);
        const node = this.getNode(item.id);
        if (item.collapsibleState !== undefined && item.collapsibleState !== plugin_api_rpc_1.TreeViewItemCollapsibleState.None) {
            if (CompositeTreeViewNode.is(node)) {
                return Object.assign(node, update);
            }
            return Object.assign({
                id: item.id,
                parent,
                visible: true,
                selected: false,
                expanded: plugin_api_rpc_1.TreeViewItemCollapsibleState.Expanded === item.collapsibleState,
                children: [],
                command: item.command
            }, update);
        }
        if (TreeViewNode.is(node) && !browser_1.ExpandableTreeNode.is(node)) {
            return Object.assign(node, update, { command: item.command });
        }
        return Object.assign({
            id: item.id,
            parent,
            visible: true,
            selected: false,
            command: item.command,
        }, update);
    }
    markAsChecked(node, checked) {
        var _a;
        function findParentsToChange(child, nodes) {
            var _a;
            if ((((_a = child.parent) === null || _a === void 0 ? void 0 : _a.checkboxInfo) !== undefined && child.parent.checkboxInfo.checked !== checked) &&
                (!checked || !child.parent.children.some(candidate => { var _a; return candidate !== child && ((_a = candidate.checkboxInfo) === null || _a === void 0 ? void 0 : _a.checked) === false; }))) {
                nodes.push(child.parent);
                findParentsToChange(child.parent, nodes);
            }
        }
        function findChildrenToChange(parent, nodes) {
            if (browser_1.CompositeTreeNode.is(parent)) {
                parent.children.forEach(child => {
                    if (child.checkboxInfo !== undefined && child.checkboxInfo.checked !== checked) {
                        nodes.push(child);
                    }
                    findChildrenToChange(child, nodes);
                });
            }
        }
        const nodesToChange = [node];
        if (!this.options.manageCheckboxStateManually) {
            findParentsToChange(node, nodesToChange);
            findChildrenToChange(node, nodesToChange);
        }
        nodesToChange.forEach(n => n.checkboxInfo.checked = checked);
        this.onDidUpdateEmitter.fire(nodesToChange);
        (_a = this.proxy) === null || _a === void 0 ? void 0 : _a.$checkStateChanged(this.options.id, [{ id: node.id, checked: checked }]);
    }
    /** Creates a resolvable tree node. If a node already exists, reset it because the underlying TreeViewItem might have been disposed in the backend. */
    createResolvableTreeNode(item, parent) {
        const update = this.createTreeNodeUpdate(item);
        const node = this.getNode(item.id);
        // Node is a composite node that might contain children
        if (item.collapsibleState !== undefined && item.collapsibleState !== plugin_api_rpc_1.TreeViewItemCollapsibleState.None) {
            // Reuse existing composite node and reset it
            if (node instanceof ResolvableCompositeTreeViewNode) {
                node.reset();
                return Object.assign(node, update);
            }
            // Create new composite node
            const compositeNode = Object.assign({
                id: item.id,
                parent,
                visible: true,
                selected: false,
                expanded: plugin_api_rpc_1.TreeViewItemCollapsibleState.Expanded === item.collapsibleState,
                children: [],
                command: item.command
            }, update);
            return new ResolvableCompositeTreeViewNode(compositeNode, async (token) => { var _a; return (_a = this._proxy) === null || _a === void 0 ? void 0 : _a.$resolveTreeItem(this.options.id, item.id, token); });
        }
        // Node is a leaf
        // Reuse existing node and reset it.
        if (node instanceof ResolvableTreeViewNode && !browser_1.ExpandableTreeNode.is(node)) {
            node.reset();
            return Object.assign(node, update);
        }
        const treeNode = Object.assign({
            id: item.id,
            parent,
            visible: true,
            selected: false,
            command: item.command,
        }, update);
        return new ResolvableTreeViewNode(treeNode, async (token) => { var _a; return (_a = this._proxy) === null || _a === void 0 ? void 0 : _a.$resolveTreeItem(this.options.id, item.id, token); });
    }
    createTreeNodeUpdate(item) {
        const decorationData = this.toDecorationData(item);
        const icon = this.toIconClass(item);
        const resourceUri = item.resourceUri && uri_1.URI.fromComponents(item.resourceUri).toString();
        const themeIcon = item.themeIcon ? item.themeIcon : item.collapsibleState !== plugin_api_rpc_1.TreeViewItemCollapsibleState.None ? { id: 'folder' } : undefined;
        return {
            name: item.label,
            decorationData,
            icon,
            description: item.description,
            themeIcon,
            resourceUri,
            tooltip: item.tooltip,
            contextValue: item.contextValue,
            command: item.command,
            checkboxInfo: item.checkboxInfo,
            accessibilityInformation: item.accessibilityInformation,
        };
    }
    toDecorationData(item) {
        let decoration = {};
        if (item.highlights) {
            const highlight = {
                ranges: item.highlights.map(h => ({ offset: h[0], length: h[1] - h[0] }))
            };
            decoration = { highlight };
        }
        return decoration;
    }
    toIconClass(item) {
        if (item.icon) {
            return 'fa ' + item.icon;
        }
        if (item.iconUrl) {
            const reference = this.sharedStyle.toIconClass(item.iconUrl);
            this.toDispose.push(reference);
            return reference.object.iconClass;
        }
        return undefined;
    }
};
exports.PluginTree = PluginTree;
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_shared_style_1.PluginSharedStyle),
    tslib_1.__metadata("design:type", plugin_shared_style_1.PluginSharedStyle)
], PluginTree.prototype, "sharedStyle", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(TreeViewWidgetOptions),
    tslib_1.__metadata("design:type", TreeViewWidgetOptions)
], PluginTree.prototype, "options", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(message_service_1.MessageService),
    tslib_1.__metadata("design:type", message_service_1.MessageService)
], PluginTree.prototype, "notification", void 0);
exports.PluginTree = PluginTree = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginTree);
let PluginTreeModel = class PluginTreeModel extends browser_1.TreeModelImpl {
    set proxy(proxy) {
        this.tree.proxy = proxy;
    }
    get proxy() {
        return this.tree.proxy;
    }
    get hasTreeItemResolve() {
        return this.tree.hasTreeItemResolve;
    }
    set viewInfo(viewInfo) {
        this.tree.viewInfo = viewInfo;
    }
    get isTreeEmpty() {
        return this.tree.isEmpty;
    }
    get onDidChangeWelcomeState() {
        return this.tree.onDidChangeWelcomeState;
    }
    doOpenNode(node) {
        super.doOpenNode(node);
        if (node instanceof ResolvableTreeViewNode) {
            node.resolve(common_1.CancellationToken.None);
        }
    }
};
exports.PluginTreeModel = PluginTreeModel;
tslib_1.__decorate([
    (0, inversify_1.inject)(PluginTree),
    tslib_1.__metadata("design:type", PluginTree)
], PluginTreeModel.prototype, "tree", void 0);
exports.PluginTreeModel = PluginTreeModel = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], PluginTreeModel);
let TreeViewWidget = class TreeViewWidget extends browser_1.TreeViewWelcomeWidget {
    constructor() {
        super(...arguments);
        this._contextSelection = false;
        this.expansionTimeouts = new Map();
    }
    async refresh(items) {
        if (items) {
            for (const id of items) {
                const node = this.model.getNode(id);
                if (browser_1.CompositeTreeNode.is(node)) {
                    await this.model.refresh(node);
                }
            }
            ;
        }
        else {
            this.model.refresh();
        }
    }
    init() {
        super.init();
        this.id = this.options.id;
        this.addClass('theia-tree-view');
        this.node.style.height = '100%';
        this.model.onDidChangeWelcomeState(this.update, this);
        this.toDispose.push(this.model.onDidChangeWelcomeState(this.update, this));
        this.toDispose.push(this.onDidChangeVisibilityEmitter);
        this.toDispose.push(this.contextKeyService.onDidChange(() => this.update()));
        this.toDispose.push(this.keybindings.onKeybindingsChanged(() => this.update()));
        this.treeDragType = `application/vnd.code.tree.${this.id.toLowerCase()}`;
    }
    get showCollapseAll() {
        return this.options.showCollapseAll || false;
    }
    renderIcon(node, props) {
        var _a;
        const icon = this.toNodeIcon(node);
        if (icon) {
            let style;
            if (TreeViewNode.is(node) && ((_a = node.themeIcon) === null || _a === void 0 ? void 0 : _a.color)) {
                const color = this.colorRegistry.getCurrentColor(node.themeIcon.color.id);
                if (color) {
                    style = { color };
                }
            }
            return React.createElement("div", { className: icon + ' theia-tree-view-icon', style: style });
        }
        return undefined;
    }
    renderCaption(node, props) {
        const classes = [browser_1.TREE_NODE_SEGMENT_CLASS];
        if (!this.hasTrailingSuffixes(node)) {
            classes.push(browser_1.TREE_NODE_SEGMENT_GROW_CLASS);
        }
        const className = classes.join(' ');
        let attrs = {
            ...this.decorateCaption(node, {}),
            className,
            id: node.id
        };
        if (node.accessibilityInformation) {
            attrs = {
                ...attrs,
                'aria-label': node.accessibilityInformation.label,
                'role': node.accessibilityInformation.role
            };
        }
        if (!node.tooltip && node instanceof ResolvableTreeViewNode) {
            let configuredTip = false;
            let source;
            attrs = {
                ...attrs,
                onMouseLeave: () => source === null || source === void 0 ? void 0 : source.cancel(),
                onMouseEnter: async (event) => {
                    const target = event.currentTarget; // event.currentTarget will be null after awaiting node resolve()
                    if (configuredTip) {
                        if (markdown_rendering_1.MarkdownString.is(node.tooltip)) {
                            this.hoverService.requestHover({
                                content: node.tooltip,
                                target: event.target,
                                position: 'right'
                            });
                        }
                        return;
                    }
                    if (!node.resolved) {
                        source = new common_1.CancellationTokenSource();
                        const token = source.token;
                        await node.resolve(token);
                        if (token.isCancellationRequested) {
                            return;
                        }
                    }
                    if (markdown_rendering_1.MarkdownString.is(node.tooltip)) {
                        this.hoverService.requestHover({
                            content: node.tooltip,
                            target: event.target,
                            position: 'right'
                        });
                    }
                    else {
                        const title = node.tooltip ||
                            (node.resourceUri && this.labelProvider.getLongName(new uri_1.URI(node.resourceUri)))
                            || this.toNodeName(node);
                        target.title = title;
                    }
                    configuredTip = true;
                }
            };
        }
        else if (markdown_rendering_1.MarkdownString.is(node.tooltip)) {
            attrs = {
                ...attrs,
                onMouseEnter: event => {
                    this.hoverService.requestHover({
                        content: node.tooltip,
                        target: event.target,
                        position: 'right'
                    });
                }
            };
        }
        else {
            const title = node.tooltip ||
                (node.resourceUri && this.labelProvider.getLongName(new uri_1.URI(node.resourceUri)))
                || this.toNodeName(node);
            attrs = {
                ...attrs,
                title
            };
        }
        const children = [];
        const caption = this.toNodeName(node);
        const highlight = this.getDecorationData(node, 'highlight')[0];
        if (highlight) {
            children.push(this.toReactNode(caption, highlight));
        }
        const searchHighlight = this.searchHighlights && this.searchHighlights.get(node.id);
        if (searchHighlight) {
            children.push(...this.toReactNode(caption, searchHighlight));
        }
        else if (!highlight) {
            children.push(caption);
        }
        const description = this.toNodeDescription(node);
        if (description) {
            children.push(React.createElement("span", { className: 'theia-tree-view-description' }, description));
        }
        return React.createElement("div", { ...attrs }, ...children);
    }
    createNodeAttributes(node, props) {
        const attrs = super.createNodeAttributes(node, props);
        if (this.options.dragMimeTypes) {
            attrs.onDragStart = event => this.handleDragStartEvent(node, event);
            attrs.onDragEnd = event => this.handleDragEnd(node, event);
            attrs.draggable = true;
        }
        if (this.options.dropMimeTypes) {
            attrs.onDrop = event => this.handleDropEvent(node, event);
            attrs.onDragEnter = event => this.handleDragEnter(node, event);
            attrs.onDragLeave = event => this.handleDragLeave(node, event);
            attrs.onDragOver = event => this.handleDragOver(event);
        }
        return attrs;
    }
    handleDragLeave(node, event) {
        const timeout = this.expansionTimeouts.get(node.id);
        if (typeof timeout !== 'undefined') {
            console.debug(`dragleave ${node.id} canceling timeout`);
            clearTimeout(timeout);
            this.expansionTimeouts.delete(node.id);
        }
    }
    handleDragEnter(node, event) {
        console.debug(`dragenter ${node.id}`);
        if (browser_1.ExpandableTreeNode.is(node)) {
            console.debug(`dragenter ${node.id} starting timeout`);
            this.expansionTimeouts.set(node.id, window.setTimeout(() => {
                console.debug(`dragenter ${node.id} timeout reached`);
                this.model.expandNode(node);
            }, 500));
        }
    }
    createContainerAttributes() {
        const attrs = super.createContainerAttributes();
        if (this.options.dropMimeTypes) {
            attrs.onDrop = event => this.handleDropEvent(undefined, event);
            attrs.onDragOver = event => this.handleDragOver(event);
        }
        return attrs;
    }
    handleDragStartEvent(node, event) {
        event.dataTransfer.setData(this.treeDragType, '');
        let selectedNodes = [];
        if (this.model.selectedNodes.find(selected => browser_1.TreeNode.equals(selected, node))) {
            selectedNodes = this.model.selectedNodes.filter(TreeViewNode.is);
        }
        else {
            selectedNodes = [node];
        }
        this.options.dragMimeTypes.forEach(type => {
            if (type === 'text/uri-list') {
                browser_1.ApplicationShell.setDraggedEditorUris(event.dataTransfer, selectedNodes.filter(n => n.resourceUri).map(n => new uri_1.URI(n.resourceUri)));
            }
            else {
                event.dataTransfer.setData(type, '');
            }
        });
        this.model.proxy.$dragStarted(this.options.id, selectedNodes.map(selected => selected.id), common_1.CancellationToken.None).then(maybeUris => {
            if (maybeUris) {
                this.applicationShell.addAdditionalDraggedEditorUris(maybeUris.map(uri => uri_1.URI.fromComponents(uri)));
            }
        });
    }
    handleDragEnd(node, event) {
        this.applicationShell.clearAdditionalDraggedEditorUris();
        this.model.proxy.$dragEnd(this.id);
    }
    handleDragOver(event) {
        const hasFiles = (items) => {
            for (let i = 0; i < items.length; i++) {
                if (items[i].kind === 'file') {
                    return true;
                }
            }
            return false;
        };
        if (event.dataTransfer) {
            const canDrop = event.dataTransfer.types.some(type => this.options.dropMimeTypes.includes(type)) ||
                event.dataTransfer.types.includes(this.treeDragType) ||
                this.options.dropMimeTypes.includes('files') && hasFiles(event.dataTransfer.items);
            if (canDrop) {
                event.preventDefault();
                event.dataTransfer.dropEffect = 'move';
            }
            else {
                event.dataTransfer.dropEffect = 'none';
            }
            event.stopPropagation();
        }
    }
    handleDropEvent(node, event) {
        var _a;
        if (event.dataTransfer) {
            const items = [];
            let files = [];
            try {
                for (let i = 0; i < event.dataTransfer.items.length; i++) {
                    const transferItem = event.dataTransfer.items[i];
                    if (transferItem.type !== this.treeDragType) {
                        // do not pass the artificial drag data to the extension
                        const f = event.dataTransfer.items[i].getAsFile();
                        if (f) {
                            const fileId = this.dndFileContentStore.addFile(f);
                            files.push(fileId);
                            const path = window.electronTheiaCore.getPathForFile(f);
                            const uri = path ? {
                                scheme: 'file',
                                path: path,
                                authority: '',
                                query: '',
                                fragment: ''
                            } : undefined;
                            items.push([transferItem.type, new plugin_api_rpc_1.DataTransferFileDTO(f.name, fileId, uri)]);
                        }
                        else {
                            const textData = event.dataTransfer.getData(transferItem.type);
                            if (textData) {
                                items.push([transferItem.type, textData]);
                            }
                        }
                    }
                }
                if (items.length > 0 || event.dataTransfer.types.includes(this.treeDragType)) {
                    event.preventDefault();
                    event.stopPropagation();
                    (_a = this.model.proxy) === null || _a === void 0 ? void 0 : _a.$drop(this.id, node === null || node === void 0 ? void 0 : node.id, items, common_1.CancellationToken.None).finally(() => {
                        for (const file of files) {
                            this.dndFileContentStore.removeFile(file);
                        }
                    });
                    files = [];
                }
            }
            catch (e) {
                for (const file of files) {
                    this.dndFileContentStore.removeFile(file);
                }
                throw e;
            }
        }
    }
    renderTailDecorations(treeViewNode, props) {
        return this.contextKeys.with({ view: this.id, viewItem: treeViewNode.contextValue }, () => {
            const menu = this.menus.getMenu(exports.VIEW_ITEM_INLINE_MENU);
            const args = this.toContextMenuArgs(treeViewNode);
            const inlineCommands = (menu === null || menu === void 0 ? void 0 : menu.children.filter((item) => menu_1.CommandMenu.is(item))) || [];
            const tailDecorations = super.renderTailDecorations(treeViewNode, props);
            return React.createElement(React.Fragment, null,
                inlineCommands.length > 0 && React.createElement("div", { className: browser_1.TREE_NODE_SEGMENT_CLASS + ' flex' }, inlineCommands.map((item, index) => this.renderInlineCommand(item, index, this.focusService.hasFocus(treeViewNode), args))),
                tailDecorations !== undefined && React.createElement("div", { className: browser_1.TREE_NODE_SEGMENT_CLASS + ' flex' }, tailDecorations));
        });
    }
    toTreeViewItemReference(treeNode) {
        return { viewId: this.id, itemId: treeNode.id };
    }
    resolveKeybindingForCommand(command) {
        let result = '';
        if (command) {
            const bindings = this.keybindings.getKeybindingsForCommand(command);
            let found = false;
            if (bindings && bindings.length > 0) {
                bindings.forEach(binding => {
                    if (!found && this.keybindings.isEnabledInScope(binding, this.node)) {
                        found = true;
                        result = ` (${this.keybindings.acceleratorFor(binding, '+')})`;
                    }
                });
            }
        }
        return result;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    renderInlineCommand(actionMenuNode, index, tabbable, args) {
        const nodePath = [...exports.VIEW_ITEM_INLINE_MENU, actionMenuNode.id];
        if (!actionMenuNode.icon || !actionMenuNode.isVisible(nodePath, this.contextKeys, undefined)) {
            return false;
        }
        const className = [browser_1.TREE_NODE_SEGMENT_CLASS, browser_1.TREE_NODE_TAIL_CLASS, actionMenuNode.icon, widget_1.ACTION_ITEM, 'theia-tree-view-inline-action'].join(' ');
        const tabIndex = tabbable ? 0 : undefined;
        const titleString = actionMenuNode.label + (menu_1.AcceleratorSource.is(actionMenuNode) ? actionMenuNode.getAccelerator(undefined).join('+') : '');
        return React.createElement("div", { key: index, className: className, title: titleString, tabIndex: tabIndex, onClick: e => {
                e.stopPropagation();
                actionMenuNode.run(nodePath, ...args);
            } });
    }
    toContextMenuArgs(target) {
        if (this.options.multiSelect) {
            return [this.toTreeViewItemReference(target), this.model.selectedNodes.map(node => this.toTreeViewItemReference(node))];
        }
        else {
            return [this.toTreeViewItemReference(target)];
        }
    }
    setFlag(flag) {
        super.setFlag(flag);
        if (flag === widget_1.Widget.Flag.IsVisible) {
            this.onDidChangeVisibilityEmitter.fire(this.isVisible);
        }
    }
    clearFlag(flag) {
        super.clearFlag(flag);
        if (flag === widget_1.Widget.Flag.IsVisible) {
            this.onDidChangeVisibilityEmitter.fire(this.isVisible);
        }
    }
    handleEnter(event) {
        super.handleEnter(event);
        this.tryExecuteCommand();
    }
    tapNode(node) {
        super.tapNode(node);
        this.findCommands(node).then(commandMap => {
            if (commandMap.size > 0) {
                this.tryExecuteCommandMap(commandMap);
            }
            else if (node && this.isExpandable(node)) {
                this.model.toggleNodeExpansion(node);
            }
        });
    }
    // execute TreeItem.command if present
    async tryExecuteCommand(node) {
        this.tryExecuteCommandMap(await this.findCommands(node));
    }
    tryExecuteCommandMap(commandMap) {
        commandMap.forEach((args, commandId) => {
            this.commands.executeCommand(commandId, ...args);
        });
    }
    async findCommands(node) {
        const commandMap = new Map();
        const treeNodes = (node ? [node] : this.model.selectedNodes);
        if (await this.model.hasTreeItemResolve) {
            const cancellationToken = new common_1.CancellationTokenSource().token;
            // Resolve all resolvable nodes that don't have a command and haven't been resolved.
            const allResolved = Promise.all(treeNodes.map(maybeNeedsResolve => {
                if (!maybeNeedsResolve.command && maybeNeedsResolve instanceof ResolvableTreeViewNode && !maybeNeedsResolve.resolved) {
                    return maybeNeedsResolve.resolve(cancellationToken).catch(err => {
                        console.error(`Failed to resolve tree item '${maybeNeedsResolve.id}'`, err);
                    });
                }
                return Promise.resolve(maybeNeedsResolve);
            }));
            // Only need to wait but don't need the values because tree items are resolved in place.
            await allResolved;
        }
        for (const treeNode of treeNodes) {
            if (treeNode && treeNode.command) {
                commandMap.set(treeNode.command.id, treeNode.command.arguments || []);
            }
        }
        return commandMap;
    }
    get message() {
        return this._message;
    }
    set message(message) {
        this._message = message;
        this.update();
    }
    render() {
        return React.createElement('div', this.createContainerAttributes(), this.renderSearchInfo(), this.renderTree(this.model));
    }
    renderSearchInfo() {
        if (this._message) {
            return React.createElement("div", { className: 'theia-TreeViewInfo' }, this._message);
        }
        return undefined;
    }
    shouldShowWelcomeView() {
        return (this.model.proxy === undefined || this.model.isTreeEmpty) && this.message === undefined;
    }
    handleContextMenuEvent(node, event) {
        if (browser_1.SelectableTreeNode.is(node)) {
            // Keep the selection for the context menu, if the widget support multi-selection and the right click happens on an already selected node.
            if (!this.props.multiSelect || !node.selected) {
                const type = !!this.props.multiSelect && this.hasCtrlCmdMask(event) ? browser_1.TreeSelection.SelectionType.TOGGLE : browser_1.TreeSelection.SelectionType.DEFAULT;
                this.model.addSelection({ node, type });
            }
            this.focusService.setFocus(node);
            const contextMenuPath = this.props.contextMenuPath;
            if (contextMenuPath) {
                const { x, y } = event.nativeEvent;
                const args = this.toContextMenuArgs(node);
                const contextKeyService = this.contextKeyService.createOverlay([
                    ['viewItem', (TreeViewNode.is(node) && node.contextValue) || undefined],
                    ['view', this.options.id]
                ]);
                setTimeout(() => this.contextMenuRenderer.render({
                    menuPath: contextMenuPath,
                    anchor: { x, y },
                    args,
                    contextKeyService,
                    context: event.currentTarget
                }), 10);
            }
        }
        event.stopPropagation();
        event.preventDefault();
    }
};
exports.TreeViewWidget = TreeViewWidget;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ApplicationShell),
    tslib_1.__metadata("design:type", browser_1.ApplicationShell)
], TreeViewWidget.prototype, "applicationShell", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(menu_1.MenuModelRegistry),
    tslib_1.__metadata("design:type", menu_1.MenuModelRegistry)
], TreeViewWidget.prototype, "menus", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.KeybindingRegistry),
    tslib_1.__metadata("design:type", browser_1.KeybindingRegistry)
], TreeViewWidget.prototype, "keybindings", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], TreeViewWidget.prototype, "contextKeys", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(TreeViewWidgetOptions),
    tslib_1.__metadata("design:type", TreeViewWidgetOptions)
], TreeViewWidget.prototype, "options", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(PluginTreeModel),
    tslib_1.__metadata("design:type", PluginTreeModel)
], TreeViewWidget.prototype, "model", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], TreeViewWidget.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.HoverService),
    tslib_1.__metadata("design:type", browser_1.HoverService)
], TreeViewWidget.prototype, "hoverService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(color_registry_1.ColorRegistry),
    tslib_1.__metadata("design:type", color_registry_1.ColorRegistry)
], TreeViewWidget.prototype, "colorRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(dnd_file_content_store_1.DnDFileContentStore),
    tslib_1.__metadata("design:type", dnd_file_content_store_1.DnDFileContentStore)
], TreeViewWidget.prototype, "dndFileContentStore", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], TreeViewWidget.prototype, "init", null);
exports.TreeViewWidget = TreeViewWidget = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TreeViewWidget);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/tree-views-main.js"
/*!*************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/view/tree-views-main.js ***!
  \*************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TreeViewsMainImpl = void 0;
const plugin_api_rpc_1 = __webpack_require__(/*! ../../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const plugin_view_registry_1 = __webpack_require__(/*! ./plugin-view-registry */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-registry.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const tree_view_widget_1 = __webpack_require__(/*! ./tree-view-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/tree-view-widget.js");
const plugin_view_widget_1 = __webpack_require__(/*! ./plugin-view-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-widget.js");
const buffer_1 = __webpack_require__(/*! @theia/core/lib/common/buffer */ "../../node_modules/@theia/core/lib/common/buffer.js");
const dnd_file_content_store_1 = __webpack_require__(/*! ./dnd-file-content-store */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/dnd-file-content-store.js");
class TreeViewsMainImpl {
    constructor(rpc, container) {
        this.container = container;
        this.treeViewProviders = new Map();
        this.toDispose = new core_1.DisposableCollection(core_1.Disposable.create(() => { }));
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.TREE_VIEWS_EXT);
        this.viewRegistry = container.get(plugin_view_registry_1.PluginViewRegistry);
        this.widgetManager = this.container.get(browser_1.WidgetManager);
        this.fileContentStore = this.container.get(dnd_file_content_store_1.DnDFileContentStore);
        this.badgeService = this.container.get(browser_1.BadgeService);
    }
    dispose() {
        this.toDispose.dispose();
    }
    async $registerTreeDataProvider(treeViewId, $options) {
        this.treeViewProviders.set(treeViewId, this.viewRegistry.registerViewDataProvider(treeViewId, async ({ state, viewInfo }) => {
            const options = {
                id: treeViewId,
                manageCheckboxStateManually: $options.manageCheckboxStateManually,
                showCollapseAll: $options.showCollapseAll,
                multiSelect: $options.canSelectMany,
                dragMimeTypes: $options.dragMimeTypes,
                dropMimeTypes: $options.dropMimeTypes
            };
            const widget = await this.widgetManager.getOrCreateWidget(plugin_view_registry_1.PLUGIN_VIEW_DATA_FACTORY_ID, options);
            widget.model.viewInfo = viewInfo;
            if (state) {
                widget.restoreState(state);
                // ensure that state is completely restored
                await widget.model.refresh();
            }
            else if (!widget.model.root) {
                const root = {
                    id: '',
                    parent: undefined,
                    name: '',
                    visible: false,
                    expanded: true,
                    children: []
                };
                widget.model.root = root;
            }
            if (this.toDispose.disposed) {
                widget.model.proxy = undefined;
            }
            else {
                widget.model.proxy = this.proxy;
                this.toDispose.push(core_1.Disposable.create(() => widget.model.proxy = undefined));
                this.handleTreeEvents(widget.id, widget);
            }
            widget.model.refresh();
            return widget;
        }));
        this.toDispose.push(core_1.Disposable.create(() => this.$unregisterTreeDataProvider(treeViewId)));
    }
    async $unregisterTreeDataProvider(treeViewId) {
        const treeDataProvider = this.treeViewProviders.get(treeViewId);
        if (treeDataProvider) {
            this.treeViewProviders.delete(treeViewId);
            treeDataProvider.dispose();
        }
    }
    async $readDroppedFile(contentId) {
        const file = this.fileContentStore.getFile(contentId);
        const buffer = await file.arrayBuffer();
        return buffer_1.BinaryBuffer.wrap(new Uint8Array(buffer));
    }
    async $refresh(treeViewId, items) {
        const viewPanel = await this.viewRegistry.getView(treeViewId);
        const widget = viewPanel && viewPanel.widgets[0];
        if (widget instanceof tree_view_widget_1.TreeViewWidget) {
            await widget.refresh(items);
        }
    }
    // elementParentChain parameter contain a list of tree ids from root to the revealed node
    // all parents of the revealed node should be fetched and expanded in order for it to reveal
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async $reveal(treeViewId, elementParentChain, options) {
        const viewPanel = await this.viewRegistry.openView(treeViewId, { activate: options.focus, reveal: true });
        const widget = viewPanel && viewPanel.widgets[0];
        if (widget instanceof tree_view_widget_1.TreeViewWidget) {
            // pop last element which is the node to reveal
            const elementId = elementParentChain.pop();
            await this.expandParentChain(widget.model, elementParentChain);
            const treeNode = widget.model.getNode(elementId);
            if (treeNode) {
                if (options.expand && browser_1.ExpandableTreeNode.is(treeNode)) {
                    await widget.model.expandNode(treeNode);
                }
                if (options.select && browser_1.SelectableTreeNode.is(treeNode)) {
                    widget.model.selectNode(treeNode);
                }
            }
        }
    }
    /**
     * Expand all parents of the node to reveal from root. This should also fetch missing nodes to the frontend.
     */
    async expandParentChain(model, elementParentChain) {
        for (const elementId of elementParentChain) {
            const treeNode = model.getNode(elementId);
            if (browser_1.ExpandableTreeNode.is(treeNode)) {
                await model.expandNode(treeNode);
            }
        }
    }
    async $setMessage(treeViewId, message) {
        const viewPanel = await this.viewRegistry.getView(treeViewId);
        if (viewPanel instanceof plugin_view_widget_1.PluginViewWidget) {
            viewPanel.message = message;
        }
    }
    async $setTitle(treeViewId, title) {
        const viewPanel = await this.viewRegistry.getView(treeViewId);
        if (viewPanel) {
            viewPanel.title.label = title;
        }
    }
    async $setDescription(treeViewId, description) {
        const viewPanel = await this.viewRegistry.getView(treeViewId);
        if (viewPanel) {
            viewPanel.description = description;
        }
    }
    async $setBadge(treeViewId, badge) {
        const viewPanel = await this.viewRegistry.getView(treeViewId);
        if (viewPanel) {
            this.badgeService.showBadge(viewPanel, badge);
        }
    }
    async setChecked(treeViewWidget, changedNodes) {
        await this.proxy.$checkStateChanged(treeViewWidget.id, changedNodes.map(node => {
            var _a;
            return ({
                id: node.id,
                checked: !!((_a = node.checkboxInfo) === null || _a === void 0 ? void 0 : _a.checked)
            });
        }));
    }
    handleTreeEvents(treeViewId, treeViewWidget) {
        this.toDispose.push(treeViewWidget.model.onExpansionChanged(event => {
            this.proxy.$setExpanded(treeViewId, event.id, event.expanded);
        }));
        this.toDispose.push(treeViewWidget.model.onSelectionChanged(event => {
            this.proxy.$setSelection(treeViewId, event.map((node) => node.id));
        }));
        const updateVisible = () => this.proxy.$setVisible(treeViewId, treeViewWidget.isVisible);
        updateVisible();
        this.toDispose.push(treeViewWidget.onDidChangeVisibility(() => updateVisible()));
    }
}
exports.TreeViewsMainImpl = TreeViewsMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/view-context-key-service.js"
/*!**********************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/view/view-context-key-service.js ***!
  \**********************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ViewContextKeyService = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../../node_modules/@theia/core/lib/browser/context-key-service.js");
let ViewContextKeyService = class ViewContextKeyService {
    get viewItem() {
        return this._viewItem;
    }
    get activeViewlet() {
        return this._activeViewlet;
    }
    get activePanel() {
        return this._activePanel;
    }
    get activeAuxiliary() {
        return this._activeAuxiliary;
    }
    get focusedView() {
        return this._focusedView;
    }
    init() {
        this._viewItem = this.contextKeyService.createKey('viewItem', '');
        this._activeViewlet = this.contextKeyService.createKey('activeViewlet', '');
        this._activePanel = this.contextKeyService.createKey('activePanel', '');
        this._activeAuxiliary = this.contextKeyService.createKey('activeAuxiliary', '');
        this._focusedView = this.contextKeyService.createKey('focusedView', '');
    }
    match(expression) {
        return !expression || this.contextKeyService.match(expression);
    }
};
exports.ViewContextKeyService = ViewContextKeyService;
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], ViewContextKeyService.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], ViewContextKeyService.prototype, "init", null);
exports.ViewContextKeyService = ViewContextKeyService = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], ViewContextKeyService);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview-views/webview-views-main.js"
/*!*************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/webview-views/webview-views-main.js ***!
  \*************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 SAP SE or an SAP affiliate company and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// some code copied and modified from https://github.com/microsoft/vscode/blob/e1f0f8f51390dea5df9096718fb6b647ed5a9534/src/vs/workbench/api/browser/mainThreadWebviewViews.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebviewViewsMainImpl = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const plugin_view_registry_1 = __webpack_require__(/*! ../view/plugin-view-registry */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-registry.js");
const plugin_view_widget_1 = __webpack_require__(/*! ../view/plugin-view-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-widget.js");
class WebviewViewsMainImpl {
    constructor(rpc, container, webviewsMain) {
        this.webviewsMain = webviewsMain;
        this.toDispose = new core_1.DisposableCollection(core_1.Disposable.create(() => { }));
        this.webviewViews = new Map();
        this.webviewViewProviders = new Map();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.WEBVIEW_VIEWS_EXT);
        this.widgetManager = container.get(browser_1.WidgetManager);
        this.pluginViewRegistry = container.get(plugin_view_registry_1.PluginViewRegistry);
        this.badgeService = container.get(browser_1.BadgeService);
    }
    dispose() {
        this.toDispose.dispose();
    }
    async $registerWebviewViewProvider(viewType, options) {
        if (this.webviewViewProviders.has(viewType)) {
            throw new Error(`View provider for ${viewType} already registered`);
        }
        const registration = await this.pluginViewRegistry.registerWebviewView(viewType, {
            resolve: async (webviewView, cancellation) => {
                const handle = webviewView.webview.identifier.id;
                this.webviewViews.set(handle, webviewView);
                this.webviewsMain.hookWebview(webviewView.webview);
                let state;
                if (webviewView.webview.state) {
                    try {
                        state = JSON.parse(webviewView.webview.state);
                        console.log(state);
                    }
                    catch (e) {
                        console.error('Could not load webview state', e, webviewView.webview.state);
                    }
                }
                if (options) {
                    webviewView.webview.options = options;
                }
                webviewView.onDidChangeVisibility(async (visible) => {
                    if (visible) {
                        await webviewView.resolve();
                    }
                    this.proxy.$onDidChangeWebviewViewVisibility(handle, visible);
                });
                webviewView.onDidDispose(() => {
                    this.proxy.$disposeWebviewView(handle);
                    this.webviewViews.delete(handle);
                });
                try {
                    await this.proxy.$resolveWebviewView(handle, viewType, webviewView.title, state, cancellation);
                }
                catch (error) {
                    this.logger.error(`Error resolving webview view '${viewType}': ${error}`);
                    webviewView.webview.setHTML('failed to load plugin webview view');
                }
            }
        });
        this.webviewViewProviders.set(viewType, registration);
    }
    getWebview(handle) {
        return this.widgetManager.tryGetWidget(handle);
    }
    $unregisterWebviewViewProvider(viewType) {
        const provider = this.webviewViewProviders.get(viewType);
        if (!provider) {
            throw new Error(`No view provider for ${viewType} registered`);
        }
        provider.dispose();
        this.webviewViewProviders.delete(viewType);
    }
    $setWebviewViewTitle(handle, value) {
        const webviewView = this.getWebviewView(handle);
        webviewView.title = value;
    }
    $setWebviewViewDescription(handle, value) {
        const webviewView = this.getWebviewView(handle);
        webviewView.description = value;
    }
    async $setBadge(handle, badge) {
        const webviewView = this.getWebviewView(handle);
        if (webviewView) {
            if (!(webviewView.webview.parent instanceof plugin_view_widget_1.PluginViewWidget)) {
                throw new Error('Unexpected parent of WebviewViewWidget');
            }
            this.badgeService.showBadge(webviewView.webview.parent, badge);
        }
    }
    $show(handle, preserveFocus) {
        const webviewView = this.getWebviewView(handle);
        webviewView.show(preserveFocus);
    }
    getWebviewView(handle) {
        const webviewView = this.webviewViews.get(handle);
        if (!webviewView) {
            throw new Error(`No webview view registered for handle '${handle}'`);
        }
        return webviewView;
    }
}
exports.WebviewViewsMainImpl = WebviewViewsMainImpl;
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.ILogger),
    tslib_1.__metadata("design:type", Object)
], WebviewViewsMainImpl.prototype, "logger", void 0);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-context-keys.js"
/*!*********************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-context-keys.js ***!
  \*********************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2023 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebviewContextKeys = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../../node_modules/@theia/core/lib/browser/context-key-service.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const custom_editor_widget_1 = __webpack_require__(/*! ../custom-editors/custom-editor-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-widget.js");
const webview_1 = __webpack_require__(/*! ./webview */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview.js");
let WebviewContextKeys = class WebviewContextKeys {
    init() {
        this.activeWebviewPanelId = this.contextKeyService.createKey('activeWebviewPanelId', '');
        this.activeCustomEditorId = this.contextKeyService.createKey('activeCustomEditorId', '');
        this.applicationShell.onDidChangeCurrentWidget(this.handleDidChangeCurrentWidget, this);
    }
    handleDidChangeCurrentWidget(change) {
        const { newValue } = change;
        if (newValue instanceof custom_editor_widget_1.CustomEditorWidget) {
            this.activeCustomEditorId.set(newValue.viewType);
        }
        else {
            this.activeCustomEditorId.set('');
        }
        if (newValue instanceof webview_1.WebviewWidget) {
            this.activeWebviewPanelId.set(newValue.viewType);
        }
        else {
            this.activeWebviewPanelId.set('');
        }
    }
};
exports.WebviewContextKeys = WebviewContextKeys;
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_1.ApplicationShell),
    tslib_1.__metadata("design:type", browser_1.ApplicationShell)
], WebviewContextKeys.prototype, "applicationShell", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], WebviewContextKeys.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], WebviewContextKeys.prototype, "init", null);
exports.WebviewContextKeys = WebviewContextKeys = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], WebviewContextKeys);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-environment.js"
/*!********************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-environment.js ***!
  \********************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebviewEnvironment = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const endpoint_1 = __webpack_require__(/*! @theia/core/lib/browser/endpoint */ "../../node_modules/@theia/core/lib/browser/endpoint.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../../node_modules/@theia/core/lib/common/promise-util.js");
const env_variables_1 = __webpack_require__(/*! @theia/core/lib/common/env-variables */ "../../node_modules/@theia/core/lib/common/env-variables/index.js");
const webview_protocol_1 = __webpack_require__(/*! ../../common/webview-protocol */ "../../node_modules/@theia/plugin-ext/lib/main/common/webview-protocol.js");
const environment_1 = __webpack_require__(/*! @theia/core/shared/@theia/application-package/lib/environment */ "../../node_modules/@theia/core/shared/@theia/application-package/lib/environment/index.js");
let WebviewEnvironment = class WebviewEnvironment {
    constructor() {
        this.externalEndpointHost = new promise_util_1.Deferred();
    }
    init() {
        this.doInit();
    }
    async doInit() {
        this._hostPatternPromise = this.getHostPattern();
        try {
            const endpointPattern = await this.hostPatternPromise;
            const { host } = new endpoint_1.Endpoint();
            this.externalEndpointHost.resolve(endpointPattern.replace('{{hostname}}', host));
        }
        catch (e) {
            this.externalEndpointHost.reject(e);
        }
    }
    get hostPatternPromise() {
        return this._hostPatternPromise;
    }
    async externalEndpointUrl() {
        const host = await this.externalEndpointHost.promise;
        return new endpoint_1.Endpoint({
            host,
            path: '/webview'
        }).getRestUrl();
    }
    async externalEndpoint() {
        return (await this.externalEndpointUrl()).toString(true);
    }
    async resourceRoot(host) {
        if (host === 'frontend') {
            return (await this.externalEndpointUrl()).withPath('{{path}}').toString(true);
        }
        // Make sure we preserve the scheme of the resource but convert it into a normal path segment
        // The scheme is important as we need to know if we are requesting a local or a remote resource.
        return (await this.externalEndpointUrl()).resolve('theia-resource/{{scheme}}//{{authority}}/{{path}}').toString(true);
    }
    async cspSource() {
        return (await this.externalEndpointUrl()).withPath('').withQuery('').withFragment('').toString(true).replace('{{uuid}}', '*');
    }
    async getHostPattern() {
        return environment_1.environment.electron.is()
            ? webview_protocol_1.WebviewExternalEndpoint.defaultPattern
            : this.environments.getValue(webview_protocol_1.WebviewExternalEndpoint.pattern)
                .then(variable => (variable === null || variable === void 0 ? void 0 : variable.value) || webview_protocol_1.WebviewExternalEndpoint.defaultPattern);
    }
};
exports.WebviewEnvironment = WebviewEnvironment;
tslib_1.__decorate([
    (0, inversify_1.inject)(env_variables_1.EnvVariablesServer),
    tslib_1.__metadata("design:type", Object)
], WebviewEnvironment.prototype, "environments", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], WebviewEnvironment.prototype, "init", null);
exports.WebviewEnvironment = WebviewEnvironment = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], WebviewEnvironment);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-frontend-preference-contribution.js"
/*!*****************************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-frontend-preference-contribution.js ***!
  \*****************************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebviewFrontendPreferenceContribution = void 0;
// *****************************************************************************
// Copyright (C) 2025 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const frontend_application_config_provider_1 = __webpack_require__(/*! @theia/core/lib/browser/frontend-application-config-provider */ "../../node_modules/@theia/core/lib/browser/frontend-application-config-provider.js");
const schema = {
    properties: {
        'webview.warnIfUnsecure': {
            scope: core_1.PreferenceScope.Default,
            type: 'boolean',
            description: core_1.nls.localize('theia/plugin-ext/webviewWarnIfUnsecure', 'Warns users that webviews are currently deployed insecurely.'),
            default: true,
        }
    }
};
class WebviewFrontendPreferenceContribution {
    async initSchema(service) {
        const frontendConfig = frontend_application_config_provider_1.FrontendApplicationConfigProvider.get();
        if (frontendConfig.securityWarnings) {
            service.addSchema(schema);
        }
    }
}
exports.WebviewFrontendPreferenceContribution = WebviewFrontendPreferenceContribution;
;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-frontend-security-warnings.js"
/*!***********************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-frontend-security-warnings.js ***!
  \***********************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2021 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebviewFrontendSecurityWarnings = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const frontend_application_config_provider_1 = __webpack_require__(/*! @theia/core/lib/browser/frontend-application-config-provider */ "../../node_modules/@theia/core/lib/browser/frontend-application-config-provider.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../../node_modules/@theia/core/lib/common/nls.js");
const window_service_1 = __webpack_require__(/*! @theia/core/lib/browser/window/window-service */ "../../node_modules/@theia/core/lib/browser/window/window-service.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const webview_protocol_1 = __webpack_require__(/*! ../../common/webview-protocol */ "../../node_modules/@theia/plugin-ext/lib/main/common/webview-protocol.js");
const webview_environment_1 = __webpack_require__(/*! ./webview-environment */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-environment.js");
let WebviewFrontendSecurityWarnings = class WebviewFrontendSecurityWarnings {
    initialize() {
        this.checkHostPattern();
    }
    async checkHostPattern() {
        if (frontend_application_config_provider_1.FrontendApplicationConfigProvider.get()['warnOnPotentiallyInsecureHostPattern'] === false) {
            return;
        }
        const hostPattern = await this.webviewEnvironment.hostPatternPromise;
        if (hostPattern !== webview_protocol_1.WebviewExternalEndpoint.defaultPattern) {
            const goToReadme = nls_1.nls.localize('theia/webview/goToReadme', 'Go To README');
            const message = nls_1.nls.localize('theia/webview/messageWarning', '\
            The {0} endpoint\'s host pattern has been changed to `{1}`; changing the pattern can lead to security vulnerabilities. \
            See `{2}` for more information.', 'webview', hostPattern, '@theia/plugin-ext/README.md');
            this.messageService.warn(message, browser_1.Dialog.OK, goToReadme).then(action => {
                if (action === goToReadme) {
                    this.windowService.openNewWindow('https://www.npmjs.com/package/@theia/plugin-ext', { external: true });
                }
            });
        }
    }
};
exports.WebviewFrontendSecurityWarnings = WebviewFrontendSecurityWarnings;
tslib_1.__decorate([
    (0, inversify_1.inject)(window_service_1.WindowService),
    tslib_1.__metadata("design:type", Object)
], WebviewFrontendSecurityWarnings.prototype, "windowService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.MessageService),
    tslib_1.__metadata("design:type", core_1.MessageService)
], WebviewFrontendSecurityWarnings.prototype, "messageService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(webview_environment_1.WebviewEnvironment),
    tslib_1.__metadata("design:type", webview_environment_1.WebviewEnvironment)
], WebviewFrontendSecurityWarnings.prototype, "webviewEnvironment", void 0);
exports.WebviewFrontendSecurityWarnings = WebviewFrontendSecurityWarnings = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], WebviewFrontendSecurityWarnings);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-resource-cache.js"
/*!***********************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-resource-cache.js ***!
  \***********************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebviewResourceCache = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../../node_modules/@theia/core/lib/common/promise-util.js");
/**
 * Browser based cache of webview resources across all instances.
 */
let WebviewResourceCache = class WebviewResourceCache {
    constructor() {
        this.cache = new promise_util_1.Deferred();
        this.resolveCache();
    }
    async resolveCache() {
        try {
            this.cache.resolve(await caches.open('webview:v1'));
        }
        catch (e) {
            console.error('Failed to enable webview caching: ', e);
            this.cache.resolve(undefined);
        }
    }
    async match(url) {
        const cache = await this.cache.promise;
        if (!cache) {
            return undefined;
        }
        const response = await cache.match(url);
        if (!response) {
            return undefined;
        }
        return {
            eTag: response.headers.get('ETag') || undefined,
            body: async () => {
                const buffer = await response.arrayBuffer();
                return new Uint8Array(buffer);
            }
        };
    }
    async delete(url) {
        const cache = await this.cache.promise;
        if (!cache) {
            return false;
        }
        return cache.delete(url);
    }
    async put(url, response) {
        if (!response.eTag) {
            return;
        }
        const cache = await this.cache.promise;
        if (!cache) {
            return;
        }
        const body = await response.body();
        await cache.put(url, new Response(body, {
            status: 200,
            headers: { 'ETag': response.eTag }
        }));
    }
};
exports.WebviewResourceCache = WebviewResourceCache;
exports.WebviewResourceCache = WebviewResourceCache = tslib_1.__decorate([
    (0, inversify_1.injectable)(),
    tslib_1.__metadata("design:paramtypes", [])
], WebviewResourceCache);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-secondary-window-support.js"
/*!*********************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-secondary-window-support.js ***!
  \*********************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2024 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebviewSecondaryWindowSupport = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const secondary_window_handler_1 = __webpack_require__(/*! @theia/core/lib/browser/secondary-window-handler */ "../../node_modules/@theia/core/lib/browser/secondary-window-handler.js");
const webview_1 = __webpack_require__(/*! ./webview */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview.js");
let WebviewSecondaryWindowSupport = class WebviewSecondaryWindowSupport {
    onStart(app) {
        this.secondaryWindowHandler.onDidAddWidget(([widget, win]) => {
            if (widget instanceof webview_1.WebviewWidget) {
                const script = win.document.createElement('script');
                script.text = `
                        window.addEventListener('message', e => {
                        // Only process messages from Theia main window
                        if (e.source === window.opener) {
                            // Delegate message to iframe
                            const frame = window.document.getElementsByTagName('iframe').item(0);
                            if (frame) {
                                frame.contentWindow?.postMessage({ ...e.data }, '*');
                            }
                        }
                        }); `;
                win.document.head.append(script);
            }
        });
    }
};
exports.WebviewSecondaryWindowSupport = WebviewSecondaryWindowSupport;
tslib_1.__decorate([
    (0, inversify_1.inject)(secondary_window_handler_1.SecondaryWindowHandler),
    tslib_1.__metadata("design:type", secondary_window_handler_1.SecondaryWindowHandler)
], WebviewSecondaryWindowSupport.prototype, "secondaryWindowHandler", void 0);
exports.WebviewSecondaryWindowSupport = WebviewSecondaryWindowSupport = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], WebviewSecondaryWindowSupport);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-theme-data-provider.js"
/*!****************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-theme-data-provider.js ***!
  \****************************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// copied and modified from https://github.com/microsoft/vscode/blob/ba40bd16433d5a817bfae15f3b4350e18f144af4/src/vs/workbench/contrib/webview/common/themeing.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebviewThemeDataProvider = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../node_modules/@theia/core/lib/common/event.js");
const editor_preferences_1 = __webpack_require__(/*! @theia/editor/lib/common/editor-preferences */ "../../node_modules/@theia/editor/lib/common/editor-preferences.js");
const theming_1 = __webpack_require__(/*! @theia/core/lib/browser/theming */ "../../node_modules/@theia/core/lib/browser/theming.js");
const color_registry_1 = __webpack_require__(/*! @theia/core/lib/browser/color-registry */ "../../node_modules/@theia/core/lib/browser/color-registry.js");
const color_application_contribution_1 = __webpack_require__(/*! @theia/core/lib/browser/color-application-contribution */ "../../node_modules/@theia/core/lib/browser/color-application-contribution.js");
let WebviewThemeDataProvider = class WebviewThemeDataProvider {
    constructor() {
        this.onDidChangeThemeDataEmitter = new event_1.Emitter();
        this.onDidChangeThemeData = this.onDidChangeThemeDataEmitter.event;
        this.editorStyles = new Map([
            ['editor.fontFamily', 'editor-font-family'],
            ['editor.fontWeight', 'editor-font-weight'],
            ['editor.fontSize', 'editor-font-size']
        ]);
    }
    init() {
        this.colorContribution.onDidChange(() => this.reset());
        this.editorPreferences.onPreferenceChanged(e => {
            if (this.editorStyles.has(e.preferenceName)) {
                this.reset();
            }
        });
    }
    reset() {
        if (this.themeData) {
            this.themeData = undefined;
            this.onDidChangeThemeDataEmitter.fire(undefined);
        }
    }
    getThemeData() {
        if (!this.themeData) {
            this.themeData = this.computeThemeData();
        }
        return this.themeData;
    }
    computeThemeData() {
        const styles = {};
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const addStyle = (id, rawValue) => {
            if (rawValue) {
                const value = typeof rawValue === 'number' || typeof rawValue === 'string' ? rawValue : String(rawValue);
                styles[this.colors.toCssVariableName(id).substring(2)] = value;
                styles[this.colors.toCssVariableName(id, 'vscode').substring(2)] = value;
            }
        };
        addStyle('font-family', '-apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif');
        addStyle('font-weight', 'normal');
        addStyle('font-size', '13px');
        this.editorStyles.forEach((value, key) => addStyle(value, this.editorPreferences[key]));
        for (const id of this.colors.getColors()) {
            const color = this.colors.getCurrentColor(id);
            if (color) {
                addStyle(id, color.toString());
            }
        }
        const activeTheme = this.getActiveTheme();
        return {
            styles,
            activeThemeName: activeTheme.label,
            activeThemeType: this.getThemeType(activeTheme)
        };
    }
    getActiveTheme() {
        return this.themeService.getCurrentTheme();
    }
    getThemeType(theme) {
        switch (theme.type) {
            case 'light': return 'vscode-light';
            case 'dark': return 'vscode-dark';
            default: return 'vscode-high-contrast';
        }
    }
};
exports.WebviewThemeDataProvider = WebviewThemeDataProvider;
tslib_1.__decorate([
    (0, inversify_1.inject)(editor_preferences_1.EditorPreferences),
    tslib_1.__metadata("design:type", Object)
], WebviewThemeDataProvider.prototype, "editorPreferences", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(color_registry_1.ColorRegistry),
    tslib_1.__metadata("design:type", color_registry_1.ColorRegistry)
], WebviewThemeDataProvider.prototype, "colors", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(color_application_contribution_1.ColorApplicationContribution),
    tslib_1.__metadata("design:type", color_application_contribution_1.ColorApplicationContribution)
], WebviewThemeDataProvider.prototype, "colorContribution", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(theming_1.ThemeService),
    tslib_1.__metadata("design:type", theming_1.ThemeService)
], WebviewThemeDataProvider.prototype, "themeService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], WebviewThemeDataProvider.prototype, "init", null);
exports.WebviewThemeDataProvider = WebviewThemeDataProvider = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], WebviewThemeDataProvider);


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-widget-factory.js"
/*!***********************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-widget-factory.js ***!
  \***********************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2020 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebviewWidgetFactory = void 0;
const webview_1 = __webpack_require__(/*! ./webview */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview.js");
const webview_environment_1 = __webpack_require__(/*! ./webview-environment */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-environment.js");
const uuid_1 = __webpack_require__(/*! @theia/core/lib/common/uuid */ "../../node_modules/@theia/core/lib/common/uuid.js");
class WebviewWidgetFactory {
    constructor(container) {
        this.id = webview_1.WebviewWidget.FACTORY_ID;
        this.container = container;
    }
    async createWidget(identifier) {
        const externalEndpoint = await this.container.get(webview_environment_1.WebviewEnvironment).externalEndpoint();
        let endpoint = externalEndpoint.replace('{{uuid}}', identifier.viewId ? (0, uuid_1.hashValue)(identifier.viewId) : identifier.id);
        if (endpoint[endpoint.length - 1] === '/') {
            endpoint = endpoint.slice(0, endpoint.length - 1);
        }
        const child = this.container.createChild();
        child.bind(webview_1.WebviewWidgetIdentifier).toConstantValue(identifier);
        child.bind(webview_1.WebviewWidgetExternalEndpoint).toConstantValue(endpoint);
        return child.get(webview_1.WebviewWidget);
    }
}
exports.WebviewWidgetFactory = WebviewWidgetFactory;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview.js"
/*!********************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview.js ***!
  \********************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
/*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/
// copied and modified from https://github.com/microsoft/vscode/blob/ba40bd16433d5a817bfae15f3b4350e18f144af4/src/vs/workbench/contrib/webview/browser/baseWebviewElement.ts
// copied and modified from https://github.com/microsoft/vscode/blob/ba40bd16433d5a817bfae15f3b4350e18f144af4/src/vs/workbench/contrib/webview/browser/webviewElement.ts#
var WebviewWidget_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebviewWidget = exports.WebviewWidgetExternalEndpoint = exports.WebviewWidgetIdentifier = exports.WEBVIEW_CONTEXT_MENU = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const mime = __webpack_require__(/*! mime */ "../../node_modules/@theia/plugin-ext/node_modules/mime/index.js");
const coreutils_1 = __webpack_require__(/*! @theia/core/shared/@lumino/coreutils */ "../../node_modules/@theia/core/shared/@lumino/coreutils/index.js");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const widget_1 = __webpack_require__(/*! @theia/core/lib/browser/widgets/widget */ "../../node_modules/@theia/core/lib/browser/widgets/widget.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const application_shell_mouse_tracker_1 = __webpack_require__(/*! @theia/core/lib/browser/shell/application-shell-mouse-tracker */ "../../node_modules/@theia/core/lib/browser/shell/application-shell-mouse-tracker.js");
const promise_util_1 = __webpack_require__(/*! @theia/core/lib/common/promise-util */ "../../node_modules/@theia/core/lib/common/promise-util.js");
const webview_environment_1 = __webpack_require__(/*! ./webview-environment */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-environment.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../../node_modules/@theia/core/lib/common/uri.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../node_modules/@theia/core/lib/common/event.js");
const opener_service_1 = __webpack_require__(/*! @theia/core/lib/browser/opener-service */ "../../node_modules/@theia/core/lib/browser/opener-service.js");
const keybinding_1 = __webpack_require__(/*! @theia/core/lib/browser/keybinding */ "../../node_modules/@theia/core/lib/browser/keybinding.js");
const uri_components_1 = __webpack_require__(/*! ../../../common/uri-components */ "../../node_modules/@theia/plugin-ext/lib/common/uri-components.js");
const plugin_shared_style_1 = __webpack_require__(/*! ../plugin-shared-style */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-shared-style.js");
const webview_theme_data_provider_1 = __webpack_require__(/*! ./webview-theme-data-provider */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-theme-data-provider.js");
const external_uri_service_1 = __webpack_require__(/*! @theia/core/lib/browser/external-uri-service */ "../../node_modules/@theia/core/lib/browser/external-uri-service.js");
const output_channel_1 = __webpack_require__(/*! @theia/output/lib/browser/output-channel */ "../../node_modules/@theia/output/lib/browser/output-channel.js");
const webview_resource_cache_1 = __webpack_require__(/*! ./webview-resource-cache */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview-resource-cache.js");
const endpoint_1 = __webpack_require__(/*! @theia/core/lib/browser/endpoint */ "../../node_modules/@theia/core/lib/browser/endpoint.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser/browser */ "../../node_modules/@theia/core/lib/browser/browser.js");
const file_service_1 = __webpack_require__(/*! @theia/filesystem/lib/browser/file-service */ "../../node_modules/@theia/filesystem/lib/browser/file-service.js");
const files_1 = __webpack_require__(/*! @theia/filesystem/lib/common/files */ "../../node_modules/@theia/filesystem/lib/common/files.js");
const buffer_1 = __webpack_require__(/*! @theia/core/lib/common/buffer */ "../../node_modules/@theia/core/lib/common/buffer.js");
const browser_2 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const context_key_service_1 = __webpack_require__(/*! @theia/core/lib/browser/context-key-service */ "../../node_modules/@theia/core/lib/browser/context-key-service.js");
const plugin_view_widget_1 = __webpack_require__(/*! ../view/plugin-view-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/view/plugin-view-widget.js");
const webview_preferences_1 = __webpack_require__(/*! ../../common/webview-preferences */ "../../node_modules/@theia/plugin-ext/lib/main/common/webview-preferences.js");
// Style from core
const TRANSPARENT_OVERLAY_STYLE = 'theia-transparent-overlay';
exports.WEBVIEW_CONTEXT_MENU = ['webview-context-menu'];
let WebviewWidgetIdentifier = class WebviewWidgetIdentifier {
};
exports.WebviewWidgetIdentifier = WebviewWidgetIdentifier;
exports.WebviewWidgetIdentifier = WebviewWidgetIdentifier = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], WebviewWidgetIdentifier);
exports.WebviewWidgetExternalEndpoint = Symbol('WebviewWidgetExternalEndpoint');
let WebviewWidget = WebviewWidget_1 = class WebviewWidget extends widget_1.BaseWidget {
    constructor() {
        super(...arguments);
        this.viewState = {
            visible: false,
            active: false,
            position: 0
        };
        this.html = '';
        this._contentOptions = {};
        this.options = {};
        this.ready = new promise_util_1.Deferred();
        this.onMessageEmitter = new event_1.Emitter();
        this.onMessage = this.onMessageEmitter.event;
        this.pendingMessages = [];
        this.toHide = new disposable_1.DisposableCollection();
        this.isExtractable = true;
        this.secondaryWindow = undefined;
        this.toDisposeOnIcon = new disposable_1.DisposableCollection();
    }
    get contentOptions() {
        return this._contentOptions;
    }
    get state() {
        return this._state;
    }
    init() {
        this.node.tabIndex = 0;
        this.id = WebviewWidget_1.FACTORY_ID + ':' + this.identifier.id;
        this.title.closable = true;
        this.addClass(WebviewWidget_1.Styles.WEBVIEW);
        this.toDispose.push(this.onMessageEmitter);
        this.transparentOverlay = document.createElement('div');
        this.transparentOverlay.classList.add(TRANSPARENT_OVERLAY_STYLE);
        this.transparentOverlay.style.display = 'none';
        this.node.appendChild(this.transparentOverlay);
        this.toDispose.push(this.mouseTracker.onMousedown(() => {
            if (this.element && this.element.style.display !== 'none') {
                this.transparentOverlay.style.display = 'block';
            }
        }));
        this.toDispose.push(this.mouseTracker.onMouseup(() => {
            if (this.element && this.element.style.display !== 'none') {
                this.transparentOverlay.style.display = 'none';
            }
        }));
    }
    onBeforeAttach(msg) {
        super.onBeforeAttach(msg);
        this.doShow();
        // iframe has to be reloaded when moved to another DOM element
        this.toDisposeOnDetach.push(disposable_1.Disposable.create(() => this.forceHide()));
    }
    onAfterAttach(msg) {
        super.onAfterAttach(msg);
        this.addEventListener(this.node, 'focus', () => {
            if (this.element) {
                this.doSend('focus');
            }
        });
    }
    onBeforeShow(msg) {
        super.onBeforeShow(msg);
        this.doShow();
    }
    onAfterHide(msg) {
        super.onAfterHide(msg);
        this.doHide();
    }
    doHide() {
        if (this.options.retainContextWhenHidden !== true) {
            if (this.hideTimeout === undefined) {
                // avoid removing iframe if a widget moved quickly
                this.hideTimeout = setTimeout(() => this.forceHide(), 50);
            }
        }
    }
    forceHide() {
        clearTimeout(this.hideTimeout);
        this.hideTimeout = undefined;
        this.toHide.dispose();
    }
    doShow() {
        clearTimeout(this.hideTimeout);
        this.hideTimeout = undefined;
        if (!this.toHide.disposed) {
            return;
        }
        this.toDispose.push(this.toHide);
        const element = document.createElement('iframe');
        element.className = 'webview';
        element.sandbox.add('allow-scripts', 'allow-forms', 'allow-same-origin', 'allow-downloads');
        if (!browser_1.isFirefox) {
            element.setAttribute('allow', 'clipboard-read; clipboard-write; usb; serial; hid;');
        }
        element.setAttribute('src', `${this.externalEndpoint}/index.html?id=${this.identifier.id}`);
        element.style.border = 'none';
        element.style.width = '100%';
        element.style.height = '100%';
        this.element = element;
        this.node.appendChild(this.element);
        this.toHide.push(disposable_1.Disposable.create(() => {
            if (this.element) {
                this.element.remove();
                this.element = undefined;
            }
        }));
        const oldReady = this.ready;
        const ready = new promise_util_1.Deferred();
        ready.promise.then(() => oldReady.resolve());
        this.ready = ready;
        this.toHide.push(disposable_1.Disposable.create(() => this.ready = new promise_util_1.Deferred()));
        const subscription = this.on("webview-ready" /* WebviewMessageChannels.webviewReady */, () => {
            subscription.dispose();
            ready.resolve();
        });
        this.toHide.push(subscription);
        this.toHide.push(this.on("onmessage" /* WebviewMessageChannels.onmessage */, (data) => this.onMessageEmitter.fire(data)));
        this.toHide.push(this.on("onconsole" /* WebviewMessageChannels.onconsole */, (data) => this.forwardConsoleLog(data)));
        this.toHide.push(this.on("did-click-link" /* WebviewMessageChannels.didClickLink */, (uri) => this.openLink(new uri_1.default(uri))));
        this.toHide.push(this.on("do-update-state" /* WebviewMessageChannels.doUpdateState */, (state) => {
            this._state = state;
        }));
        this.toHide.push(this.on("did-focus" /* WebviewMessageChannels.didFocus */, () => 
        // emulate the webview focus without actually changing focus
        this.node.dispatchEvent(new FocusEvent('focus'))));
        this.toHide.push(this.on("did-blur" /* WebviewMessageChannels.didBlur */, () => {
            /* no-op: webview loses focus only if another element gains focus in the main window */
        }));
        this.toHide.push(this.on("do-reload" /* WebviewMessageChannels.doReload */, () => this.reload()));
        this.toHide.push(this.on("load-resource" /* WebviewMessageChannels.loadResource */, (entry) => this.loadResource(entry.path, entry.query)));
        this.toHide.push(this.on("load-localhost" /* WebviewMessageChannels.loadLocalhost */, (entry) => this.loadLocalhost(entry.origin)));
        this.toHide.push(this.on("did-keydown" /* WebviewMessageChannels.didKeydown */, (data) => {
            // Electron: workaround for https://github.com/electron/electron/issues/14258
            // We have to detect keyboard events in the <webview> and dispatch them to our
            // keybinding service because these events do not bubble to the parent window anymore.
            this.keybindings.dispatchKeyDown(data, this.element);
        }));
        this.toHide.push(this.on("did-mousedown" /* WebviewMessageChannels.didMouseDown */, (data) => {
            // We have to dispatch mousedown events so menus will be closed when clicking inside webviews.
            // See: https://github.com/eclipse-theia/theia/issues/7752
            this.dispatchMouseEvent('mousedown', data);
        }));
        this.toHide.push(this.on("did-mouseup" /* WebviewMessageChannels.didMouseUp */, (data) => {
            this.dispatchMouseEvent('mouseup', data);
        }));
        this.toHide.push(this.on("did-context-menu" /* WebviewMessageChannels.didcontextmenu */, (event) => {
            this.handleContextMenu(event);
        }));
        this.style();
        this.toHide.push(this.themeDataProvider.onDidChangeThemeData(() => this.style()));
        this.doUpdateContent();
        while (this.pendingMessages.length) {
            this.sendMessage(this.pendingMessages.shift());
        }
    }
    async loadLocalhost(origin) {
        const redirect = await this.getRedirect(origin);
        return this.doSend('did-load-localhost', { origin, location: redirect });
    }
    dispatchMouseEvent(type, data) {
        const domRect = this.node.getBoundingClientRect();
        document.dispatchEvent(new MouseEvent(type, {
            ...data,
            clientX: domRect.x + data.clientX,
            clientY: domRect.y + data.clientY
        }));
    }
    handleContextMenu(event) {
        const domRect = this.node.getBoundingClientRect();
        this.contextKeyService.with(this.parent instanceof plugin_view_widget_1.PluginViewWidget ?
            { webviewId: this.parent.options.viewId, ...event.context } : {}, () => {
            this.contextMenuRenderer.render({
                menuPath: exports.WEBVIEW_CONTEXT_MENU,
                args: [event.context],
                anchor: {
                    x: domRect.x + event.clientX, y: domRect.y + event.clientY
                },
                context: this.node
            });
        });
    }
    async getRedirect(url) {
        const uri = new uri_1.default(url);
        const localhost = this.externalUriService.parseLocalhost(uri);
        if (!localhost) {
            return undefined;
        }
        if (this._contentOptions.portMapping) {
            for (const mapping of this._contentOptions.portMapping) {
                if (mapping.webviewPort === localhost.port) {
                    if (mapping.webviewPort !== mapping.extensionHostPort) {
                        return this.toRemoteUrl(uri.withAuthority(`${localhost.address}:${mapping.extensionHostPort}`));
                    }
                }
            }
        }
        return this.toRemoteUrl(uri);
    }
    async toRemoteUrl(localUri) {
        const remoteUri = await this.externalUriService.resolve(localUri);
        const remoteUrl = remoteUri.toString();
        if (remoteUrl[remoteUrl.length - 1] === '/') {
            return remoteUrl.slice(0, remoteUrl.length - 1);
        }
        return remoteUrl;
    }
    setContentOptions(contentOptions) {
        if (coreutils_1.JSONExt.deepEqual(this.contentOptions, contentOptions)) {
            return;
        }
        this._contentOptions = contentOptions;
        this.doUpdateContent();
    }
    setIconUrl(iconUrl) {
        if ((this.iconUrl && iconUrl && coreutils_1.JSONExt.deepEqual(this.iconUrl, iconUrl)) || (this.iconUrl === iconUrl)) {
            return;
        }
        this.toDisposeOnIcon.dispose();
        this.toDispose.push(this.toDisposeOnIcon);
        this.iconUrl = iconUrl;
        if (iconUrl) {
            const darkIconUrl = typeof iconUrl === 'object' ? iconUrl.dark : iconUrl;
            const lightIconUrl = typeof iconUrl === 'object' ? iconUrl.light : iconUrl;
            const iconClass = `webview-${this.identifier.id}-file-icon`;
            this.toDisposeOnIcon.push(this.sharedStyle.insertRule(`.theia-webview-icon.${iconClass}::before`, theme => `background-image: url(${this.toEndpoint(theme.type === 'light' ? lightIconUrl : darkIconUrl)});`));
            this.title.iconClass = `theia-webview-icon ${iconClass}`;
        }
        else {
            this.title.iconClass = '';
        }
    }
    toEndpoint(pathname) {
        return new endpoint_1.Endpoint({ path: pathname }).getRestUrl().toString();
    }
    setHTML(value) {
        this.html = this.preprocessHtml(value);
        this.doUpdateContent();
    }
    preprocessHtml(value) {
        return value
            .replace(/(["'])(?:vscode|theia)-resource:(\/\/([^\s\/'"]+?)(?=\/))?([^\s'"]+?)(["'])/gi, (_, startQuote, _1, scheme, path, endQuote) => {
            if (scheme) {
                return `${startQuote}${this.externalEndpoint}/theia-resource/${scheme}${path}${endQuote}`;
            }
            return `${startQuote}${this.externalEndpoint}/theia-resource/file${path}${endQuote}`;
        });
    }
    onActivateRequest(msg) {
        super.onActivateRequest(msg);
        this.node.focus();
    }
    reload() {
        this.doUpdateContent();
    }
    forwardConsoleLog(log) {
        const message = `[webview: ${this.identifier.id}] ${log.message ? JSON.parse(log.message) : undefined}`;
        if (log.optionalParams !== undefined) {
            console[log.level](message, JSON.parse(log.optionalParams));
        }
        else {
            console[log.level](message);
        }
    }
    style() {
        const { styles, activeThemeType, activeThemeName } = this.themeDataProvider.getThemeData();
        this.doSend('styles', { styles, activeThemeType, activeThemeName });
    }
    openLink(link) {
        const supported = this.toSupportedLink(link);
        if (supported) {
            (0, opener_service_1.open)(this.openerService, supported);
        }
    }
    toSupportedLink(link) {
        if (WebviewWidget_1.standardSupportedLinkSchemes.has(link.scheme)) {
            const linkAsString = link.toString();
            for (const resourceRoot of [this.externalEndpoint + '/theia-resource', this.externalEndpoint + '/vscode-resource']) {
                if (linkAsString.startsWith(resourceRoot + '/')) {
                    return this.normalizeRequestUri(linkAsString.substring(resourceRoot.length));
                }
            }
            return link;
        }
        if (link.scheme === uri_components_1.Schemes.command) {
            if (Array.isArray(this.contentOptions.enableCommandUris) && this.contentOptions.enableCommandUris.some(value => value === link.path.toString())) {
                return link;
            }
            else if (this.contentOptions.enableCommandUris === true) {
                return link;
            }
        }
        return undefined;
    }
    async loadResource(requestPath, requestQuery = '') {
        const normalizedUri = this.normalizeRequestUri(requestPath).withQuery(decodeURIComponent(requestQuery));
        // browser cache does not support file scheme, normalize to current endpoint scheme and host
        // use requestPath rather than normalizedUri.path to preserve the scheme of the requested resource as a path segment
        const cacheUrl = new endpoint_1.Endpoint({ path: requestPath }).getRestUrl().withQuery(decodeURIComponent(requestQuery)).toString();
        try {
            if (this.contentOptions.localResourceRoots) {
                for (const root of this.contentOptions.localResourceRoots) {
                    if (!new uri_1.default(root).path.isEqualOrParent(normalizedUri.path)) {
                        continue;
                    }
                    let cached = await this.resourceCache.match(cacheUrl);
                    try {
                        const result = await this.fileService.readFileStream(normalizedUri, { etag: cached === null || cached === void 0 ? void 0 : cached.eTag });
                        const { buffer } = await buffer_1.BinaryBufferReadableStream.toBuffer(result.value);
                        cached = { body: () => buffer, eTag: result.etag };
                        this.resourceCache.put(cacheUrl, cached);
                    }
                    catch (e) {
                        if (!(e instanceof files_1.FileOperationError && e.fileOperationResult === 2 /* FileOperationResult.FILE_NOT_MODIFIED_SINCE */)) {
                            throw e;
                        }
                    }
                    if (cached) {
                        const data = await cached.body();
                        return this.doSend('did-load-resource', {
                            status: 200,
                            path: requestPath,
                            mime: mime.getType(normalizedUri.path.toString()) || 'application/octet-stream',
                            data
                        });
                    }
                }
            }
        }
        catch {
            // no-op
        }
        this.resourceCache.delete(cacheUrl);
        return this.doSend('did-load-resource', {
            status: 404,
            path: requestPath
        });
    }
    normalizeRequestUri(requestPath) {
        const normalizedPath = decodeURIComponent(requestPath);
        const requestUri = new uri_1.default(normalizedPath.replace(/^\/([a-zA-Z0-9.\-+]+)\/(.+)$/, (_, scheme, path) => scheme + ':/' + path));
        if (requestUri.scheme !== 'theia-resource' && requestUri.scheme !== 'vscode-resource') {
            return requestUri;
        }
        // Modern vscode-resources uris put the scheme of the requested resource as the authority
        if (requestUri.authority) {
            return new uri_1.default(requestUri.authority + ':' + requestUri.path);
        }
        // Old style vscode-resource uris lose the scheme of the resource which means they are unable to
        // load a mix of local and remote content properly.
        return requestUri.withScheme('file');
    }
    sendMessage(data) {
        if (this.element) {
            this.doSend('message', data);
        }
        else {
            this.pendingMessages.push(data);
        }
    }
    doUpdateContent() {
        this.doSend('content', {
            contents: this.html,
            options: this.contentOptions,
            state: this.state
        });
    }
    storeState() {
        return {
            viewType: this.viewType,
            title: this.title.label,
            iconUrl: this.iconUrl,
            options: this.options,
            contentOptions: this.contentOptions,
            state: this.state
        };
    }
    restoreState(oldState) {
        const { viewType, title, iconUrl, options, contentOptions, state } = oldState;
        this.viewType = viewType;
        this.title.label = title;
        this.setIconUrl(iconUrl);
        this.options = options;
        this._contentOptions = contentOptions;
        this._state = state;
    }
    setIframeHeight(height) {
        if (this.element) {
            this.element.style.height = `${height}px`;
        }
    }
    async doSend(channel, data) {
        if (!this.element) {
            return;
        }
        try {
            await this.ready.promise;
            this.postMessage(channel, data);
        }
        catch (e) {
            console.error(e);
        }
    }
    postMessage(channel, data) {
        if (this.element) {
            this.trace('out', channel, data);
            if (this.secondaryWindow) {
                this.secondaryWindow.postMessage({ channel, args: data }, '*');
            }
            else {
                this.element.contentWindow.postMessage({ channel, args: data }, '*');
            }
        }
    }
    on(channel, handler) {
        const listener = (e) => {
            if (!e || !e.data || e.data.target !== this.identifier.id) {
                return;
            }
            if (e.data.channel === channel) {
                this.trace('in', e.data.channel, e.data.data);
                handler(e.data.data);
            }
        };
        window.addEventListener('message', listener);
        return disposable_1.Disposable.create(() => window.removeEventListener('message', listener));
    }
    trace(kind, channel, data) {
        const value = this.preferences['webview.trace'];
        if (value === 'off') {
            return;
        }
        const output = this.outputManager.getChannel('webviews');
        output.append('\n' + this.identifier.id);
        output.append(kind === 'out' ? ' => ' : ' <= ');
        output.append(channel);
        if (value === 'verbose') {
            if (data) {
                output.append('\n' + JSON.stringify(data, undefined, 2));
            }
        }
    }
};
exports.WebviewWidget = WebviewWidget;
WebviewWidget.standardSupportedLinkSchemes = new Set([
    uri_components_1.Schemes.http,
    uri_components_1.Schemes.https,
    uri_components_1.Schemes.mailto,
    uri_components_1.Schemes.vscode,
    uri_components_1.Schemes.vscodeNotebookCell
]);
WebviewWidget.FACTORY_ID = 'plugin-webview';
tslib_1.__decorate([
    (0, inversify_1.inject)(WebviewWidgetIdentifier),
    tslib_1.__metadata("design:type", WebviewWidgetIdentifier)
], WebviewWidget.prototype, "identifier", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(exports.WebviewWidgetExternalEndpoint),
    tslib_1.__metadata("design:type", String)
], WebviewWidget.prototype, "externalEndpoint", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(application_shell_mouse_tracker_1.ApplicationShellMouseTracker),
    tslib_1.__metadata("design:type", application_shell_mouse_tracker_1.ApplicationShellMouseTracker)
], WebviewWidget.prototype, "mouseTracker", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(webview_environment_1.WebviewEnvironment),
    tslib_1.__metadata("design:type", webview_environment_1.WebviewEnvironment)
], WebviewWidget.prototype, "environment", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(opener_service_1.OpenerService),
    tslib_1.__metadata("design:type", Object)
], WebviewWidget.prototype, "openerService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(keybinding_1.KeybindingRegistry),
    tslib_1.__metadata("design:type", keybinding_1.KeybindingRegistry)
], WebviewWidget.prototype, "keybindings", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(plugin_shared_style_1.PluginSharedStyle),
    tslib_1.__metadata("design:type", plugin_shared_style_1.PluginSharedStyle)
], WebviewWidget.prototype, "sharedStyle", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(webview_theme_data_provider_1.WebviewThemeDataProvider),
    tslib_1.__metadata("design:type", webview_theme_data_provider_1.WebviewThemeDataProvider)
], WebviewWidget.prototype, "themeDataProvider", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(external_uri_service_1.ExternalUriService),
    tslib_1.__metadata("design:type", external_uri_service_1.ExternalUriService)
], WebviewWidget.prototype, "externalUriService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(output_channel_1.OutputChannelManager),
    tslib_1.__metadata("design:type", output_channel_1.OutputChannelManager)
], WebviewWidget.prototype, "outputManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(webview_preferences_1.WebviewPreferences),
    tslib_1.__metadata("design:type", Object)
], WebviewWidget.prototype, "preferences", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(file_service_1.FileService),
    tslib_1.__metadata("design:type", file_service_1.FileService)
], WebviewWidget.prototype, "fileService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(webview_resource_cache_1.WebviewResourceCache),
    tslib_1.__metadata("design:type", webview_resource_cache_1.WebviewResourceCache)
], WebviewWidget.prototype, "resourceCache", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(browser_2.ContextMenuRenderer),
    tslib_1.__metadata("design:type", browser_2.ContextMenuRenderer)
], WebviewWidget.prototype, "contextMenuRenderer", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(context_key_service_1.ContextKeyService),
    tslib_1.__metadata("design:type", Object)
], WebviewWidget.prototype, "contextKeyService", void 0);
tslib_1.__decorate([
    (0, inversify_1.postConstruct)(),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", []),
    tslib_1.__metadata("design:returntype", void 0)
], WebviewWidget.prototype, "init", null);
exports.WebviewWidget = WebviewWidget = WebviewWidget_1 = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], WebviewWidget);
(function (WebviewWidget) {
    let Styles;
    (function (Styles) {
        Styles.WEBVIEW = 'theia-webview';
    })(Styles = WebviewWidget.Styles || (WebviewWidget.Styles = {}));
})(WebviewWidget || (exports.WebviewWidget = WebviewWidget = {}));


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/webviews-main.js"
/*!******************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/webviews-main.js ***!
  \******************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebviewsMainImpl = void 0;
const debounce = __webpack_require__(/*! @theia/core/shared/lodash.debounce */ "../../node_modules/@theia/core/shared/lodash.debounce/index.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../../node_modules/@theia/core/shared/vscode-uri/index.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const application_shell_1 = __webpack_require__(/*! @theia/core/lib/browser/shell/application-shell */ "../../node_modules/@theia/core/lib/browser/shell/application-shell.js");
const webview_1 = __webpack_require__(/*! ./webview/webview */ "../../node_modules/@theia/plugin-ext/lib/main/browser/webview/webview.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const view_column_service_1 = __webpack_require__(/*! @theia/core/lib/browser/shell/view-column-service */ "../../node_modules/@theia/core/lib/browser/shell/view-column-service.js");
const widget_manager_1 = __webpack_require__(/*! @theia/core/lib/browser/widget-manager */ "../../node_modules/@theia/core/lib/browser/widget-manager.js");
const coreutils_1 = __webpack_require__(/*! @theia/core/shared/@lumino/coreutils */ "../../node_modules/@theia/core/shared/@lumino/coreutils/index.js");
const hosted_plugin_1 = __webpack_require__(/*! ../../hosted/browser/hosted-plugin */ "../../node_modules/@theia/plugin-ext/lib/hosted/browser/hosted-plugin.js");
const custom_editor_widget_1 = __webpack_require__(/*! ./custom-editors/custom-editor-widget */ "../../node_modules/@theia/plugin-ext/lib/main/browser/custom-editors/custom-editor-widget.js");
const types_impl_1 = __webpack_require__(/*! ../../plugin/types-impl */ "../../node_modules/@theia/plugin-ext/lib/plugin/types-impl.js");
class WebviewsMainImpl {
    constructor(rpc, container) {
        this.toDispose = new disposable_1.DisposableCollection();
        this.updateViewStates = debounce(() => {
            const widgets = this.widgetManager.getWidgets(webview_1.WebviewWidget.FACTORY_ID);
            const customEditors = this.widgetManager.getWidgets(custom_editor_widget_1.CustomEditorWidget.FACTORY_ID);
            for (const widget of widgets.concat(customEditors)) {
                if (widget instanceof webview_1.WebviewWidget) {
                    this.updateViewState(widget);
                }
            }
        }, 100);
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.WEBVIEWS_EXT);
        this.shell = container.get(application_shell_1.ApplicationShell);
        this.viewColumnService = container.get(view_column_service_1.ViewColumnService);
        this.widgetManager = container.get(widget_manager_1.WidgetManager);
        this.pluginService = container.get(hosted_plugin_1.HostedPluginSupport);
        this.toDispose.push(this.shell.onDidChangeActiveWidget(() => this.updateViewStates()));
        this.toDispose.push(this.shell.onDidChangeCurrentWidget(() => this.updateViewStates()));
        this.toDispose.push(this.viewColumnService.onViewColumnChanged(() => this.updateViewStates()));
    }
    dispose() {
        this.toDispose.dispose();
    }
    async $createWebviewPanel(panelId, viewType, title, showOptions, options) {
        const view = await this.widgetManager.getOrCreateWidget(webview_1.WebviewWidget.FACTORY_ID, { id: panelId, viewId: viewType });
        this.hookWebview(view);
        view.viewType = viewType;
        view.title.label = title;
        const { enableFindWidget, retainContextWhenHidden, enableScripts, enableForms, localResourceRoots, ...contentOptions } = options;
        view.options = { enableFindWidget, retainContextWhenHidden };
        view.setContentOptions({
            allowScripts: enableScripts,
            allowForms: enableForms,
            localResourceRoots: localResourceRoots && localResourceRoots.map(root => root.toString()),
            ...contentOptions
        });
        this.addOrReattachWidget(view, showOptions);
    }
    hookWebview(view) {
        const handle = view.identifier.id;
        this.toDispose.push(view.onDidChangeVisibility(() => this.updateViewState(view)));
        this.toDispose.push(view.onMessage(data => this.proxy.$onMessage(handle, data)));
        view.disposed.connect(() => {
            if (this.toDispose.disposed) {
                return;
            }
            this.proxy.$onDidDisposeWebviewPanel(handle);
        });
    }
    addOrReattachWidget(widget, showOptions) {
        var _a;
        const area = showOptions.area ? showOptions.area : types_impl_1.WebviewPanelTargetArea.Main;
        const widgetOptions = { area };
        let mode = 'open-to-right';
        const canOpenBeside = showOptions.viewColumn === types_impl_1.ViewColumn.Beside && (area === types_impl_1.WebviewPanelTargetArea.Main || area === types_impl_1.WebviewPanelTargetArea.Bottom);
        if (canOpenBeside) {
            const activeOrRightmostTabbar = this.shell.getTabBarFor(area);
            const ref = (_a = activeOrRightmostTabbar === null || activeOrRightmostTabbar === void 0 ? void 0 : activeOrRightmostTabbar.currentTitle) === null || _a === void 0 ? void 0 : _a.owner;
            if (ref) {
                Object.assign(widgetOptions, { ref, mode });
            }
        }
        else if (widgetOptions.area === 'main' && showOptions.viewColumn !== undefined) {
            this.viewColumnService.updateViewColumns();
            let widgetIds = this.viewColumnService.getViewColumnIds(showOptions.viewColumn);
            if (widgetIds.length > 0) {
                mode = 'tab-after';
            }
            else if (showOptions.viewColumn >= 0) {
                const columnsSize = this.viewColumnService.viewColumnsSize();
                if (columnsSize) {
                    showOptions.viewColumn = columnsSize - 1;
                    widgetIds = this.viewColumnService.getViewColumnIds(showOptions.viewColumn);
                }
            }
            const ref = this.shell.getWidgets(widgetOptions.area).find(w => !w.isHidden && widgetIds.indexOf(w.id) !== -1);
            if (ref) {
                Object.assign(widgetOptions, { ref, mode });
            }
        }
        this.shell.addWidget(widget, widgetOptions);
        if (showOptions.preserveFocus) {
            this.shell.revealWidget(widget.id);
        }
        else {
            this.shell.activateWidget(widget.id);
        }
    }
    async $disposeWebview(handle) {
        const view = await this.tryGetWebview(handle);
        if (view) {
            view.dispose();
        }
    }
    async $reveal(handle, showOptions) {
        const widget = await this.getWebview(handle);
        if (widget.isDisposed) {
            return;
        }
        if ((showOptions.viewColumn !== undefined && showOptions.viewColumn !== widget.viewState.position) || showOptions.area !== undefined) {
            this.viewColumnService.updateViewColumns();
            const columnIds = showOptions.viewColumn ? this.viewColumnService.getViewColumnIds(showOptions.viewColumn) : [];
            const area = this.shell.getAreaFor(widget);
            if (columnIds.indexOf(widget.id) === -1 || area !== showOptions.area) {
                this.addOrReattachWidget(widget, showOptions);
                return;
            }
        }
        if (showOptions.preserveFocus) {
            this.shell.revealWidget(widget.id);
        }
        else {
            this.shell.activateWidget(widget.id);
        }
    }
    async $setTitle(handle, value) {
        const webview = await this.getWebview(handle);
        webview.title.label = value;
    }
    async $setIconPath(handle, iconUrl) {
        const webview = await this.getWebview(handle);
        webview.setIconUrl(iconUrl);
    }
    async $setHtml(handle, value) {
        const webview = await this.getWebview(handle);
        webview.setHTML(value);
    }
    async $setOptions(handle, options) {
        const webview = await this.getWebview(handle);
        const { enableScripts, enableForms, localResourceRoots, ...contentOptions } = options;
        webview.setContentOptions({
            allowScripts: enableScripts,
            allowForms: enableForms,
            localResourceRoots: localResourceRoots && localResourceRoots.map(root => root.toString()),
            ...contentOptions
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async $postMessage(handle, value) {
        // Due to async nature of $postMessage, the webview may have been disposed in the meantime.
        // Therefore, don't throw an error if the webview is not found, but return false in this case.
        const webview = await this.tryGetWebview(handle);
        if (!webview) {
            return false;
        }
        webview.sendMessage(value);
        return true;
    }
    $registerSerializer(viewType) {
        this.pluginService.registerWebviewReviver(viewType, widget => this.restoreWidget(widget));
        this.toDispose.push(disposable_1.Disposable.create(() => this.$unregisterSerializer(viewType)));
    }
    $unregisterSerializer(viewType) {
        this.pluginService.unregisterWebviewReviver(viewType);
    }
    async restoreWidget(widget) {
        this.hookWebview(widget);
        const handle = widget.identifier.id;
        const title = widget.title.label;
        let state = undefined;
        if (widget.state) {
            try {
                state = JSON.parse(widget.state);
            }
            catch {
                // noop
            }
        }
        const options = widget.options;
        const { allowScripts, allowForms, localResourceRoots, ...contentOptions } = widget.contentOptions;
        this.updateViewState(widget);
        await this.proxy.$deserializeWebviewPanel(handle, widget.viewType, title, state, widget.viewState, {
            enableScripts: allowScripts,
            enableForms: allowForms,
            localResourceRoots: localResourceRoots && localResourceRoots.map(root => vscode_uri_1.URI.parse(root)),
            ...contentOptions,
            ...options
        });
    }
    updateViewState(widget, viewColumn) {
        const viewState = {
            active: this.shell.activeWidget === widget,
            visible: !widget.isHidden,
            position: viewColumn || 0
        };
        if (typeof viewColumn !== 'number') {
            this.viewColumnService.updateViewColumns();
            viewState.position = this.viewColumnService.getViewColumn(widget.id) || 0;
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (coreutils_1.JSONExt.deepEqual(viewState, widget.viewState)) {
            return;
        }
        widget.viewState = viewState;
        this.proxy.$onDidChangeWebviewPanelViewState(widget.identifier.id, widget.viewState);
    }
    async getWebview(viewId) {
        const webview = await this.tryGetWebview(viewId);
        if (!webview) {
            throw new Error(`Unknown Webview: ${viewId}`);
        }
        return webview;
    }
    async tryGetWebview(id) {
        const webview = await this.widgetManager.findWidget(webview_1.WebviewWidget.FACTORY_ID, options => {
            if (options) {
                return options.id === id;
            }
            return false;
        })
            || await this.widgetManager.getWidget(custom_editor_widget_1.CustomEditorWidget.FACTORY_ID, { id });
        return webview;
    }
}
exports.WebviewsMainImpl = WebviewsMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/window-activity-tracker.js"
/*!****************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/window-activity-tracker.js ***!
  \****************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2024 STMicroelectronics and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WindowActivityTracker = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const CHECK_INACTIVITY_LIMIT = 30;
const CHECK_INACTIVITY_INTERVAL = 1000;
const eventListenerOptions = {
    passive: true,
    capture: true
};
class WindowActivityTracker {
    constructor(win) {
        this.win = win;
        this.inactivityCounter = 0; // number of times inactivity was checked since last reset
        this.inactivityLimit = CHECK_INACTIVITY_LIMIT; // number of inactivity checks done before sending inactive signal
        this.checkInactivityInterval = CHECK_INACTIVITY_INTERVAL; // check interval in milliseconds
        this.onDidChangeActiveStateEmitter = new core_1.Emitter();
        this._activeState = true;
        // Reset inactivity time
        this.resetInactivity = () => {
            this.inactivityCounter = 0;
            if (!this.interval) {
                // it was not active. Set as active and restart tracking inactivity
                this.activeState = true;
                this.startTracking();
            }
        };
        // Check inactivity status
        this.checkInactivity = () => {
            this.inactivityCounter++;
            if (this.inactivityCounter >= this.inactivityLimit) {
                this.activeState = false;
                this.stopTracking();
            }
        };
        this.initializeListeners(this.win);
    }
    get onDidChangeActiveState() {
        return this.onDidChangeActiveStateEmitter.event;
    }
    set activeState(newState) {
        if (this._activeState !== newState) {
            this._activeState = newState;
            this.onDidChangeActiveStateEmitter.fire(this._activeState);
        }
    }
    initializeListeners(win) {
        // currently assumes activity based on key/mouse/touch pressed, not on mouse move or scrolling.
        win.addEventListener('mousedown', this.resetInactivity, eventListenerOptions);
        win.addEventListener('keydown', this.resetInactivity, eventListenerOptions);
        win.addEventListener('touchstart', this.resetInactivity, eventListenerOptions);
    }
    dispose() {
        this.stopTracking();
        this.win.removeEventListener('mousedown', this.resetInactivity);
        this.win.removeEventListener('keydown', this.resetInactivity);
        this.win.removeEventListener('touchstart', this.resetInactivity);
    }
    startTracking() {
        this.stopTracking();
        this.interval = setInterval(this.checkInactivity, this.checkInactivityInterval);
    }
    stopTracking() {
        if (this.interval) {
            clearInterval(this.interval);
            this.interval = undefined;
        }
    }
}
exports.WindowActivityTracker = WindowActivityTracker;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/window-state-main.js"
/*!**********************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/window-state-main.js ***!
  \**********************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WindowStateMain = void 0;
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../../node_modules/@theia/core/shared/vscode-uri/index.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../../node_modules/@theia/core/lib/common/uri.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const opener_service_1 = __webpack_require__(/*! @theia/core/lib/browser/opener-service */ "../../node_modules/@theia/core/lib/browser/opener-service.js");
const external_uri_service_1 = __webpack_require__(/*! @theia/core/lib/browser/external-uri-service */ "../../node_modules/@theia/core/lib/browser/external-uri-service.js");
const window_activity_tracker_1 = __webpack_require__(/*! ./window-activity-tracker */ "../../node_modules/@theia/plugin-ext/lib/main/browser/window-activity-tracker.js");
class WindowStateMain {
    constructor(rpc, container) {
        this.toDispose = new disposable_1.DisposableCollection();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.WINDOW_STATE_EXT);
        this.openerService = container.get(opener_service_1.OpenerService);
        this.externalUriService = container.get(external_uri_service_1.ExternalUriService);
        const fireDidFocus = () => this.onFocusChanged(true);
        window.addEventListener('focus', fireDidFocus);
        this.toDispose.push(disposable_1.Disposable.create(() => window.removeEventListener('focus', fireDidFocus)));
        const fireDidBlur = () => this.onFocusChanged(false);
        window.addEventListener('blur', fireDidBlur);
        this.toDispose.push(disposable_1.Disposable.create(() => window.removeEventListener('blur', fireDidBlur)));
        const tracker = new window_activity_tracker_1.WindowActivityTracker(window);
        this.toDispose.push(tracker.onDidChangeActiveState(isActive => this.onActiveStateChanged(isActive)));
        this.toDispose.push(tracker);
    }
    dispose() {
        this.toDispose.dispose();
    }
    onFocusChanged(focused) {
        this.proxy.$onDidChangeWindowFocus(focused);
    }
    onActiveStateChanged(isActive) {
        this.proxy.$onDidChangeWindowActive(isActive);
    }
    async $openUri(uriComponent) {
        const uri = vscode_uri_1.URI.revive(uriComponent);
        const url = new uri_1.default(encodeURI(uri.toString(true)));
        try {
            await (0, opener_service_1.open)(this.openerService, url, { openExternalApp: true });
            return true;
        }
        catch (e) {
            return false;
        }
    }
    async $asExternalUri(uriComponents) {
        const uri = vscode_uri_1.URI.revive(uriComponents);
        const resolved = await this.externalUriService.resolve(new uri_1.default(uri));
        return vscode_uri_1.URI.parse(resolved.toString());
    }
}
exports.WindowStateMain = WindowStateMain;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/browser/workspace-main.js"
/*!*******************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/browser/workspace-main.js ***!
  \*******************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextContentResource = exports.TextContentResourceResolver = exports.WorkspaceMainImpl = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
const vscode_uri_1 = __webpack_require__(/*! @theia/core/shared/vscode-uri */ "../../node_modules/@theia/core/shared/vscode-uri/index.js");
const file_search_service_1 = __webpack_require__(/*! @theia/file-search/lib/common/file-search-service */ "../../node_modules/@theia/file-search/lib/common/file-search-service.js");
const uri_1 = __webpack_require__(/*! @theia/core/lib/common/uri */ "../../node_modules/@theia/core/lib/common/uri.js");
const browser_1 = __webpack_require__(/*! @theia/workspace/lib/browser */ "../../node_modules/@theia/workspace/lib/browser/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const plugin_protocol_1 = __webpack_require__(/*! ../../common/plugin-protocol */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-protocol.js");
const common_1 = __webpack_require__(/*! @theia/filesystem/lib/common */ "../../node_modules/@theia/filesystem/lib/common/index.js");
const search_in_workspace_service_1 = __webpack_require__(/*! @theia/search-in-workspace/lib/browser/search-in-workspace-service */ "../../node_modules/@theia/search-in-workspace/lib/browser/search-in-workspace-service.js");
const monaco_quick_input_service_1 = __webpack_require__(/*! @theia/monaco/lib/browser/monaco-quick-input-service */ "../../node_modules/@theia/monaco/lib/browser/monaco-quick-input-service.js");
const request_1 = __webpack_require__(/*! @theia/core/shared/@theia/request */ "../../node_modules/@theia/core/shared/@theia/request/index.js");
const encodings_1 = __webpack_require__(/*! @theia/core/lib/common/encodings */ "../../node_modules/@theia/core/lib/common/encodings.js");
const encoding_registry_1 = __webpack_require__(/*! @theia/core/lib/browser/encoding-registry */ "../../node_modules/@theia/core/lib/browser/encoding-registry.js");
const preference_service_1 = __webpack_require__(/*! @theia/core/lib/common/preferences/preference-service */ "../../node_modules/@theia/core/lib/common/preferences/preference-service.js");
class WorkspaceMainImpl {
    constructor(rpc, container) {
        this.toDispose = new disposable_1.DisposableCollection();
        this.workspaceSearch = new Set();
        this.canonicalUriProviders = new Map();
        this.proxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.WORKSPACE_EXT);
        this.storageProxy = rpc.getProxy(plugin_api_rpc_1.MAIN_RPC_CONTEXT.STORAGE_EXT);
        this.monacoQuickInputService = container.get(monaco_quick_input_service_1.MonacoQuickInputService);
        this.fileSearchService = container.get(file_search_service_1.FileSearchService);
        this.searchInWorkspaceService = container.get(search_in_workspace_service_1.SearchInWorkspaceService);
        this.resourceResolver = container.get(TextContentResourceResolver);
        this.pluginServer = container.get(plugin_protocol_1.PluginServer);
        this.requestService = container.get(request_1.RequestService);
        this.workspaceService = container.get(browser_1.WorkspaceService);
        this.canonicalUriService = container.get(browser_1.CanonicalUriService);
        this.workspaceTrustService = container.get(browser_1.WorkspaceTrustService);
        this.encodingRegistry = container.get(encoding_registry_1.EncodingRegistry);
        this.fsPreferences = container.get(common_1.FileSystemPreferences);
        this.preferenceService = container.get(preference_service_1.PreferenceService);
        this.processWorkspaceFoldersChanged(this.workspaceService.tryGetRoots().map(root => root.resource.toString()));
        this.toDispose.push(this.workspaceService.onWorkspaceChanged(roots => {
            this.processWorkspaceFoldersChanged(roots.map(root => root.resource.toString()));
        }));
        this.toDispose.push(this.workspaceService.onWorkspaceLocationChanged(stat => {
            this.proxy.$onWorkspaceLocationChanged(stat);
        }));
        this.workspaceTrustService.getWorkspaceTrust().then(trust => this.proxy.$onWorkspaceTrustChanged(trust));
    }
    dispose() {
        this.toDispose.dispose();
    }
    $resolveProxy(url) {
        return this.requestService.resolveProxy(url);
    }
    async processWorkspaceFoldersChanged(roots) {
        var _a;
        if (this.isAnyRootChanged(roots) === false) {
            return;
        }
        this.roots = roots;
        this.proxy.$onWorkspaceFoldersChanged({ roots });
        const keyValueStorageWorkspacesData = await this.pluginServer.getAllStorageValues({
            workspace: (_a = this.workspaceService.workspace) === null || _a === void 0 ? void 0 : _a.resource.toString(),
            roots: this.workspaceService.tryGetRoots().map(root => root.resource.toString())
        });
        this.storageProxy.$updatePluginsWorkspaceData(keyValueStorageWorkspacesData);
    }
    isAnyRootChanged(roots) {
        if (!this.roots || this.roots.length !== roots.length) {
            return true;
        }
        return this.roots.some((root, index) => root !== roots[index]);
    }
    async $getWorkspace() {
        return this.workspaceService.workspace;
    }
    $pickWorkspaceFolder(options) {
        return new Promise((resolve, reject) => {
            // Return undefined if workspace root is not set
            if (!this.roots || !this.roots.length) {
                resolve(undefined);
                return;
            }
            // Active before appearing the pick menu
            const activeElement = window.document.activeElement;
            // WorkspaceFolder to be returned
            let returnValue;
            const items = this.roots.map(root => {
                const rootUri = vscode_uri_1.URI.parse(root);
                const rootPathName = rootUri.path.substring(rootUri.path.lastIndexOf('/') + 1);
                return {
                    label: rootPathName,
                    detail: rootUri.path,
                    execute: () => {
                        returnValue = {
                            uri: rootUri,
                            name: rootPathName,
                            index: 0
                        };
                    }
                };
            });
            // Show pick menu
            this.monacoQuickInputService.showQuickPick(items, {
                onDidHide: () => {
                    if (activeElement) {
                        activeElement.focus({ preventScroll: true });
                    }
                    resolve(returnValue);
                }
            });
        });
    }
    async $startFileSearch(includePattern, includeFolderUri, options) {
        const roots = {};
        const rootUris = includeFolderUri ? [includeFolderUri] : this.roots;
        for (const rootUri of rootUris) {
            roots[rootUri] = {};
        }
        const opts = {
            rootOptions: roots,
            fuzzyMatch: options.fuzzy,
            useGitIgnore: options.useIgnoreFiles
        };
        if (includePattern) {
            opts.includePatterns = [includePattern];
        }
        if (options.exclude) {
            opts.excludePatterns = [options.exclude];
        }
        if (options.useDefaultExcludes) {
            for (const rootUri of rootUris) {
                const filesExclude = this.fsPreferences.get('files.exclude', undefined, rootUri);
                if (filesExclude) {
                    for (const excludePattern in filesExclude) {
                        if (filesExclude[excludePattern]) {
                            const rootOptions = roots[rootUri];
                            const rootExcludePatterns = rootOptions.excludePatterns || [];
                            rootExcludePatterns.push(excludePattern);
                            rootOptions.excludePatterns = rootExcludePatterns;
                        }
                    }
                }
            }
        }
        if (typeof options.maxResults === 'number') {
            opts.limit = options.maxResults;
        }
        const uriStrs = await this.fileSearchService.find('', opts);
        return uriStrs.map(uriStr => vscode_uri_1.URI.parse(uriStr));
    }
    async $findTextInFiles(query, options, searchRequestId, token = core_1.CancellationToken.None) {
        const maxHits = options.maxResults ? options.maxResults : 150;
        const excludes = options.exclude ? (typeof options.exclude === 'string' ? options.exclude : options.exclude.pattern) : undefined;
        const includes = options.include ? (typeof options.include === 'string' ? options.include : options.include.pattern) : undefined;
        let canceledRequest = false;
        return new Promise(resolve => {
            let matches = 0;
            const what = query.pattern;
            this.searchInWorkspaceService.searchWithCallback(what, this.roots, {
                onResult: (searchId, result) => {
                    if (canceledRequest) {
                        return;
                    }
                    const hasSearch = this.workspaceSearch.has(searchId);
                    if (!hasSearch) {
                        this.workspaceSearch.add(searchId);
                        token.onCancellationRequested(() => {
                            this.searchInWorkspaceService.cancel(searchId);
                            canceledRequest = true;
                        });
                    }
                    if (token.isCancellationRequested) {
                        this.searchInWorkspaceService.cancel(searchId);
                        canceledRequest = true;
                        return;
                    }
                    if (result && result.matches && result.matches.length) {
                        while ((matches + result.matches.length) > maxHits) {
                            result.matches.splice(result.matches.length - 1, 1);
                        }
                        this.proxy.$onTextSearchResult(searchRequestId, false, result);
                        matches += result.matches.length;
                        if (maxHits <= matches) {
                            this.searchInWorkspaceService.cancel(searchId);
                        }
                    }
                },
                onDone: (searchId, _error) => {
                    const hasSearch = this.workspaceSearch.has(searchId);
                    if (hasSearch) {
                        this.searchInWorkspaceService.cancel(searchId);
                        this.workspaceSearch.delete(searchId);
                    }
                    this.proxy.$onTextSearchResult(searchRequestId, true);
                    if (maxHits <= matches) {
                        resolve({ limitHit: true });
                    }
                    else {
                        resolve({ limitHit: false });
                    }
                }
            }, {
                useRegExp: query.isRegExp,
                matchCase: query.isCaseSensitive,
                matchWholeWord: query.isWordMatch,
                exclude: excludes ? [excludes] : undefined,
                include: includes ? [includes] : undefined,
                maxResults: maxHits
            });
        });
    }
    async $registerTextDocumentContentProvider(scheme) {
        this.resourceResolver.registerContentProvider(scheme, this.proxy);
        this.toDispose.push(disposable_1.Disposable.create(() => this.resourceResolver.unregisterContentProvider(scheme)));
    }
    $unregisterTextDocumentContentProvider(scheme) {
        this.resourceResolver.unregisterContentProvider(scheme);
    }
    $onTextDocumentContentChange(uri, content) {
        this.resourceResolver.onContentChange(uri, content);
    }
    async $updateWorkspaceFolders(start, deleteCount, ...rootsToAdd) {
        await this.workspaceService.spliceRoots(start, deleteCount, ...rootsToAdd.map(root => new uri_1.default(root)));
    }
    async $requestWorkspaceTrust(_options) {
        return this.workspaceTrustService.requestWorkspaceTrust();
    }
    async $registerCanonicalUriProvider(scheme) {
        this.canonicalUriProviders.set(scheme, this.canonicalUriService.registerCanonicalUriProvider(scheme, {
            provideCanonicalUri: async (uri, targetScheme, token) => {
                const canonicalUri = await this.proxy.$provideCanonicalUri(uri.toString(), targetScheme, core_1.CancellationToken.None);
                return (0, core_1.isUndefined)(uri) ? undefined : new uri_1.default(canonicalUri);
            },
            dispose: () => {
                this.proxy.$disposeCanonicalUriProvider(scheme);
            },
        }));
    }
    $unregisterCanonicalUriProvider(scheme) {
        const disposable = this.canonicalUriProviders.get(scheme);
        if (disposable) {
            this.canonicalUriProviders.delete(scheme);
            disposable.dispose();
        }
        else {
            console.warn(`No canonical uri provider registered for '${scheme}'`);
        }
    }
    async $getCanonicalUri(uri, targetScheme, token) {
        const canonicalUri = await this.canonicalUriService.provideCanonicalUri(new uri_1.default(uri), targetScheme, token);
        return (0, core_1.isUndefined)(canonicalUri) ? undefined : canonicalUri.toString();
    }
    async $resolveDecoding(resource, options) {
        const preferredEncoding = await this.getPreferredReadEncoding(resource, options);
        return {
            preferredEncoding,
            guessEncoding: this.preferenceService.get('files.autoGuessEncoding', false, resource ? resource.toString() : undefined)
        };
    }
    async $resolveEncoding(resource, options) {
        var _a;
        let encoding;
        if (resource) {
            encoding = await this.encodingRegistry.getEncodingForResource(uri_1.default.fromComponents(resource), options === null || options === void 0 ? void 0 : options.encoding);
        }
        else {
            encoding = (_a = options === null || options === void 0 ? void 0 : options.encoding) !== null && _a !== void 0 ? _a : encodings_1.UTF8;
        }
        // see https://github.com/microsoft/vscode/blob/118f9ecd71a8f101b71ae19e3bf44802aa173209/src/vs/workbench/services/textfile/browser/textFileService.ts#L806
        const hasBOM = encoding === encodings_1.UTF16be || encoding === encodings_1.UTF16le || encoding === encodings_1.UTF8_with_bom;
        return { encoding, hasBOM };
    }
    async $getValidEncoding(uri, detectedEncoding, options) {
        return this.getPreferredReadEncoding(uri, options, detectedEncoding);
    }
    async getPreferredReadEncoding(uri, options, detectedEncoding) {
        let preferredEncoding;
        // either encoding is passed as an option
        // or we have a detected encoding,
        // or we are looking in the preferences
        // or we default at UTF8
        if (options === null || options === void 0 ? void 0 : options.encoding) {
            if (detectedEncoding === encodings_1.UTF8_with_bom && options.encoding === encodings_1.UTF8) {
                preferredEncoding = encodings_1.UTF8_with_bom; // indicate the file has BOM if we are to resolve with UTF 8
            }
            else {
                preferredEncoding = options.encoding; // give passed in encoding highest priority
            }
        }
        else if (typeof detectedEncoding === 'string') {
            preferredEncoding = detectedEncoding;
        }
        let encoding;
        if (uri) {
            encoding = await this.encodingRegistry.getEncodingForResource(uri_1.default.fromComponents(uri), preferredEncoding);
        }
        else {
            encoding = preferredEncoding !== null && preferredEncoding !== void 0 ? preferredEncoding : encodings_1.UTF8;
        }
        return encoding;
    }
}
exports.WorkspaceMainImpl = WorkspaceMainImpl;
let TextContentResourceResolver = class TextContentResourceResolver {
    constructor() {
        // Resource providers for different schemes
        this.providers = new Map();
        // Opened resources
        this.resources = new Map();
    }
    async resolve(uri) {
        const provider = this.providers.get(uri.scheme);
        if (provider) {
            return provider.provideResource(uri);
        }
        throw new Error(`Unable to find Text Content Resource Provider for scheme '${uri.scheme}'`);
    }
    registerContentProvider(scheme, proxy) {
        if (this.providers.has(scheme)) {
            throw new Error(`Text Content Resource Provider for scheme '${scheme}' is already registered`);
        }
        const instance = this;
        this.providers.set(scheme, {
            provideResource: (uri) => {
                let resource = instance.resources.get(uri.toString());
                if (resource) {
                    return resource;
                }
                resource = new TextContentResource(uri, proxy, {
                    dispose() {
                        instance.resources.delete(uri.toString());
                    }
                });
                instance.resources.set(uri.toString(), resource);
                return resource;
            }
        });
    }
    unregisterContentProvider(scheme) {
        if (!this.providers.delete(scheme)) {
            throw new Error(`Text Content Resource Provider for scheme '${scheme}' has not been registered`);
        }
    }
    onContentChange(uri, content) {
        const resource = this.resources.get(uri);
        if (resource) {
            resource.setContent(content);
        }
    }
};
exports.TextContentResourceResolver = TextContentResourceResolver;
exports.TextContentResourceResolver = TextContentResourceResolver = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], TextContentResourceResolver);
class TextContentResource {
    constructor(uri, proxy, disposable) {
        this.uri = uri;
        this.proxy = proxy;
        this.disposable = disposable;
        this.onDidChangeContentsEmitter = new core_1.Emitter();
        this.onDidChangeContents = this.onDidChangeContentsEmitter.event;
    }
    async readContents(options) {
        if (this.cache) {
            const content = this.cache;
            this.cache = undefined;
            return content;
        }
        else {
            const content = await this.proxy.$provideTextDocumentContent(this.uri.toString());
            return content !== null && content !== void 0 ? content : '';
        }
    }
    dispose() {
        this.disposable.dispose();
    }
    setContent(content) {
        this.cache = content;
        this.onDidChangeContentsEmitter.fire(undefined);
    }
}
exports.TextContentResource = TextContentResource;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/common/basic-message-registry-main.js"
/*!*******************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/common/basic-message-registry-main.js ***!
  \*******************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BasicMessageRegistryMainImpl = void 0;
const message_service_1 = __webpack_require__(/*! @theia/core/lib/common/message-service */ "../../node_modules/@theia/core/lib/common/message-service.js");
const plugin_api_rpc_1 = __webpack_require__(/*! ../../common/plugin-api-rpc */ "../../node_modules/@theia/plugin-ext/lib/common/plugin-api-rpc.js");
/**
 * A basic implementation of the message registry that does not support the modal option
 * as that requires an UI.
 */
class BasicMessageRegistryMainImpl {
    constructor(container) {
        this.messageService = container.get(message_service_1.MessageService);
    }
    async $showMessage(type, message, options, actions) {
        const action = await this.doShowMessage(type, message, options, actions);
        const handle = action
            ? actions.map(a => a.title).indexOf(action)
            : undefined;
        return handle === undefined && options.modal ? options.onCloseActionHandle : handle;
    }
    async doShowMessage(type, message, options, actions) {
        // Modal notifications are not supported in this context
        switch (type) {
            case plugin_api_rpc_1.MainMessageType.Info:
                return this.messageService.info(message, ...actions.map(a => a.title));
            case plugin_api_rpc_1.MainMessageType.Warning:
                return this.messageService.warn(message, ...actions.map(a => a.title));
            case plugin_api_rpc_1.MainMessageType.Error:
                return this.messageService.error(message, ...actions.map(a => a.title));
        }
        throw new Error(`Message type '${type}' is not supported yet!`);
    }
}
exports.BasicMessageRegistryMainImpl = BasicMessageRegistryMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/common/basic-notification-main.js"
/*!***************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/common/basic-notification-main.js ***!
  \***************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BasicNotificationMainImpl = void 0;
const common_1 = __webpack_require__(/*! @theia/core/lib/common */ "../../node_modules/@theia/core/lib/common/index.js");
const disposable_1 = __webpack_require__(/*! @theia/core/lib/common/disposable */ "../../node_modules/@theia/core/lib/common/disposable.js");
class BasicNotificationMainImpl {
    constructor(rpc, container, extIdentifier) {
        this.progressMap = new Map();
        this.progress2Work = new Map();
        this.toDispose = new disposable_1.DisposableCollection(disposable_1.Disposable.create(() => { }));
        this.progressService = container.get(common_1.ProgressService);
        this.proxy = rpc.getProxy(extIdentifier);
    }
    dispose() {
        this.toDispose.dispose();
    }
    async $startProgress(options) {
        const onDidCancel = () => {
            // If the map does not contain current id, it has already stopped and should not be cancelled
            if (this.progressMap.has(id)) {
                this.proxy.$acceptProgressCanceled(id);
            }
        };
        const progressMessage = this.mapOptions(options);
        const progress = await this.progressService.showProgress(progressMessage, onDidCancel);
        const id = progress.id;
        this.progressMap.set(id, progress);
        this.progress2Work.set(id, 0);
        if (this.toDispose.disposed) {
            this.$stopProgress(id);
        }
        else {
            this.toDispose.push(disposable_1.Disposable.create(() => this.$stopProgress(id)));
        }
        return id;
    }
    mapOptions(options) {
        const { title, location, cancellable } = options;
        return { text: title, options: { location, cancelable: cancellable } };
    }
    $stopProgress(id) {
        const progress = this.progressMap.get(id);
        if (progress) {
            this.progressMap.delete(id);
            this.progress2Work.delete(id);
            progress.cancel();
        }
    }
    $updateProgress(id, item) {
        const progress = this.progressMap.get(id);
        if (!progress) {
            return;
        }
        const done = Math.min((this.progress2Work.get(id) || 0) + (item.increment || 0), 100);
        this.progress2Work.set(id, done);
        progress.report({ message: item.message, work: done ? { done, total: 100 } : undefined });
    }
}
exports.BasicNotificationMainImpl = BasicNotificationMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/common/env-main.js"
/*!************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/common/env-main.js ***!
  \************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnvMainImpl = void 0;
const env_variables_1 = __webpack_require__(/*! @theia/core/lib/common/env-variables */ "../../node_modules/@theia/core/lib/common/env-variables/index.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
const types_impl_1 = __webpack_require__(/*! ../../plugin/types-impl */ "../../node_modules/@theia/plugin-ext/lib/plugin/types-impl.js");
class EnvMainImpl {
    constructor(rpc, container) {
        this.envVariableServer = container.get(env_variables_1.EnvVariablesServer);
    }
    $getEnvVariable(envVarName) {
        return this.envVariableServer.getValue(envVarName).then(result => result ? result.value : undefined);
    }
    async $getClientOperatingSystem() {
        if (core_1.isWindows) {
            return types_impl_1.OperatingSystem.Windows;
        }
        if (core_1.isOSX) {
            return types_impl_1.OperatingSystem.OSX;
        }
        return types_impl_1.OperatingSystem.Linux;
    }
}
exports.EnvMainImpl = EnvMainImpl;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/common/plugin-paths-protocol.js"
/*!*************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/common/plugin-paths-protocol.js ***!
  \*************************************************************************************/
(__unused_webpack_module, exports) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PluginPathsService = exports.pluginPathsServicePath = void 0;
exports.pluginPathsServicePath = '/services/plugin-paths';
// Service to create plugin configuration folders for different purpose.
exports.PluginPathsService = Symbol('PluginPathsService');


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/common/webview-preferences.js"
/*!***********************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/common/webview-preferences.js ***!
  \***********************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bindWebviewPreferences = exports.createWebviewPreferences = exports.WebviewPreferences = exports.WebviewPreferenceContribution = exports.WebviewConfigSchema = void 0;
const preferences_1 = __webpack_require__(/*! @theia/core/lib/common/preferences */ "../../node_modules/@theia/core/lib/common/preferences/index.js");
const nls_1 = __webpack_require__(/*! @theia/core/lib/common/nls */ "../../node_modules/@theia/core/lib/common/nls.js");
exports.WebviewConfigSchema = {
    properties: {
        'webview.trace': {
            type: 'string',
            enum: ['off', 'on', 'verbose'],
            description: nls_1.nls.localize('theia/plugin-ext/webviewTrace', 'Controls communication tracing with webviews.'),
            default: 'off'
        }
    }
};
exports.WebviewPreferenceContribution = Symbol('WebviewPreferenceContribution');
exports.WebviewPreferences = Symbol('WebviewPreferences');
function createWebviewPreferences(preferences, schema = exports.WebviewConfigSchema) {
    return (0, preferences_1.createPreferenceProxy)(preferences, schema);
}
exports.createWebviewPreferences = createWebviewPreferences;
function bindWebviewPreferences(bind) {
    bind(exports.WebviewPreferences).toDynamicValue(ctx => {
        const preferences = ctx.container.get(preferences_1.PreferenceService);
        const contribution = ctx.container.get(exports.WebviewPreferenceContribution);
        return createWebviewPreferences(preferences, contribution.schema);
    }).inSingletonScope();
    bind(exports.WebviewPreferenceContribution).toConstantValue({ schema: exports.WebviewConfigSchema });
    bind(preferences_1.PreferenceContribution).toService(exports.WebviewPreferenceContribution);
}
exports.bindWebviewPreferences = bindWebviewPreferences;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/main/common/webview-protocol.js"
/*!********************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/main/common/webview-protocol.js ***!
  \********************************************************************************/
(__unused_webpack_module, exports) {

"use strict";

// *****************************************************************************
// Copyright (C) 2019 TypeFox and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebviewExternalEndpoint = void 0;
/**
 * Each webview should be deployed on a unique origin (https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)
 * to ensure isolation from browser shared state as cookies, local storage and so on.
 *
 * Default hostname pattern of a origin is `{{uuid}}.webview.{{hostname}}`. Where `{{uuid}}` is a placeholder for a webview global id.
 * For electron target the default pattern is always used.
 * For the browser target use `THEIA_WEBVIEW_EXTERNAL_ENDPOINT` env variable to customize it.
 */
var WebviewExternalEndpoint;
(function (WebviewExternalEndpoint) {
    WebviewExternalEndpoint.pattern = 'THEIA_WEBVIEW_EXTERNAL_ENDPOINT';
    WebviewExternalEndpoint.defaultPattern = '{{uuid}}.webview.{{hostname}}';
})(WebviewExternalEndpoint || (exports.WebviewExternalEndpoint = WebviewExternalEndpoint = {}));


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/lib/plugin-ext-frontend-module.js"
/*!******************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/lib/plugin-ext-frontend-module.js ***!
  \******************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2018 Red Hat, Inc. and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const plugin_ext_frontend_module_1 = __webpack_require__(/*! ./main/browser/plugin-ext-frontend-module */ "../../node_modules/@theia/plugin-ext/lib/main/browser/plugin-ext-frontend-module.js");
exports["default"] = plugin_ext_frontend_module_1.default;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/node_modules/mime/Mime.js"
/*!**********************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/node_modules/mime/Mime.js ***!
  \**********************************************************************/
(module) {

"use strict";


/**
 * @param typeMap [Object] Map of MIME type -> Array[extensions]
 * @param ...
 */
function Mime() {
  this._types = Object.create(null);
  this._extensions = Object.create(null);

  for (let i = 0; i < arguments.length; i++) {
    this.define(arguments[i]);
  }

  this.define = this.define.bind(this);
  this.getType = this.getType.bind(this);
  this.getExtension = this.getExtension.bind(this);
}

/**
 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
 * to an array of extensions associated with the type.  The first extension is
 * used as the default extension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
 *
 * If a type declares an extension that has already been defined, an error will
 * be thrown.  To suppress this error and force the extension to be associated
 * with the new type, pass `force`=true.  Alternatively, you may prefix the
 * extension with "*" to map the type to extension, without mapping the
 * extension to the type.
 *
 * e.g. mime.define({'audio/wav', ['wav']}, {'audio/x-wav', ['*wav']});
 *
 *
 * @param map (Object) type definitions
 * @param force (Boolean) if true, force overriding of existing definitions
 */
Mime.prototype.define = function(typeMap, force) {
  for (let type in typeMap) {
    let extensions = typeMap[type].map(function(t) {
      return t.toLowerCase();
    });
    type = type.toLowerCase();

    for (let i = 0; i < extensions.length; i++) {
      const ext = extensions[i];

      // '*' prefix = not the preferred type for this extension.  So fixup the
      // extension, and skip it.
      if (ext[0] === '*') {
        continue;
      }

      if (!force && (ext in this._types)) {
        throw new Error(
          'Attempt to change mapping for "' + ext +
          '" extension from "' + this._types[ext] + '" to "' + type +
          '". Pass `force=true` to allow this, otherwise remove "' + ext +
          '" from the list of extensions for "' + type + '".'
        );
      }

      this._types[ext] = type;
    }

    // Use first extension as default
    if (force || !this._extensions[type]) {
      const ext = extensions[0];
      this._extensions[type] = (ext[0] !== '*') ? ext : ext.substr(1);
    }
  }
};

/**
 * Lookup a mime type based on extension
 */
Mime.prototype.getType = function(path) {
  path = String(path);
  let last = path.replace(/^.*[/\\]/, '').toLowerCase();
  let ext = last.replace(/^.*\./, '').toLowerCase();

  let hasPath = last.length < path.length;
  let hasDot = ext.length < last.length - 1;

  return (hasDot || !hasPath) && this._types[ext] || null;
};

/**
 * Return file extension associated with a mime type
 */
Mime.prototype.getExtension = function(type) {
  type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
  return type && this._extensions[type.toLowerCase()] || null;
};

module.exports = Mime;


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/node_modules/mime/index.js"
/*!***********************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/node_modules/mime/index.js ***!
  \***********************************************************************/
(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


let Mime = __webpack_require__(/*! ./Mime */ "../../node_modules/@theia/plugin-ext/node_modules/mime/Mime.js");
module.exports = new Mime(__webpack_require__(/*! ./types/standard */ "../../node_modules/@theia/plugin-ext/node_modules/mime/types/standard.js"), __webpack_require__(/*! ./types/other */ "../../node_modules/@theia/plugin-ext/node_modules/mime/types/other.js"));


/***/ },

/***/ "../../node_modules/@theia/plugin-ext/node_modules/mime/types/other.js"
/*!*****************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/node_modules/mime/types/other.js ***!
  \*****************************************************************************/
(module) {

module.exports = {"application/prs.cww":["cww"],"application/vnd.1000minds.decision-model+xml":["1km"],"application/vnd.3gpp.pic-bw-large":["plb"],"application/vnd.3gpp.pic-bw-small":["psb"],"application/vnd.3gpp.pic-bw-var":["pvb"],"application/vnd.3gpp2.tcap":["tcap"],"application/vnd.3m.post-it-notes":["pwn"],"application/vnd.accpac.simply.aso":["aso"],"application/vnd.accpac.simply.imp":["imp"],"application/vnd.acucobol":["acu"],"application/vnd.acucorp":["atc","acutc"],"application/vnd.adobe.air-application-installer-package+zip":["air"],"application/vnd.adobe.formscentral.fcdt":["fcdt"],"application/vnd.adobe.fxp":["fxp","fxpl"],"application/vnd.adobe.xdp+xml":["xdp"],"application/vnd.adobe.xfdf":["xfdf"],"application/vnd.ahead.space":["ahead"],"application/vnd.airzip.filesecure.azf":["azf"],"application/vnd.airzip.filesecure.azs":["azs"],"application/vnd.amazon.ebook":["azw"],"application/vnd.americandynamics.acc":["acc"],"application/vnd.amiga.ami":["ami"],"application/vnd.android.package-archive":["apk"],"application/vnd.anser-web-certificate-issue-initiation":["cii"],"application/vnd.anser-web-funds-transfer-initiation":["fti"],"application/vnd.antix.game-component":["atx"],"application/vnd.apple.installer+xml":["mpkg"],"application/vnd.apple.keynote":["key"],"application/vnd.apple.mpegurl":["m3u8"],"application/vnd.apple.numbers":["numbers"],"application/vnd.apple.pages":["pages"],"application/vnd.apple.pkpass":["pkpass"],"application/vnd.aristanetworks.swi":["swi"],"application/vnd.astraea-software.iota":["iota"],"application/vnd.audiograph":["aep"],"application/vnd.balsamiq.bmml+xml":["bmml"],"application/vnd.blueice.multipass":["mpm"],"application/vnd.bmi":["bmi"],"application/vnd.businessobjects":["rep"],"application/vnd.chemdraw+xml":["cdxml"],"application/vnd.chipnuts.karaoke-mmd":["mmd"],"application/vnd.cinderella":["cdy"],"application/vnd.citationstyles.style+xml":["csl"],"application/vnd.claymore":["cla"],"application/vnd.cloanto.rp9":["rp9"],"application/vnd.clonk.c4group":["c4g","c4d","c4f","c4p","c4u"],"application/vnd.cluetrust.cartomobile-config":["c11amc"],"application/vnd.cluetrust.cartomobile-config-pkg":["c11amz"],"application/vnd.commonspace":["csp"],"application/vnd.contact.cmsg":["cdbcmsg"],"application/vnd.cosmocaller":["cmc"],"application/vnd.crick.clicker":["clkx"],"application/vnd.crick.clicker.keyboard":["clkk"],"application/vnd.crick.clicker.palette":["clkp"],"application/vnd.crick.clicker.template":["clkt"],"application/vnd.crick.clicker.wordbank":["clkw"],"application/vnd.criticaltools.wbs+xml":["wbs"],"application/vnd.ctc-posml":["pml"],"application/vnd.cups-ppd":["ppd"],"application/vnd.curl.car":["car"],"application/vnd.curl.pcurl":["pcurl"],"application/vnd.dart":["dart"],"application/vnd.data-vision.rdz":["rdz"],"application/vnd.dbf":["dbf"],"application/vnd.dece.data":["uvf","uvvf","uvd","uvvd"],"application/vnd.dece.ttml+xml":["uvt","uvvt"],"application/vnd.dece.unspecified":["uvx","uvvx"],"application/vnd.dece.zip":["uvz","uvvz"],"application/vnd.denovo.fcselayout-link":["fe_launch"],"application/vnd.dna":["dna"],"application/vnd.dolby.mlp":["mlp"],"application/vnd.dpgraph":["dpg"],"application/vnd.dreamfactory":["dfac"],"application/vnd.ds-keypoint":["kpxx"],"application/vnd.dvb.ait":["ait"],"application/vnd.dvb.service":["svc"],"application/vnd.dynageo":["geo"],"application/vnd.ecowin.chart":["mag"],"application/vnd.enliven":["nml"],"application/vnd.epson.esf":["esf"],"application/vnd.epson.msf":["msf"],"application/vnd.epson.quickanime":["qam"],"application/vnd.epson.salt":["slt"],"application/vnd.epson.ssf":["ssf"],"application/vnd.eszigno3+xml":["es3","et3"],"application/vnd.ezpix-album":["ez2"],"application/vnd.ezpix-package":["ez3"],"application/vnd.fdf":["fdf"],"application/vnd.fdsn.mseed":["mseed"],"application/vnd.fdsn.seed":["seed","dataless"],"application/vnd.flographit":["gph"],"application/vnd.fluxtime.clip":["ftc"],"application/vnd.framemaker":["fm","frame","maker","book"],"application/vnd.frogans.fnc":["fnc"],"application/vnd.frogans.ltf":["ltf"],"application/vnd.fsc.weblaunch":["fsc"],"application/vnd.fujitsu.oasys":["oas"],"application/vnd.fujitsu.oasys2":["oa2"],"application/vnd.fujitsu.oasys3":["oa3"],"application/vnd.fujitsu.oasysgp":["fg5"],"application/vnd.fujitsu.oasysprs":["bh2"],"application/vnd.fujixerox.ddd":["ddd"],"application/vnd.fujixerox.docuworks":["xdw"],"application/vnd.fujixerox.docuworks.binder":["xbd"],"application/vnd.fuzzysheet":["fzs"],"application/vnd.genomatix.tuxedo":["txd"],"application/vnd.geogebra.file":["ggb"],"application/vnd.geogebra.tool":["ggt"],"application/vnd.geometry-explorer":["gex","gre"],"application/vnd.geonext":["gxt"],"application/vnd.geoplan":["g2w"],"application/vnd.geospace":["g3w"],"application/vnd.gmx":["gmx"],"application/vnd.google-apps.document":["gdoc"],"application/vnd.google-apps.presentation":["gslides"],"application/vnd.google-apps.spreadsheet":["gsheet"],"application/vnd.google-earth.kml+xml":["kml"],"application/vnd.google-earth.kmz":["kmz"],"application/vnd.grafeq":["gqf","gqs"],"application/vnd.groove-account":["gac"],"application/vnd.groove-help":["ghf"],"application/vnd.groove-identity-message":["gim"],"application/vnd.groove-injector":["grv"],"application/vnd.groove-tool-message":["gtm"],"application/vnd.groove-tool-template":["tpl"],"application/vnd.groove-vcard":["vcg"],"application/vnd.hal+xml":["hal"],"application/vnd.handheld-entertainment+xml":["zmm"],"application/vnd.hbci":["hbci"],"application/vnd.hhe.lesson-player":["les"],"application/vnd.hp-hpgl":["hpgl"],"application/vnd.hp-hpid":["hpid"],"application/vnd.hp-hps":["hps"],"application/vnd.hp-jlyt":["jlt"],"application/vnd.hp-pcl":["pcl"],"application/vnd.hp-pclxl":["pclxl"],"application/vnd.hydrostatix.sof-data":["sfd-hdstx"],"application/vnd.ibm.minipay":["mpy"],"application/vnd.ibm.modcap":["afp","listafp","list3820"],"application/vnd.ibm.rights-management":["irm"],"application/vnd.ibm.secure-container":["sc"],"application/vnd.iccprofile":["icc","icm"],"application/vnd.igloader":["igl"],"application/vnd.immervision-ivp":["ivp"],"application/vnd.immervision-ivu":["ivu"],"application/vnd.insors.igm":["igm"],"application/vnd.intercon.formnet":["xpw","xpx"],"application/vnd.intergeo":["i2g"],"application/vnd.intu.qbo":["qbo"],"application/vnd.intu.qfx":["qfx"],"application/vnd.ipunplugged.rcprofile":["rcprofile"],"application/vnd.irepository.package+xml":["irp"],"application/vnd.is-xpr":["xpr"],"application/vnd.isac.fcs":["fcs"],"application/vnd.jam":["jam"],"application/vnd.jcp.javame.midlet-rms":["rms"],"application/vnd.jisp":["jisp"],"application/vnd.joost.joda-archive":["joda"],"application/vnd.kahootz":["ktz","ktr"],"application/vnd.kde.karbon":["karbon"],"application/vnd.kde.kchart":["chrt"],"application/vnd.kde.kformula":["kfo"],"application/vnd.kde.kivio":["flw"],"application/vnd.kde.kontour":["kon"],"application/vnd.kde.kpresenter":["kpr","kpt"],"application/vnd.kde.kspread":["ksp"],"application/vnd.kde.kword":["kwd","kwt"],"application/vnd.kenameaapp":["htke"],"application/vnd.kidspiration":["kia"],"application/vnd.kinar":["kne","knp"],"application/vnd.koan":["skp","skd","skt","skm"],"application/vnd.kodak-descriptor":["sse"],"application/vnd.las.las+xml":["lasxml"],"application/vnd.llamagraphics.life-balance.desktop":["lbd"],"application/vnd.llamagraphics.life-balance.exchange+xml":["lbe"],"application/vnd.lotus-1-2-3":["123"],"application/vnd.lotus-approach":["apr"],"application/vnd.lotus-freelance":["pre"],"application/vnd.lotus-notes":["nsf"],"application/vnd.lotus-organizer":["org"],"application/vnd.lotus-screencam":["scm"],"application/vnd.lotus-wordpro":["lwp"],"application/vnd.macports.portpkg":["portpkg"],"application/vnd.mapbox-vector-tile":["mvt"],"application/vnd.mcd":["mcd"],"application/vnd.medcalcdata":["mc1"],"application/vnd.mediastation.cdkey":["cdkey"],"application/vnd.mfer":["mwf"],"application/vnd.mfmp":["mfm"],"application/vnd.micrografx.flo":["flo"],"application/vnd.micrografx.igx":["igx"],"application/vnd.mif":["mif"],"application/vnd.mobius.daf":["daf"],"application/vnd.mobius.dis":["dis"],"application/vnd.mobius.mbk":["mbk"],"application/vnd.mobius.mqy":["mqy"],"application/vnd.mobius.msl":["msl"],"application/vnd.mobius.plc":["plc"],"application/vnd.mobius.txf":["txf"],"application/vnd.mophun.application":["mpn"],"application/vnd.mophun.certificate":["mpc"],"application/vnd.mozilla.xul+xml":["xul"],"application/vnd.ms-artgalry":["cil"],"application/vnd.ms-cab-compressed":["cab"],"application/vnd.ms-excel":["xls","xlm","xla","xlc","xlt","xlw"],"application/vnd.ms-excel.addin.macroenabled.12":["xlam"],"application/vnd.ms-excel.sheet.binary.macroenabled.12":["xlsb"],"application/vnd.ms-excel.sheet.macroenabled.12":["xlsm"],"application/vnd.ms-excel.template.macroenabled.12":["xltm"],"application/vnd.ms-fontobject":["eot"],"application/vnd.ms-htmlhelp":["chm"],"application/vnd.ms-ims":["ims"],"application/vnd.ms-lrm":["lrm"],"application/vnd.ms-officetheme":["thmx"],"application/vnd.ms-outlook":["msg"],"application/vnd.ms-pki.seccat":["cat"],"application/vnd.ms-pki.stl":["*stl"],"application/vnd.ms-powerpoint":["ppt","pps","pot"],"application/vnd.ms-powerpoint.addin.macroenabled.12":["ppam"],"application/vnd.ms-powerpoint.presentation.macroenabled.12":["pptm"],"application/vnd.ms-powerpoint.slide.macroenabled.12":["sldm"],"application/vnd.ms-powerpoint.slideshow.macroenabled.12":["ppsm"],"application/vnd.ms-powerpoint.template.macroenabled.12":["potm"],"application/vnd.ms-project":["mpp","mpt"],"application/vnd.ms-word.document.macroenabled.12":["docm"],"application/vnd.ms-word.template.macroenabled.12":["dotm"],"application/vnd.ms-works":["wps","wks","wcm","wdb"],"application/vnd.ms-wpl":["wpl"],"application/vnd.ms-xpsdocument":["xps"],"application/vnd.mseq":["mseq"],"application/vnd.musician":["mus"],"application/vnd.muvee.style":["msty"],"application/vnd.mynfc":["taglet"],"application/vnd.neurolanguage.nlu":["nlu"],"application/vnd.nitf":["ntf","nitf"],"application/vnd.noblenet-directory":["nnd"],"application/vnd.noblenet-sealer":["nns"],"application/vnd.noblenet-web":["nnw"],"application/vnd.nokia.n-gage.ac+xml":["*ac"],"application/vnd.nokia.n-gage.data":["ngdat"],"application/vnd.nokia.n-gage.symbian.install":["n-gage"],"application/vnd.nokia.radio-preset":["rpst"],"application/vnd.nokia.radio-presets":["rpss"],"application/vnd.novadigm.edm":["edm"],"application/vnd.novadigm.edx":["edx"],"application/vnd.novadigm.ext":["ext"],"application/vnd.oasis.opendocument.chart":["odc"],"application/vnd.oasis.opendocument.chart-template":["otc"],"application/vnd.oasis.opendocument.database":["odb"],"application/vnd.oasis.opendocument.formula":["odf"],"application/vnd.oasis.opendocument.formula-template":["odft"],"application/vnd.oasis.opendocument.graphics":["odg"],"application/vnd.oasis.opendocument.graphics-template":["otg"],"application/vnd.oasis.opendocument.image":["odi"],"application/vnd.oasis.opendocument.image-template":["oti"],"application/vnd.oasis.opendocument.presentation":["odp"],"application/vnd.oasis.opendocument.presentation-template":["otp"],"application/vnd.oasis.opendocument.spreadsheet":["ods"],"application/vnd.oasis.opendocument.spreadsheet-template":["ots"],"application/vnd.oasis.opendocument.text":["odt"],"application/vnd.oasis.opendocument.text-master":["odm"],"application/vnd.oasis.opendocument.text-template":["ott"],"application/vnd.oasis.opendocument.text-web":["oth"],"application/vnd.olpc-sugar":["xo"],"application/vnd.oma.dd2+xml":["dd2"],"application/vnd.openblox.game+xml":["obgx"],"application/vnd.openofficeorg.extension":["oxt"],"application/vnd.openstreetmap.data+xml":["osm"],"application/vnd.openxmlformats-officedocument.presentationml.presentation":["pptx"],"application/vnd.openxmlformats-officedocument.presentationml.slide":["sldx"],"application/vnd.openxmlformats-officedocument.presentationml.slideshow":["ppsx"],"application/vnd.openxmlformats-officedocument.presentationml.template":["potx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":["xlsx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.template":["xltx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.document":["docx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.template":["dotx"],"application/vnd.osgeo.mapguide.package":["mgp"],"application/vnd.osgi.dp":["dp"],"application/vnd.osgi.subsystem":["esa"],"application/vnd.palm":["pdb","pqa","oprc"],"application/vnd.pawaafile":["paw"],"application/vnd.pg.format":["str"],"application/vnd.pg.osasli":["ei6"],"application/vnd.picsel":["efif"],"application/vnd.pmi.widget":["wg"],"application/vnd.pocketlearn":["plf"],"application/vnd.powerbuilder6":["pbd"],"application/vnd.previewsystems.box":["box"],"application/vnd.proteus.magazine":["mgz"],"application/vnd.publishare-delta-tree":["qps"],"application/vnd.pvi.ptid1":["ptid"],"application/vnd.quark.quarkxpress":["qxd","qxt","qwd","qwt","qxl","qxb"],"application/vnd.rar":["rar"],"application/vnd.realvnc.bed":["bed"],"application/vnd.recordare.musicxml":["mxl"],"application/vnd.recordare.musicxml+xml":["musicxml"],"application/vnd.rig.cryptonote":["cryptonote"],"application/vnd.rim.cod":["cod"],"application/vnd.rn-realmedia":["rm"],"application/vnd.rn-realmedia-vbr":["rmvb"],"application/vnd.route66.link66+xml":["link66"],"application/vnd.sailingtracker.track":["st"],"application/vnd.seemail":["see"],"application/vnd.sema":["sema"],"application/vnd.semd":["semd"],"application/vnd.semf":["semf"],"application/vnd.shana.informed.formdata":["ifm"],"application/vnd.shana.informed.formtemplate":["itp"],"application/vnd.shana.informed.interchange":["iif"],"application/vnd.shana.informed.package":["ipk"],"application/vnd.simtech-mindmapper":["twd","twds"],"application/vnd.smaf":["mmf"],"application/vnd.smart.teacher":["teacher"],"application/vnd.software602.filler.form+xml":["fo"],"application/vnd.solent.sdkm+xml":["sdkm","sdkd"],"application/vnd.spotfire.dxp":["dxp"],"application/vnd.spotfire.sfs":["sfs"],"application/vnd.stardivision.calc":["sdc"],"application/vnd.stardivision.draw":["sda"],"application/vnd.stardivision.impress":["sdd"],"application/vnd.stardivision.math":["smf"],"application/vnd.stardivision.writer":["sdw","vor"],"application/vnd.stardivision.writer-global":["sgl"],"application/vnd.stepmania.package":["smzip"],"application/vnd.stepmania.stepchart":["sm"],"application/vnd.sun.wadl+xml":["wadl"],"application/vnd.sun.xml.calc":["sxc"],"application/vnd.sun.xml.calc.template":["stc"],"application/vnd.sun.xml.draw":["sxd"],"application/vnd.sun.xml.draw.template":["std"],"application/vnd.sun.xml.impress":["sxi"],"application/vnd.sun.xml.impress.template":["sti"],"application/vnd.sun.xml.math":["sxm"],"application/vnd.sun.xml.writer":["sxw"],"application/vnd.sun.xml.writer.global":["sxg"],"application/vnd.sun.xml.writer.template":["stw"],"application/vnd.sus-calendar":["sus","susp"],"application/vnd.svd":["svd"],"application/vnd.symbian.install":["sis","sisx"],"application/vnd.syncml+xml":["xsm"],"application/vnd.syncml.dm+wbxml":["bdm"],"application/vnd.syncml.dm+xml":["xdm"],"application/vnd.syncml.dmddf+xml":["ddf"],"application/vnd.tao.intent-module-archive":["tao"],"application/vnd.tcpdump.pcap":["pcap","cap","dmp"],"application/vnd.tmobile-livetv":["tmo"],"application/vnd.trid.tpt":["tpt"],"application/vnd.triscape.mxs":["mxs"],"application/vnd.trueapp":["tra"],"application/vnd.ufdl":["ufd","ufdl"],"application/vnd.uiq.theme":["utz"],"application/vnd.umajin":["umj"],"application/vnd.unity":["unityweb"],"application/vnd.uoml+xml":["uoml"],"application/vnd.vcx":["vcx"],"application/vnd.visio":["vsd","vst","vss","vsw"],"application/vnd.visionary":["vis"],"application/vnd.vsf":["vsf"],"application/vnd.wap.wbxml":["wbxml"],"application/vnd.wap.wmlc":["wmlc"],"application/vnd.wap.wmlscriptc":["wmlsc"],"application/vnd.webturbo":["wtb"],"application/vnd.wolfram.player":["nbp"],"application/vnd.wordperfect":["wpd"],"application/vnd.wqd":["wqd"],"application/vnd.wt.stf":["stf"],"application/vnd.xara":["xar"],"application/vnd.xfdl":["xfdl"],"application/vnd.yamaha.hv-dic":["hvd"],"application/vnd.yamaha.hv-script":["hvs"],"application/vnd.yamaha.hv-voice":["hvp"],"application/vnd.yamaha.openscoreformat":["osf"],"application/vnd.yamaha.openscoreformat.osfpvg+xml":["osfpvg"],"application/vnd.yamaha.smaf-audio":["saf"],"application/vnd.yamaha.smaf-phrase":["spf"],"application/vnd.yellowriver-custom-menu":["cmp"],"application/vnd.zul":["zir","zirz"],"application/vnd.zzazz.deck+xml":["zaz"],"application/x-7z-compressed":["7z"],"application/x-abiword":["abw"],"application/x-ace-compressed":["ace"],"application/x-apple-diskimage":["*dmg"],"application/x-arj":["arj"],"application/x-authorware-bin":["aab","x32","u32","vox"],"application/x-authorware-map":["aam"],"application/x-authorware-seg":["aas"],"application/x-bcpio":["bcpio"],"application/x-bdoc":["*bdoc"],"application/x-bittorrent":["torrent"],"application/x-blorb":["blb","blorb"],"application/x-bzip":["bz"],"application/x-bzip2":["bz2","boz"],"application/x-cbr":["cbr","cba","cbt","cbz","cb7"],"application/x-cdlink":["vcd"],"application/x-cfs-compressed":["cfs"],"application/x-chat":["chat"],"application/x-chess-pgn":["pgn"],"application/x-chrome-extension":["crx"],"application/x-cocoa":["cco"],"application/x-conference":["nsc"],"application/x-cpio":["cpio"],"application/x-csh":["csh"],"application/x-debian-package":["*deb","udeb"],"application/x-dgc-compressed":["dgc"],"application/x-director":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"],"application/x-doom":["wad"],"application/x-dtbncx+xml":["ncx"],"application/x-dtbook+xml":["dtb"],"application/x-dtbresource+xml":["res"],"application/x-dvi":["dvi"],"application/x-envoy":["evy"],"application/x-eva":["eva"],"application/x-font-bdf":["bdf"],"application/x-font-ghostscript":["gsf"],"application/x-font-linux-psf":["psf"],"application/x-font-pcf":["pcf"],"application/x-font-snf":["snf"],"application/x-font-type1":["pfa","pfb","pfm","afm"],"application/x-freearc":["arc"],"application/x-futuresplash":["spl"],"application/x-gca-compressed":["gca"],"application/x-glulx":["ulx"],"application/x-gnumeric":["gnumeric"],"application/x-gramps-xml":["gramps"],"application/x-gtar":["gtar"],"application/x-hdf":["hdf"],"application/x-httpd-php":["php"],"application/x-install-instructions":["install"],"application/x-iso9660-image":["*iso"],"application/x-iwork-keynote-sffkey":["*key"],"application/x-iwork-numbers-sffnumbers":["*numbers"],"application/x-iwork-pages-sffpages":["*pages"],"application/x-java-archive-diff":["jardiff"],"application/x-java-jnlp-file":["jnlp"],"application/x-keepass2":["kdbx"],"application/x-latex":["latex"],"application/x-lua-bytecode":["luac"],"application/x-lzh-compressed":["lzh","lha"],"application/x-makeself":["run"],"application/x-mie":["mie"],"application/x-mobipocket-ebook":["prc","mobi"],"application/x-ms-application":["application"],"application/x-ms-shortcut":["lnk"],"application/x-ms-wmd":["wmd"],"application/x-ms-wmz":["wmz"],"application/x-ms-xbap":["xbap"],"application/x-msaccess":["mdb"],"application/x-msbinder":["obd"],"application/x-mscardfile":["crd"],"application/x-msclip":["clp"],"application/x-msdos-program":["*exe"],"application/x-msdownload":["*exe","*dll","com","bat","*msi"],"application/x-msmediaview":["mvb","m13","m14"],"application/x-msmetafile":["*wmf","*wmz","*emf","emz"],"application/x-msmoney":["mny"],"application/x-mspublisher":["pub"],"application/x-msschedule":["scd"],"application/x-msterminal":["trm"],"application/x-mswrite":["wri"],"application/x-netcdf":["nc","cdf"],"application/x-ns-proxy-autoconfig":["pac"],"application/x-nzb":["nzb"],"application/x-perl":["pl","pm"],"application/x-pilot":["*prc","*pdb"],"application/x-pkcs12":["p12","pfx"],"application/x-pkcs7-certificates":["p7b","spc"],"application/x-pkcs7-certreqresp":["p7r"],"application/x-rar-compressed":["*rar"],"application/x-redhat-package-manager":["rpm"],"application/x-research-info-systems":["ris"],"application/x-sea":["sea"],"application/x-sh":["sh"],"application/x-shar":["shar"],"application/x-shockwave-flash":["swf"],"application/x-silverlight-app":["xap"],"application/x-sql":["sql"],"application/x-stuffit":["sit"],"application/x-stuffitx":["sitx"],"application/x-subrip":["srt"],"application/x-sv4cpio":["sv4cpio"],"application/x-sv4crc":["sv4crc"],"application/x-t3vm-image":["t3"],"application/x-tads":["gam"],"application/x-tar":["tar"],"application/x-tcl":["tcl","tk"],"application/x-tex":["tex"],"application/x-tex-tfm":["tfm"],"application/x-texinfo":["texinfo","texi"],"application/x-tgif":["*obj"],"application/x-ustar":["ustar"],"application/x-virtualbox-hdd":["hdd"],"application/x-virtualbox-ova":["ova"],"application/x-virtualbox-ovf":["ovf"],"application/x-virtualbox-vbox":["vbox"],"application/x-virtualbox-vbox-extpack":["vbox-extpack"],"application/x-virtualbox-vdi":["vdi"],"application/x-virtualbox-vhd":["vhd"],"application/x-virtualbox-vmdk":["vmdk"],"application/x-wais-source":["src"],"application/x-web-app-manifest+json":["webapp"],"application/x-x509-ca-cert":["der","crt","pem"],"application/x-xfig":["fig"],"application/x-xliff+xml":["*xlf"],"application/x-xpinstall":["xpi"],"application/x-xz":["xz"],"application/x-zmachine":["z1","z2","z3","z4","z5","z6","z7","z8"],"audio/vnd.dece.audio":["uva","uvva"],"audio/vnd.digital-winds":["eol"],"audio/vnd.dra":["dra"],"audio/vnd.dts":["dts"],"audio/vnd.dts.hd":["dtshd"],"audio/vnd.lucent.voice":["lvp"],"audio/vnd.ms-playready.media.pya":["pya"],"audio/vnd.nuera.ecelp4800":["ecelp4800"],"audio/vnd.nuera.ecelp7470":["ecelp7470"],"audio/vnd.nuera.ecelp9600":["ecelp9600"],"audio/vnd.rip":["rip"],"audio/x-aac":["aac"],"audio/x-aiff":["aif","aiff","aifc"],"audio/x-caf":["caf"],"audio/x-flac":["flac"],"audio/x-m4a":["*m4a"],"audio/x-matroska":["mka"],"audio/x-mpegurl":["m3u"],"audio/x-ms-wax":["wax"],"audio/x-ms-wma":["wma"],"audio/x-pn-realaudio":["ram","ra"],"audio/x-pn-realaudio-plugin":["rmp"],"audio/x-realaudio":["*ra"],"audio/x-wav":["*wav"],"chemical/x-cdx":["cdx"],"chemical/x-cif":["cif"],"chemical/x-cmdf":["cmdf"],"chemical/x-cml":["cml"],"chemical/x-csml":["csml"],"chemical/x-xyz":["xyz"],"image/prs.btif":["btif"],"image/prs.pti":["pti"],"image/vnd.adobe.photoshop":["psd"],"image/vnd.airzip.accelerator.azv":["azv"],"image/vnd.dece.graphic":["uvi","uvvi","uvg","uvvg"],"image/vnd.djvu":["djvu","djv"],"image/vnd.dvb.subtitle":["*sub"],"image/vnd.dwg":["dwg"],"image/vnd.dxf":["dxf"],"image/vnd.fastbidsheet":["fbs"],"image/vnd.fpx":["fpx"],"image/vnd.fst":["fst"],"image/vnd.fujixerox.edmics-mmr":["mmr"],"image/vnd.fujixerox.edmics-rlc":["rlc"],"image/vnd.microsoft.icon":["ico"],"image/vnd.ms-dds":["dds"],"image/vnd.ms-modi":["mdi"],"image/vnd.ms-photo":["wdp"],"image/vnd.net-fpx":["npx"],"image/vnd.pco.b16":["b16"],"image/vnd.tencent.tap":["tap"],"image/vnd.valve.source.texture":["vtf"],"image/vnd.wap.wbmp":["wbmp"],"image/vnd.xiff":["xif"],"image/vnd.zbrush.pcx":["pcx"],"image/x-3ds":["3ds"],"image/x-cmu-raster":["ras"],"image/x-cmx":["cmx"],"image/x-freehand":["fh","fhc","fh4","fh5","fh7"],"image/x-icon":["*ico"],"image/x-jng":["jng"],"image/x-mrsid-image":["sid"],"image/x-ms-bmp":["*bmp"],"image/x-pcx":["*pcx"],"image/x-pict":["pic","pct"],"image/x-portable-anymap":["pnm"],"image/x-portable-bitmap":["pbm"],"image/x-portable-graymap":["pgm"],"image/x-portable-pixmap":["ppm"],"image/x-rgb":["rgb"],"image/x-tga":["tga"],"image/x-xbitmap":["xbm"],"image/x-xpixmap":["xpm"],"image/x-xwindowdump":["xwd"],"message/vnd.wfa.wsc":["wsc"],"model/vnd.collada+xml":["dae"],"model/vnd.dwf":["dwf"],"model/vnd.gdl":["gdl"],"model/vnd.gtw":["gtw"],"model/vnd.mts":["mts"],"model/vnd.opengex":["ogex"],"model/vnd.parasolid.transmit.binary":["x_b"],"model/vnd.parasolid.transmit.text":["x_t"],"model/vnd.sap.vds":["vds"],"model/vnd.usdz+zip":["usdz"],"model/vnd.valve.source.compiled-map":["bsp"],"model/vnd.vtu":["vtu"],"text/prs.lines.tag":["dsc"],"text/vnd.curl":["curl"],"text/vnd.curl.dcurl":["dcurl"],"text/vnd.curl.mcurl":["mcurl"],"text/vnd.curl.scurl":["scurl"],"text/vnd.dvb.subtitle":["sub"],"text/vnd.fly":["fly"],"text/vnd.fmi.flexstor":["flx"],"text/vnd.graphviz":["gv"],"text/vnd.in3d.3dml":["3dml"],"text/vnd.in3d.spot":["spot"],"text/vnd.sun.j2me.app-descriptor":["jad"],"text/vnd.wap.wml":["wml"],"text/vnd.wap.wmlscript":["wmls"],"text/x-asm":["s","asm"],"text/x-c":["c","cc","cxx","cpp","h","hh","dic"],"text/x-component":["htc"],"text/x-fortran":["f","for","f77","f90"],"text/x-handlebars-template":["hbs"],"text/x-java-source":["java"],"text/x-lua":["lua"],"text/x-markdown":["mkd"],"text/x-nfo":["nfo"],"text/x-opml":["opml"],"text/x-org":["*org"],"text/x-pascal":["p","pas"],"text/x-processing":["pde"],"text/x-sass":["sass"],"text/x-scss":["scss"],"text/x-setext":["etx"],"text/x-sfv":["sfv"],"text/x-suse-ymp":["ymp"],"text/x-uuencode":["uu"],"text/x-vcalendar":["vcs"],"text/x-vcard":["vcf"],"video/vnd.dece.hd":["uvh","uvvh"],"video/vnd.dece.mobile":["uvm","uvvm"],"video/vnd.dece.pd":["uvp","uvvp"],"video/vnd.dece.sd":["uvs","uvvs"],"video/vnd.dece.video":["uvv","uvvv"],"video/vnd.dvb.file":["dvb"],"video/vnd.fvt":["fvt"],"video/vnd.mpegurl":["mxu","m4u"],"video/vnd.ms-playready.media.pyv":["pyv"],"video/vnd.uvvu.mp4":["uvu","uvvu"],"video/vnd.vivo":["viv"],"video/x-f4v":["f4v"],"video/x-fli":["fli"],"video/x-flv":["flv"],"video/x-m4v":["m4v"],"video/x-matroska":["mkv","mk3d","mks"],"video/x-mng":["mng"],"video/x-ms-asf":["asf","asx"],"video/x-ms-vob":["vob"],"video/x-ms-wm":["wm"],"video/x-ms-wmv":["wmv"],"video/x-ms-wmx":["wmx"],"video/x-ms-wvx":["wvx"],"video/x-msvideo":["avi"],"video/x-sgi-movie":["movie"],"video/x-smv":["smv"],"x-conference/x-cooltalk":["ice"]};

/***/ },

/***/ "../../node_modules/@theia/plugin-ext/node_modules/mime/types/standard.js"
/*!********************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/node_modules/mime/types/standard.js ***!
  \********************************************************************************/
(module) {

module.exports = {"application/andrew-inset":["ez"],"application/applixware":["aw"],"application/atom+xml":["atom"],"application/atomcat+xml":["atomcat"],"application/atomdeleted+xml":["atomdeleted"],"application/atomsvc+xml":["atomsvc"],"application/atsc-dwd+xml":["dwd"],"application/atsc-held+xml":["held"],"application/atsc-rsat+xml":["rsat"],"application/bdoc":["bdoc"],"application/calendar+xml":["xcs"],"application/ccxml+xml":["ccxml"],"application/cdfx+xml":["cdfx"],"application/cdmi-capability":["cdmia"],"application/cdmi-container":["cdmic"],"application/cdmi-domain":["cdmid"],"application/cdmi-object":["cdmio"],"application/cdmi-queue":["cdmiq"],"application/cu-seeme":["cu"],"application/dash+xml":["mpd"],"application/davmount+xml":["davmount"],"application/docbook+xml":["dbk"],"application/dssc+der":["dssc"],"application/dssc+xml":["xdssc"],"application/ecmascript":["es","ecma"],"application/emma+xml":["emma"],"application/emotionml+xml":["emotionml"],"application/epub+zip":["epub"],"application/exi":["exi"],"application/express":["exp"],"application/fdt+xml":["fdt"],"application/font-tdpfr":["pfr"],"application/geo+json":["geojson"],"application/gml+xml":["gml"],"application/gpx+xml":["gpx"],"application/gxf":["gxf"],"application/gzip":["gz"],"application/hjson":["hjson"],"application/hyperstudio":["stk"],"application/inkml+xml":["ink","inkml"],"application/ipfix":["ipfix"],"application/its+xml":["its"],"application/java-archive":["jar","war","ear"],"application/java-serialized-object":["ser"],"application/java-vm":["class"],"application/javascript":["js","mjs"],"application/json":["json","map"],"application/json5":["json5"],"application/jsonml+json":["jsonml"],"application/ld+json":["jsonld"],"application/lgr+xml":["lgr"],"application/lost+xml":["lostxml"],"application/mac-binhex40":["hqx"],"application/mac-compactpro":["cpt"],"application/mads+xml":["mads"],"application/manifest+json":["webmanifest"],"application/marc":["mrc"],"application/marcxml+xml":["mrcx"],"application/mathematica":["ma","nb","mb"],"application/mathml+xml":["mathml"],"application/mbox":["mbox"],"application/mediaservercontrol+xml":["mscml"],"application/metalink+xml":["metalink"],"application/metalink4+xml":["meta4"],"application/mets+xml":["mets"],"application/mmt-aei+xml":["maei"],"application/mmt-usd+xml":["musd"],"application/mods+xml":["mods"],"application/mp21":["m21","mp21"],"application/mp4":["mp4s","m4p"],"application/msword":["doc","dot"],"application/mxf":["mxf"],"application/n-quads":["nq"],"application/n-triples":["nt"],"application/node":["cjs"],"application/octet-stream":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"],"application/oda":["oda"],"application/oebps-package+xml":["opf"],"application/ogg":["ogx"],"application/omdoc+xml":["omdoc"],"application/onenote":["onetoc","onetoc2","onetmp","onepkg"],"application/oxps":["oxps"],"application/p2p-overlay+xml":["relo"],"application/patch-ops-error+xml":["xer"],"application/pdf":["pdf"],"application/pgp-encrypted":["pgp"],"application/pgp-signature":["asc","sig"],"application/pics-rules":["prf"],"application/pkcs10":["p10"],"application/pkcs7-mime":["p7m","p7c"],"application/pkcs7-signature":["p7s"],"application/pkcs8":["p8"],"application/pkix-attr-cert":["ac"],"application/pkix-cert":["cer"],"application/pkix-crl":["crl"],"application/pkix-pkipath":["pkipath"],"application/pkixcmp":["pki"],"application/pls+xml":["pls"],"application/postscript":["ai","eps","ps"],"application/provenance+xml":["provx"],"application/pskc+xml":["pskcxml"],"application/raml+yaml":["raml"],"application/rdf+xml":["rdf","owl"],"application/reginfo+xml":["rif"],"application/relax-ng-compact-syntax":["rnc"],"application/resource-lists+xml":["rl"],"application/resource-lists-diff+xml":["rld"],"application/rls-services+xml":["rs"],"application/route-apd+xml":["rapd"],"application/route-s-tsid+xml":["sls"],"application/route-usd+xml":["rusd"],"application/rpki-ghostbusters":["gbr"],"application/rpki-manifest":["mft"],"application/rpki-roa":["roa"],"application/rsd+xml":["rsd"],"application/rss+xml":["rss"],"application/rtf":["rtf"],"application/sbml+xml":["sbml"],"application/scvp-cv-request":["scq"],"application/scvp-cv-response":["scs"],"application/scvp-vp-request":["spq"],"application/scvp-vp-response":["spp"],"application/sdp":["sdp"],"application/senml+xml":["senmlx"],"application/sensml+xml":["sensmlx"],"application/set-payment-initiation":["setpay"],"application/set-registration-initiation":["setreg"],"application/shf+xml":["shf"],"application/sieve":["siv","sieve"],"application/smil+xml":["smi","smil"],"application/sparql-query":["rq"],"application/sparql-results+xml":["srx"],"application/srgs":["gram"],"application/srgs+xml":["grxml"],"application/sru+xml":["sru"],"application/ssdl+xml":["ssdl"],"application/ssml+xml":["ssml"],"application/swid+xml":["swidtag"],"application/tei+xml":["tei","teicorpus"],"application/thraud+xml":["tfi"],"application/timestamped-data":["tsd"],"application/toml":["toml"],"application/trig":["trig"],"application/ttml+xml":["ttml"],"application/ubjson":["ubj"],"application/urc-ressheet+xml":["rsheet"],"application/urc-targetdesc+xml":["td"],"application/voicexml+xml":["vxml"],"application/wasm":["wasm"],"application/widget":["wgt"],"application/winhlp":["hlp"],"application/wsdl+xml":["wsdl"],"application/wspolicy+xml":["wspolicy"],"application/xaml+xml":["xaml"],"application/xcap-att+xml":["xav"],"application/xcap-caps+xml":["xca"],"application/xcap-diff+xml":["xdf"],"application/xcap-el+xml":["xel"],"application/xcap-ns+xml":["xns"],"application/xenc+xml":["xenc"],"application/xhtml+xml":["xhtml","xht"],"application/xliff+xml":["xlf"],"application/xml":["xml","xsl","xsd","rng"],"application/xml-dtd":["dtd"],"application/xop+xml":["xop"],"application/xproc+xml":["xpl"],"application/xslt+xml":["*xsl","xslt"],"application/xspf+xml":["xspf"],"application/xv+xml":["mxml","xhvml","xvml","xvm"],"application/yang":["yang"],"application/yin+xml":["yin"],"application/zip":["zip"],"audio/3gpp":["*3gpp"],"audio/adpcm":["adp"],"audio/amr":["amr"],"audio/basic":["au","snd"],"audio/midi":["mid","midi","kar","rmi"],"audio/mobile-xmf":["mxmf"],"audio/mp3":["*mp3"],"audio/mp4":["m4a","mp4a"],"audio/mpeg":["mpga","mp2","mp2a","mp3","m2a","m3a"],"audio/ogg":["oga","ogg","spx","opus"],"audio/s3m":["s3m"],"audio/silk":["sil"],"audio/wav":["wav"],"audio/wave":["*wav"],"audio/webm":["weba"],"audio/xm":["xm"],"font/collection":["ttc"],"font/otf":["otf"],"font/ttf":["ttf"],"font/woff":["woff"],"font/woff2":["woff2"],"image/aces":["exr"],"image/apng":["apng"],"image/avif":["avif"],"image/bmp":["bmp"],"image/cgm":["cgm"],"image/dicom-rle":["drle"],"image/emf":["emf"],"image/fits":["fits"],"image/g3fax":["g3"],"image/gif":["gif"],"image/heic":["heic"],"image/heic-sequence":["heics"],"image/heif":["heif"],"image/heif-sequence":["heifs"],"image/hej2k":["hej2"],"image/hsj2":["hsj2"],"image/ief":["ief"],"image/jls":["jls"],"image/jp2":["jp2","jpg2"],"image/jpeg":["jpeg","jpg","jpe"],"image/jph":["jph"],"image/jphc":["jhc"],"image/jpm":["jpm"],"image/jpx":["jpx","jpf"],"image/jxr":["jxr"],"image/jxra":["jxra"],"image/jxrs":["jxrs"],"image/jxs":["jxs"],"image/jxsc":["jxsc"],"image/jxsi":["jxsi"],"image/jxss":["jxss"],"image/ktx":["ktx"],"image/ktx2":["ktx2"],"image/png":["png"],"image/sgi":["sgi"],"image/svg+xml":["svg","svgz"],"image/t38":["t38"],"image/tiff":["tif","tiff"],"image/tiff-fx":["tfx"],"image/webp":["webp"],"image/wmf":["wmf"],"message/disposition-notification":["disposition-notification"],"message/global":["u8msg"],"message/global-delivery-status":["u8dsn"],"message/global-disposition-notification":["u8mdn"],"message/global-headers":["u8hdr"],"message/rfc822":["eml","mime"],"model/3mf":["3mf"],"model/gltf+json":["gltf"],"model/gltf-binary":["glb"],"model/iges":["igs","iges"],"model/mesh":["msh","mesh","silo"],"model/mtl":["mtl"],"model/obj":["obj"],"model/step+xml":["stpx"],"model/step+zip":["stpz"],"model/step-xml+zip":["stpxz"],"model/stl":["stl"],"model/vrml":["wrl","vrml"],"model/x3d+binary":["*x3db","x3dbz"],"model/x3d+fastinfoset":["x3db"],"model/x3d+vrml":["*x3dv","x3dvz"],"model/x3d+xml":["x3d","x3dz"],"model/x3d-vrml":["x3dv"],"text/cache-manifest":["appcache","manifest"],"text/calendar":["ics","ifb"],"text/coffeescript":["coffee","litcoffee"],"text/css":["css"],"text/csv":["csv"],"text/html":["html","htm","shtml"],"text/jade":["jade"],"text/jsx":["jsx"],"text/less":["less"],"text/markdown":["markdown","md"],"text/mathml":["mml"],"text/mdx":["mdx"],"text/n3":["n3"],"text/plain":["txt","text","conf","def","list","log","in","ini"],"text/richtext":["rtx"],"text/rtf":["*rtf"],"text/sgml":["sgml","sgm"],"text/shex":["shex"],"text/slim":["slim","slm"],"text/spdx":["spdx"],"text/stylus":["stylus","styl"],"text/tab-separated-values":["tsv"],"text/troff":["t","tr","roff","man","me","ms"],"text/turtle":["ttl"],"text/uri-list":["uri","uris","urls"],"text/vcard":["vcard"],"text/vtt":["vtt"],"text/xml":["*xml"],"text/yaml":["yaml","yml"],"video/3gpp":["3gp","3gpp"],"video/3gpp2":["3g2"],"video/h261":["h261"],"video/h263":["h263"],"video/h264":["h264"],"video/iso.segment":["m4s"],"video/jpeg":["jpgv"],"video/jpm":["*jpm","jpgm"],"video/mj2":["mj2","mjp2"],"video/mp2t":["ts"],"video/mp4":["mp4","mp4v","mpg4"],"video/mpeg":["mpeg","mpg","mpe","m1v","m2v"],"video/ogg":["ogv"],"video/quicktime":["qt","mov"],"video/webm":["webm"]};

/***/ },

/***/ "../../node_modules/@theia/plugin-ext/src/main/browser/dialogs/style/modal-notification.css"
/*!**************************************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/src/main/browser/dialogs/style/modal-notification.css ***!
  \**************************************************************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_cjs_js_modal_notification_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../../../../../css-loader/dist/cjs.js!./modal-notification.css */ "../../node_modules/css-loader/dist/cjs.js!../../node_modules/@theia/plugin-ext/src/main/browser/dialogs/style/modal-notification.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_modal_notification_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_modal_notification_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ },

/***/ "../../node_modules/@theia/plugin-ext/src/main/browser/style/comments.css"
/*!********************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/src/main/browser/style/comments.css ***!
  \********************************************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_cjs_js_comments_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../../../../css-loader/dist/cjs.js!./comments.css */ "../../node_modules/css-loader/dist/cjs.js!../../node_modules/@theia/plugin-ext/src/main/browser/style/comments.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_comments_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_comments_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ },

/***/ "../../node_modules/@theia/plugin-ext/src/main/browser/style/index.css"
/*!*****************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/src/main/browser/style/index.css ***!
  \*****************************************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../../../../css-loader/dist/cjs.js!./index.css */ "../../node_modules/css-loader/dist/cjs.js!../../node_modules/@theia/plugin-ext/src/main/browser/style/index.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ },

/***/ "../../node_modules/@theia/plugin-ext/src/main/style/status-bar.css"
/*!**************************************************************************!*\
  !*** ../../node_modules/@theia/plugin-ext/src/main/style/status-bar.css ***!
  \**************************************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_cjs_js_status_bar_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../../../css-loader/dist/cjs.js!./status-bar.css */ "../../node_modules/css-loader/dist/cjs.js!../../node_modules/@theia/plugin-ext/src/main/style/status-bar.css");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_status_bar_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_status_bar_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ },

/***/ "../../node_modules/@theia/task/lib/browser/index.js"
/*!***********************************************************!*\
  !*** ../../node_modules/@theia/task/lib/browser/index.js ***!
  \***********************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2017 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
tslib_1.__exportStar(__webpack_require__(/*! ./task-service */ "../../node_modules/@theia/task/lib/browser/task-service.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./task-contribution */ "../../node_modules/@theia/task/lib/browser/task-contribution.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./task-definition-registry */ "../../node_modules/@theia/task/lib/browser/task-definition-registry.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./task-problem-matcher-registry */ "../../node_modules/@theia/task/lib/browser/task-problem-matcher-registry.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./task-problem-pattern-registry */ "../../node_modules/@theia/task/lib/browser/task-problem-pattern-registry.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./task-schema-updater */ "../../node_modules/@theia/task/lib/browser/task-schema-updater.js"), exports);


/***/ },

/***/ "../../node_modules/@theia/typehierarchy/lib/browser/index.js"
/*!********************************************************************!*\
  !*** ../../node_modules/@theia/typehierarchy/lib/browser/index.js ***!
  \********************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
tslib_1.__exportStar(__webpack_require__(/*! ./typehierarchy */ "../../node_modules/@theia/typehierarchy/lib/browser/typehierarchy.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./typehierarchy-contribution */ "../../node_modules/@theia/typehierarchy/lib/browser/typehierarchy-contribution.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./typehierarchy-frontend-module */ "../../node_modules/@theia/typehierarchy/lib/browser/typehierarchy-frontend-module.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./typehierarchy-service */ "../../node_modules/@theia/typehierarchy/lib/browser/typehierarchy-service.js"), exports);


/***/ },

/***/ "../../node_modules/@theia/typehierarchy/lib/browser/typehierarchy.js"
/*!****************************************************************************!*\
  !*** ../../node_modules/@theia/typehierarchy/lib/browser/typehierarchy.js ***!
  \****************************************************************************/
(__unused_webpack_module, exports) {

"use strict";

// *****************************************************************************
// Copyright (C) 2022 Ericsson and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ },

/***/ "../../node_modules/async-mutex/lib/Mutex.js"
/*!***************************************************!*\
  !*** ../../node_modules/async-mutex/lib/Mutex.js ***!
  \***************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
var Semaphore_1 = __webpack_require__(/*! ./Semaphore */ "../../node_modules/async-mutex/lib/Semaphore.js");
var Mutex = /** @class */ (function () {
    function Mutex(cancelError) {
        this._semaphore = new Semaphore_1.default(1, cancelError);
    }
    Mutex.prototype.acquire = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, releaser;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._semaphore.acquire()];
                    case 1:
                        _a = _b.sent(), releaser = _a[1];
                        return [2 /*return*/, releaser];
                }
            });
        });
    };
    Mutex.prototype.runExclusive = function (callback) {
        return this._semaphore.runExclusive(function () { return callback(); });
    };
    Mutex.prototype.isLocked = function () {
        return this._semaphore.isLocked();
    };
    Mutex.prototype.waitForUnlock = function () {
        return this._semaphore.waitForUnlock();
    };
    Mutex.prototype.release = function () {
        if (this._semaphore.isLocked())
            this._semaphore.release();
    };
    Mutex.prototype.cancel = function () {
        return this._semaphore.cancel();
    };
    return Mutex;
}());
exports["default"] = Mutex;


/***/ },

/***/ "../../node_modules/async-mutex/lib/Semaphore.js"
/*!*******************************************************!*\
  !*** ../../node_modules/async-mutex/lib/Semaphore.js ***!
  \*******************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
var errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/async-mutex/lib/errors.js");
var Semaphore = /** @class */ (function () {
    function Semaphore(_value, _cancelError) {
        if (_cancelError === void 0) { _cancelError = errors_1.E_CANCELED; }
        this._value = _value;
        this._cancelError = _cancelError;
        this._weightedQueues = [];
        this._weightedWaiters = [];
    }
    Semaphore.prototype.acquire = function (weight) {
        var _this = this;
        if (weight === void 0) { weight = 1; }
        if (weight <= 0)
            throw new Error("invalid weight ".concat(weight, ": must be positive"));
        return new Promise(function (resolve, reject) {
            if (!_this._weightedQueues[weight - 1])
                _this._weightedQueues[weight - 1] = [];
            _this._weightedQueues[weight - 1].push({ resolve: resolve, reject: reject });
            _this._dispatch();
        });
    };
    Semaphore.prototype.runExclusive = function (callback, weight) {
        if (weight === void 0) { weight = 1; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, value, release;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.acquire(weight)];
                    case 1:
                        _a = _b.sent(), value = _a[0], release = _a[1];
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, , 4, 5]);
                        return [4 /*yield*/, callback(value)];
                    case 3: return [2 /*return*/, _b.sent()];
                    case 4:
                        release();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    Semaphore.prototype.waitForUnlock = function (weight) {
        var _this = this;
        if (weight === void 0) { weight = 1; }
        if (weight <= 0)
            throw new Error("invalid weight ".concat(weight, ": must be positive"));
        return new Promise(function (resolve) {
            if (!_this._weightedWaiters[weight - 1])
                _this._weightedWaiters[weight - 1] = [];
            _this._weightedWaiters[weight - 1].push(resolve);
            _this._dispatch();
        });
    };
    Semaphore.prototype.isLocked = function () {
        return this._value <= 0;
    };
    Semaphore.prototype.getValue = function () {
        return this._value;
    };
    Semaphore.prototype.setValue = function (value) {
        this._value = value;
        this._dispatch();
    };
    Semaphore.prototype.release = function (weight) {
        if (weight === void 0) { weight = 1; }
        if (weight <= 0)
            throw new Error("invalid weight ".concat(weight, ": must be positive"));
        this._value += weight;
        this._dispatch();
    };
    Semaphore.prototype.cancel = function () {
        var _this = this;
        this._weightedQueues.forEach(function (queue) { return queue.forEach(function (entry) { return entry.reject(_this._cancelError); }); });
        this._weightedQueues = [];
    };
    Semaphore.prototype._dispatch = function () {
        var _a;
        for (var weight = this._value; weight > 0; weight--) {
            var queueEntry = (_a = this._weightedQueues[weight - 1]) === null || _a === void 0 ? void 0 : _a.shift();
            if (!queueEntry)
                continue;
            var previousValue = this._value;
            var previousWeight = weight;
            this._value -= weight;
            weight = this._value + 1;
            queueEntry.resolve([previousValue, this._newReleaser(previousWeight)]);
        }
        this._drainUnlockWaiters();
    };
    Semaphore.prototype._newReleaser = function (weight) {
        var _this = this;
        var called = false;
        return function () {
            if (called)
                return;
            called = true;
            _this.release(weight);
        };
    };
    Semaphore.prototype._drainUnlockWaiters = function () {
        for (var weight = this._value; weight > 0; weight--) {
            if (!this._weightedWaiters[weight - 1])
                continue;
            this._weightedWaiters[weight - 1].forEach(function (waiter) { return waiter(); });
            this._weightedWaiters[weight - 1] = [];
        }
    };
    return Semaphore;
}());
exports["default"] = Semaphore;


/***/ },

/***/ "../../node_modules/async-mutex/lib/errors.js"
/*!****************************************************!*\
  !*** ../../node_modules/async-mutex/lib/errors.js ***!
  \****************************************************/
(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.E_CANCELED = exports.E_ALREADY_LOCKED = exports.E_TIMEOUT = void 0;
exports.E_TIMEOUT = new Error('timeout while waiting for mutex to become available');
exports.E_ALREADY_LOCKED = new Error('mutex already locked');
exports.E_CANCELED = new Error('request for lock canceled');


/***/ },

/***/ "../../node_modules/async-mutex/lib/index.js"
/*!***************************************************!*\
  !*** ../../node_modules/async-mutex/lib/index.js ***!
  \***************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tryAcquire = exports.withTimeout = exports.Semaphore = exports.Mutex = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
var Mutex_1 = __webpack_require__(/*! ./Mutex */ "../../node_modules/async-mutex/lib/Mutex.js");
Object.defineProperty(exports, "Mutex", ({ enumerable: true, get: function () { return Mutex_1.default; } }));
var Semaphore_1 = __webpack_require__(/*! ./Semaphore */ "../../node_modules/async-mutex/lib/Semaphore.js");
Object.defineProperty(exports, "Semaphore", ({ enumerable: true, get: function () { return Semaphore_1.default; } }));
var withTimeout_1 = __webpack_require__(/*! ./withTimeout */ "../../node_modules/async-mutex/lib/withTimeout.js");
Object.defineProperty(exports, "withTimeout", ({ enumerable: true, get: function () { return withTimeout_1.withTimeout; } }));
var tryAcquire_1 = __webpack_require__(/*! ./tryAcquire */ "../../node_modules/async-mutex/lib/tryAcquire.js");
Object.defineProperty(exports, "tryAcquire", ({ enumerable: true, get: function () { return tryAcquire_1.tryAcquire; } }));
tslib_1.__exportStar(__webpack_require__(/*! ./errors */ "../../node_modules/async-mutex/lib/errors.js"), exports);


/***/ },

/***/ "../../node_modules/async-mutex/lib/tryAcquire.js"
/*!********************************************************!*\
  !*** ../../node_modules/async-mutex/lib/tryAcquire.js ***!
  \********************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tryAcquire = void 0;
var errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/async-mutex/lib/errors.js");
var withTimeout_1 = __webpack_require__(/*! ./withTimeout */ "../../node_modules/async-mutex/lib/withTimeout.js");
// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types
function tryAcquire(sync, alreadyAcquiredError) {
    if (alreadyAcquiredError === void 0) { alreadyAcquiredError = errors_1.E_ALREADY_LOCKED; }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (0, withTimeout_1.withTimeout)(sync, 0, alreadyAcquiredError);
}
exports.tryAcquire = tryAcquire;


/***/ },

/***/ "../../node_modules/async-mutex/lib/withTimeout.js"
/*!*********************************************************!*\
  !*** ../../node_modules/async-mutex/lib/withTimeout.js ***!
  \*********************************************************/
(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.withTimeout = void 0;
var tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
/* eslint-disable @typescript-eslint/no-explicit-any */
var errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/async-mutex/lib/errors.js");
function withTimeout(sync, timeout, timeoutError) {
    var _this = this;
    if (timeoutError === void 0) { timeoutError = errors_1.E_TIMEOUT; }
    return {
        acquire: function (weight) {
            if (weight !== undefined && weight <= 0) {
                throw new Error("invalid weight ".concat(weight, ": must be positive"));
            }
            return new Promise(function (resolve, reject) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var isTimeout, handle, ticket, release, e_1;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            isTimeout = false;
                            handle = setTimeout(function () {
                                isTimeout = true;
                                reject(timeoutError);
                            }, timeout);
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, sync.acquire(weight)];
                        case 2:
                            ticket = _a.sent();
                            if (isTimeout) {
                                release = Array.isArray(ticket) ? ticket[1] : ticket;
                                release();
                            }
                            else {
                                clearTimeout(handle);
                                resolve(ticket);
                            }
                            return [3 /*break*/, 4];
                        case 3:
                            e_1 = _a.sent();
                            if (!isTimeout) {
                                clearTimeout(handle);
                                reject(e_1);
                            }
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/];
                    }
                });
            }); });
        },
        runExclusive: function (callback, weight) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var release, ticket;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            release = function () { return undefined; };
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, , 7, 8]);
                            return [4 /*yield*/, this.acquire(weight)];
                        case 2:
                            ticket = _a.sent();
                            if (!Array.isArray(ticket)) return [3 /*break*/, 4];
                            release = ticket[1];
                            return [4 /*yield*/, callback(ticket[0])];
                        case 3: return [2 /*return*/, _a.sent()];
                        case 4:
                            release = ticket;
                            return [4 /*yield*/, callback()];
                        case 5: return [2 /*return*/, _a.sent()];
                        case 6: return [3 /*break*/, 8];
                        case 7:
                            release();
                            return [7 /*endfinally*/];
                        case 8: return [2 /*return*/];
                    }
                });
            });
        },
        release: function (weight) {
            sync.release(weight);
        },
        cancel: function () {
            return sync.cancel();
        },
        waitForUnlock: function (weight) {
            if (weight !== undefined && weight <= 0) {
                throw new Error("invalid weight ".concat(weight, ": must be positive"));
            }
            return new Promise(function (resolve, reject) {
                var handle = setTimeout(function () { return reject(timeoutError); }, timeout);
                sync.waitForUnlock(weight).then(function () {
                    clearTimeout(handle);
                    resolve();
                });
            });
        },
        isLocked: function () { return sync.isLocked(); },
        getValue: function () { return sync.getValue(); },
        setValue: function (value) { return sync.setValue(value); },
    };
}
exports.withTimeout = withTimeout;


/***/ },

/***/ "../../node_modules/css-loader/dist/cjs.js!../../node_modules/@theia/plugin-ext/src/main/browser/dialogs/style/modal-notification.css"
/*!********************************************************************************************************************************************!*\
  !*** ../../node_modules/css-loader/dist/cjs.js!../../node_modules/@theia/plugin-ext/src/main/browser/dialogs/style/modal-notification.css ***!
  \********************************************************************************************************************************************/
(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../../../css-loader/dist/runtime/sourceMaps.js */ "../../node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../../../css-loader/dist/runtime/api.js */ "../../node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/********************************************************************************
 * Copyright (C) 2018 Red Hat, Inc. and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
 ********************************************************************************/
.modal-Notification {
  pointer-events: all;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  display: flex;
  flex-direction: row;
  -webkit-justify-content: center;
  justify-content: center;
  clear: both;
  box-sizing: border-box;
  position: relative;
  min-width: 200px;
  max-width: min(66vw, 800px);
  background-color: var(--theia-editorWidget-background);
  min-height: 35px;
  margin-bottom: 1px;
  color: var(--theia-editorWidget-foreground);
}

.modal-Notification .icon {
  display: inline-block;
  font-size: 20px;
  padding: 5px 0;
  width: 35px;
  order: 1;
}

.modal-Notification .icon .codicon {
  line-height: inherit;
  vertical-align: middle;
  font-size: calc(var(--theia-ui-padding) * 5);
  color: var(--theia-editorInfo-foreground);
}

.modal-Notification .icon .error {
  color: var(--theia-editorError-foreground);
}

.modal-Notification .icon .warning {
  color: var(--theia-editorWarning-foreground);
}

.modal-Notification .text {
  order: 2;
  display: inline-block;
  max-height: min(66vh, 600px);
  -webkit-user-select: text;
  -moz-user-select: text;
  -ms-user-select: text;
  user-select: text;
  align-self: center;
  flex: 1 100%;
  padding: 10px;
  overflow: auto;
  white-space: pre-wrap;
}

.modal-Notification .text > p {
  margin: 0;
  font-size: var(--theia-ui-font-size1);
  font-family: var(--theia-ui-font-family);
  vertical-align: middle;
}

.modal-Notification .buttons {
  display: flex;
  flex-direction: row;
  order: 3;
  white-space: nowrap;
  align-self: flex-end;
  height: 40px;
}

.modal-Notification .buttons > button {
  background-color: var(--theia-button-background);
  color: var(--theia-button-foreground);
  border: none;
  border-radius: 0;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  padding: 0 10px;
  margin: 0;
  font-size: var(--theia-ui-font-size1);
  outline: none;
  cursor: pointer;
}

.modal-Notification .buttons > button:hover {
  background-color: var(--theia-button-hoverBackground);
}

.modal-Notification .detail {
  align-self: center;
  order: 3;
  flex: 1 100%;
  color: var(--theia-descriptionForeground);
}

.modal-Notification .detail > p {
  margin: calc(var(--theia-ui-padding) * 2) 0px 0px 0px;
}

.modal-Notification .text {
  padding: calc(var(--theia-ui-padding) * 1.5);
}
`, "",{"version":3,"sources":["webpack://./../../node_modules/@theia/plugin-ext/src/main/browser/dialogs/style/modal-notification.css"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;iFAciF;AACjF;EACE,mBAAmB;EACnB,yBAAyB;EACzB,sBAAsB;EACtB,qBAAqB;EACrB,iBAAiB;EACjB,aAAa;EACb,mBAAmB;EACnB,+BAA+B;EAC/B,uBAAuB;EACvB,WAAW;EACX,sBAAsB;EACtB,kBAAkB;EAClB,gBAAgB;EAChB,2BAA2B;EAC3B,sDAAsD;EACtD,gBAAgB;EAChB,kBAAkB;EAClB,2CAA2C;AAC7C;;AAEA;EACE,qBAAqB;EACrB,eAAe;EACf,cAAc;EACd,WAAW;EACX,QAAQ;AACV;;AAEA;EACE,oBAAoB;EACpB,sBAAsB;EACtB,4CAA4C;EAC5C,yCAAyC;AAC3C;;AAEA;EACE,0CAA0C;AAC5C;;AAEA;EACE,4CAA4C;AAC9C;;AAEA;EACE,QAAQ;EACR,qBAAqB;EACrB,4BAA4B;EAC5B,yBAAyB;EACzB,sBAAsB;EACtB,qBAAqB;EACrB,iBAAiB;EACjB,kBAAkB;EAClB,YAAY;EACZ,aAAa;EACb,cAAc;EACd,qBAAqB;AACvB;;AAEA;EACE,SAAS;EACT,qCAAqC;EACrC,wCAAwC;EACxC,sBAAsB;AACxB;;AAEA;EACE,aAAa;EACb,mBAAmB;EACnB,QAAQ;EACR,mBAAmB;EACnB,oBAAoB;EACpB,YAAY;AACd;;AAEA;EACE,gDAAgD;EAChD,qCAAqC;EACrC,YAAY;EACZ,gBAAgB;EAChB,kBAAkB;EAClB,qBAAqB;EACrB,qBAAqB;EACrB,eAAe;EACf,SAAS;EACT,qCAAqC;EACrC,aAAa;EACb,eAAe;AACjB;;AAEA;EACE,qDAAqD;AACvD;;AAEA;EACE,kBAAkB;EAClB,QAAQ;EACR,YAAY;EACZ,yCAAyC;AAC3C;;AAEA;EACE,qDAAqD;AACvD;;AAEA;EACE,4CAA4C;AAC9C","sourcesContent":["/********************************************************************************\n * Copyright (C) 2018 Red Hat, Inc. and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0\n ********************************************************************************/\n.modal-Notification {\n  pointer-events: all;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  display: flex;\n  flex-direction: row;\n  -webkit-justify-content: center;\n  justify-content: center;\n  clear: both;\n  box-sizing: border-box;\n  position: relative;\n  min-width: 200px;\n  max-width: min(66vw, 800px);\n  background-color: var(--theia-editorWidget-background);\n  min-height: 35px;\n  margin-bottom: 1px;\n  color: var(--theia-editorWidget-foreground);\n}\n\n.modal-Notification .icon {\n  display: inline-block;\n  font-size: 20px;\n  padding: 5px 0;\n  width: 35px;\n  order: 1;\n}\n\n.modal-Notification .icon .codicon {\n  line-height: inherit;\n  vertical-align: middle;\n  font-size: calc(var(--theia-ui-padding) * 5);\n  color: var(--theia-editorInfo-foreground);\n}\n\n.modal-Notification .icon .error {\n  color: var(--theia-editorError-foreground);\n}\n\n.modal-Notification .icon .warning {\n  color: var(--theia-editorWarning-foreground);\n}\n\n.modal-Notification .text {\n  order: 2;\n  display: inline-block;\n  max-height: min(66vh, 600px);\n  -webkit-user-select: text;\n  -moz-user-select: text;\n  -ms-user-select: text;\n  user-select: text;\n  align-self: center;\n  flex: 1 100%;\n  padding: 10px;\n  overflow: auto;\n  white-space: pre-wrap;\n}\n\n.modal-Notification .text > p {\n  margin: 0;\n  font-size: var(--theia-ui-font-size1);\n  font-family: var(--theia-ui-font-family);\n  vertical-align: middle;\n}\n\n.modal-Notification .buttons {\n  display: flex;\n  flex-direction: row;\n  order: 3;\n  white-space: nowrap;\n  align-self: flex-end;\n  height: 40px;\n}\n\n.modal-Notification .buttons > button {\n  background-color: var(--theia-button-background);\n  color: var(--theia-button-foreground);\n  border: none;\n  border-radius: 0;\n  text-align: center;\n  text-decoration: none;\n  display: inline-block;\n  padding: 0 10px;\n  margin: 0;\n  font-size: var(--theia-ui-font-size1);\n  outline: none;\n  cursor: pointer;\n}\n\n.modal-Notification .buttons > button:hover {\n  background-color: var(--theia-button-hoverBackground);\n}\n\n.modal-Notification .detail {\n  align-self: center;\n  order: 3;\n  flex: 1 100%;\n  color: var(--theia-descriptionForeground);\n}\n\n.modal-Notification .detail > p {\n  margin: calc(var(--theia-ui-padding) * 2) 0px 0px 0px;\n}\n\n.modal-Notification .text {\n  padding: calc(var(--theia-ui-padding) * 1.5);\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ },

/***/ "../../node_modules/css-loader/dist/cjs.js!../../node_modules/@theia/plugin-ext/src/main/browser/style/comments.css"
/*!**************************************************************************************************************************!*\
  !*** ../../node_modules/css-loader/dist/cjs.js!../../node_modules/@theia/plugin-ext/src/main/browser/style/comments.css ***!
  \**************************************************************************************************************************/
(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../../css-loader/dist/runtime/sourceMaps.js */ "../../node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../../css-loader/dist/runtime/api.js */ "../../node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/* some code copied and modified from https://github.com/microsoft/vscode/blob/1.49.3/src/vs/workbench/contrib/comments/browser/media/review.css */

.comment-range-glyph {
    margin-left: 5px;
    cursor: pointer;
}

.comment-range-glyph:before {
    position: absolute;
    content: '';
    height: 100%;
    width: 0;
    left: -2px;
    transition: width 80ms linear, left 80ms linear;
}

.monaco-editor .margin-view-overlays > div:hover > .comment-range-glyph.comment-diff-added:before,
.monaco-editor .comment-range-glyph.comment-thread:before {
    position: absolute;
    height: 100%;
    width: 9px;
    left: -6px;
    z-index: 10;
    color: black;
    text-align: center;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
}

.monaco-editor .comment-diff-added {
    border-left: 3px solid var(--theia-editorGutter-commentRangeForeground);
    transition: opacity 0.5s;
}

.monaco-editor .comment-diff-added:before {
    background: var(--theia-editorGutter-commentRangeForeground);
}

.monaco-editor .margin-view-overlays > div:hover > .comment-range-glyph.comment-diff-added:before {
    content: "+";
}

.monaco-editor .comment-range-glyph.comment-thread {
    z-index: 20;
    border-left: 3px solid #000;
}

.monaco-editor .comment-thread:before {
    background: var(--theia-editorGutter-commentRangeForeground);
}

.monaco-editor .comment-range-glyph.comment-thread:before {
    content: "";
    font-size: 10px;
    line-height: 100%;
    z-index: 20;
}

.monaco-editor .review-widget .body {
    overflow: hidden;
}

.monaco-editor .review-widget .head {
    box-sizing: border-box;
    display: flex;
    height: 100%;
}

.monaco-editor .review-widget .head .review-title {
    display: inline-block;
    font-size: 13px;
    margin-left: 20px;
    cursor: default;
}

.monaco-editor .review-widget .head .review-actions {
    flex: 1;
    text-align: right;
    padding-right: 2px;
}

.monaco-editor .review-widget .head .review-actions > .monaco-action-bar {
    display: inline-block;
}

.monaco-editor .review-widget .head .review-actions > .monaco-action-bar,
.monaco-editor .review-widget .head .review-actions > .monaco-action-bar > .actions-container {
    height: 100%;
}

.monaco-editor .review-widget .action-item {
    min-width: 18px;
    min-height: 20px;
    margin-left: 4px;
}

.monaco-editor .review-widget .head .review-actions > .monaco-action-bar .action-label {
    width: 16px;
    height: 100%;
    margin: 0;
    color: var(--theia-editorWidget-foreground);
    line-height: inherit;
    background-repeat: no-repeat;
    background-position: center center;
}

.monaco-editor .review-widget>.body {
    border-top: 1px solid;
    position: relative;
}

.monaco-editor .review-widget .body .comment-form {
    margin: 8px 20px;
}

.monaco-editor .review-widget .body .review-comment {
    padding: 8px 16px 8px 20px;
    display: flex;
}

.monaco-editor .review-widget .body .review-comment .avatar-container {
    margin-right: 8px !important;
    margin-top: 4px !important;
}

.monaco-editor .review-widget .body .review-comment .avatar-container img.avatar {
    height: 28px;
    width: 28px;
    display: inline-block;
    overflow: hidden;
    line-height: 1;
    vertical-align: middle;
    border-radius: 3px;
    border-style: none;
}

.monaco-editor .review-widget .body .review-comment .review-comment-contents {
    user-select: text;
    -webkit-user-select: text;
    width: 100%;
    overflow: hidden;
}

.monaco-editor .review-widget .body .review-comment .review-comment-contents .author {
    line-height: var(--theia-content-line-height);
}

.monaco-editor .review-widget .body .review-comment .review-comment-contents .timestamp {
    line-height: var(--theia-content-line-height);
    margin: 0 5px 0 5px;
    padding: 0 2px 0 2px;
}

.monaco-editor .review-widget .body .review-comment .review-comment-contents .isPending {
    margin: 0 5px 0 5px;
    padding: 0 2px 0 2px;
    font-style: italic;
}

.monaco-editor .review-widget .body .review-comment .review-comment-contents .comment-body {
    padding-top: 4px;
}

.monaco-editor .review-widget .body .review-comment .comment-title {
    display: flex;
    width: 100%;
}

.monaco-editor .review-widget .body .comment-form .theia-comments-input-message-container {
    display: none;
}

.monaco-editor .review-widget .body .comment-form.expand .theia-comments-input-message-container,
.edit-textarea .theia-comments-input-message-container {
    display: flex;
    flex-direction: column;
    margin: 0px 0px 7px 0px;
    max-height: 400px;
}

.monaco-editor .review-widget .body .comment-form.expand .theia-comments-input-message-container textarea,
.edit-textarea .theia-comments-input-message-container textarea {
    line-height: var(--theia-content-line-height);
    background: var(--theia-editor-background);
    resize: none;
    height: 90px;
    box-sizing: border-box;
    min-height: 32px;
    padding: 4px;
    border: none;
}

.monaco-editor .review-widget .body .comment-form.expand .theia-comments-input-message-container textarea:placeholder-shown,
.edit-textarea .theia-comments-input-message-container textarea:placeholder-shown {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.monaco-editor .review-widget .body .comment-form.expand .theia-comments-input-message-container textarea:not(:focus),
.edit-textarea .theia-comments-input-message-container textarea:not(:focus) {
    border: var(--theia-border-width) solid var(--theia-editor-background);
}

.monaco-editor .review-widget .body .comment-form.expand .theia-comments-input-message-container textarea:focus,
.edit-textarea .theia-comments-input-message-container textarea:focus {
    border: var(--theia-border-width) solid var(--theia-focusBorder);
}

.theia-comments-input-message {
    width: 100%;
}

.monaco-editor .review-widget .body .comment-body p,
.monaco-editor .review-widget .body .comment-body ul {
    margin: 8px 0;
}

.monaco-editor .review-widget .body .comment-body p:first-child,
.monaco-editor .review-widget .body .comment-body ul:first-child {
    margin-top: 0;
}

.monaco-editor .review-widget .body .comment-body p:last-child,
.monaco-editor .review-widget .body.comment-body ul:last-child {
    margin-bottom: 0;
}

.monaco-editor .review-widget .body .comment-body ul {
    padding-left: 20px;
}

.monaco-editor .review-widget .body .comment-body li > p {
    margin-bottom: 0;
}

.monaco-editor .review-widget .body .comment-body li > ul {
    margin-top: 0;
}

.monaco-editor .review-widget .body .comment-body code {
    border-radius: 3px;
    padding: 0 0.4em;
}

.monaco-editor .review-widget .body .comment-body span {
    white-space: pre;
}

.monaco-editor .review-widget .body .comment-body img {
    max-width: 100%;
}

.monaco-editor .review-widget .body .comment-form {
    flex: 1;
    margin: 0px;
    /* Reset margin as it's handled by container */
}

.monaco-editor .review-widget .body .comment-form .form-actions {
    display: none;
}

.monaco-editor .review-widget .body .comment-form.expand .form-actions {
    display: block;
    box-sizing: content-box;
}

.monaco-editor .review-widget .body .comment-form.expand .review-thread-reply-button {
    display: none;
}

.monaco-editor .review-widget .body .comment-form .review-thread-reply-button {
    text-align: left;
    display: block;
    width: 100%;
    resize: vertical;
    background: var(--theia-editor-background);
    color: var(--theia-input-foreground);
    cursor: text;
    font-size: var(--theia-ui-font-size1);
    border-radius: 0;
    box-sizing: border-box;
    padding: 6px 12px;
    font-weight: 600;
    line-height: 20px;
    white-space: nowrap;
    border: 0px;
    outline: 1px solid transparent;
}

.monaco-editor .review-widget .body .comment-form .review-thread-reply-button:focus {
    outline-style: solid;
    outline-width: 1px;
}

.monaco-editor .review-widget .body .comment-form.expand .form-actions,
.monaco-editor .review-widget .body .edit-container .form-actions {
    overflow: auto;
    padding: 10px 0;
}

.monaco-editor .review-widget .body .edit-container .form-actions {
    display: flex;
    justify-content: flex-end;
}

.monaco-editor .review-widget .body .edit-textarea {
    margin: 5px 0 10px 0;
}

.monaco-editor .review-widget .body .comment-form.expand .comments-text-button,
.monaco-editor .review-widget .body .edit-container .comments-text-button {
    width: auto;
    padding: 4px 10px;
    margin-left: 5px;
    margin-bottom: 5px;
}

.monaco-editor .review-widget .body .comment-form.expand .comments-text-button {
    float: right;
}

.theia-comments-inline-actions-container {
    display: flex;
    justify-content: flex-end;
    margin-left: auto;
    min-height: 16px;
}

.theia-comments-inline-actions {
    display: flex;
    margin: 0 3px;
}

.theia-comments-inline-actions a {
    color: var(--theia-icon-foreground);
}

.theia-comments-inline-action {
    padding: 0px 3px;
    font-size: var(--theia-ui-font-size1);
    margin: 0 2px;
    cursor: pointer;
    display: flex;
    align-items: center;
}
`, "",{"version":3,"sources":["webpack://./../../node_modules/@theia/plugin-ext/src/main/browser/style/comments.css"],"names":[],"mappings":"AAAA;;;+FAG+F;AAC/F,kJAAkJ;;AAElJ;IACI,gBAAgB;IAChB,eAAe;AACnB;;AAEA;IACI,kBAAkB;IAClB,WAAW;IACX,YAAY;IACZ,QAAQ;IACR,UAAU;IACV,+CAA+C;AACnD;;AAEA;;IAEI,kBAAkB;IAClB,YAAY;IACZ,UAAU;IACV,UAAU;IACV,WAAW;IACX,YAAY;IACZ,kBAAkB;IAClB,aAAa;IACb,mBAAmB;IACnB,mBAAmB;IACnB,uBAAuB;AAC3B;;AAEA;IACI,uEAAuE;IACvE,wBAAwB;AAC5B;;AAEA;IACI,4DAA4D;AAChE;;AAEA;IACI,YAAY;AAChB;;AAEA;IACI,WAAW;IACX,2BAA2B;AAC/B;;AAEA;IACI,4DAA4D;AAChE;;AAEA;IACI,YAAY;IACZ,eAAe;IACf,iBAAiB;IACjB,WAAW;AACf;;AAEA;IACI,gBAAgB;AACpB;;AAEA;IACI,sBAAsB;IACtB,aAAa;IACb,YAAY;AAChB;;AAEA;IACI,qBAAqB;IACrB,eAAe;IACf,iBAAiB;IACjB,eAAe;AACnB;;AAEA;IACI,OAAO;IACP,iBAAiB;IACjB,kBAAkB;AACtB;;AAEA;IACI,qBAAqB;AACzB;;AAEA;;IAEI,YAAY;AAChB;;AAEA;IACI,eAAe;IACf,gBAAgB;IAChB,gBAAgB;AACpB;;AAEA;IACI,WAAW;IACX,YAAY;IACZ,SAAS;IACT,2CAA2C;IAC3C,oBAAoB;IACpB,4BAA4B;IAC5B,kCAAkC;AACtC;;AAEA;IACI,qBAAqB;IACrB,kBAAkB;AACtB;;AAEA;IACI,gBAAgB;AACpB;;AAEA;IACI,0BAA0B;IAC1B,aAAa;AACjB;;AAEA;IACI,4BAA4B;IAC5B,0BAA0B;AAC9B;;AAEA;IACI,YAAY;IACZ,WAAW;IACX,qBAAqB;IACrB,gBAAgB;IAChB,cAAc;IACd,sBAAsB;IACtB,kBAAkB;IAClB,kBAAkB;AACtB;;AAEA;IACI,iBAAiB;IACjB,yBAAyB;IACzB,WAAW;IACX,gBAAgB;AACpB;;AAEA;IACI,6CAA6C;AACjD;;AAEA;IACI,6CAA6C;IAC7C,mBAAmB;IACnB,oBAAoB;AACxB;;AAEA;IACI,mBAAmB;IACnB,oBAAoB;IACpB,kBAAkB;AACtB;;AAEA;IACI,gBAAgB;AACpB;;AAEA;IACI,aAAa;IACb,WAAW;AACf;;AAEA;IACI,aAAa;AACjB;;AAEA;;IAEI,aAAa;IACb,sBAAsB;IACtB,uBAAuB;IACvB,iBAAiB;AACrB;;AAEA;;IAEI,6CAA6C;IAC7C,0CAA0C;IAC1C,YAAY;IACZ,YAAY;IACZ,sBAAsB;IACtB,gBAAgB;IAChB,YAAY;IACZ,YAAY;AAChB;;AAEA;;IAEI,gBAAgB;IAChB,uBAAuB;IACvB,mBAAmB;AACvB;;AAEA;;IAEI,sEAAsE;AAC1E;;AAEA;;IAEI,gEAAgE;AACpE;;AAEA;IACI,WAAW;AACf;;AAEA;;IAEI,aAAa;AACjB;;AAEA;;IAEI,aAAa;AACjB;;AAEA;;IAEI,gBAAgB;AACpB;;AAEA;IACI,kBAAkB;AACtB;;AAEA;IACI,gBAAgB;AACpB;;AAEA;IACI,aAAa;AACjB;;AAEA;IACI,kBAAkB;IAClB,gBAAgB;AACpB;;AAEA;IACI,gBAAgB;AACpB;;AAEA;IACI,eAAe;AACnB;;AAEA;IACI,OAAO;IACP,WAAW;IACX,8CAA8C;AAClD;;AAEA;IACI,aAAa;AACjB;;AAEA;IACI,cAAc;IACd,uBAAuB;AAC3B;;AAEA;IACI,aAAa;AACjB;;AAEA;IACI,gBAAgB;IAChB,cAAc;IACd,WAAW;IACX,gBAAgB;IAChB,0CAA0C;IAC1C,oCAAoC;IACpC,YAAY;IACZ,qCAAqC;IACrC,gBAAgB;IAChB,sBAAsB;IACtB,iBAAiB;IACjB,gBAAgB;IAChB,iBAAiB;IACjB,mBAAmB;IACnB,WAAW;IACX,8BAA8B;AAClC;;AAEA;IACI,oBAAoB;IACpB,kBAAkB;AACtB;;AAEA;;IAEI,cAAc;IACd,eAAe;AACnB;;AAEA;IACI,aAAa;IACb,yBAAyB;AAC7B;;AAEA;IACI,oBAAoB;AACxB;;AAEA;;IAEI,WAAW;IACX,iBAAiB;IACjB,gBAAgB;IAChB,kBAAkB;AACtB;;AAEA;IACI,YAAY;AAChB;;AAEA;IACI,aAAa;IACb,yBAAyB;IACzB,iBAAiB;IACjB,gBAAgB;AACpB;;AAEA;IACI,aAAa;IACb,aAAa;AACjB;;AAEA;IACI,mCAAmC;AACvC;;AAEA;IACI,gBAAgB;IAChB,qCAAqC;IACrC,aAAa;IACb,eAAe;IACf,aAAa;IACb,mBAAmB;AACvB","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/* some code copied and modified from https://github.com/microsoft/vscode/blob/1.49.3/src/vs/workbench/contrib/comments/browser/media/review.css */\n\n.comment-range-glyph {\n    margin-left: 5px;\n    cursor: pointer;\n}\n\n.comment-range-glyph:before {\n    position: absolute;\n    content: '';\n    height: 100%;\n    width: 0;\n    left: -2px;\n    transition: width 80ms linear, left 80ms linear;\n}\n\n.monaco-editor .margin-view-overlays > div:hover > .comment-range-glyph.comment-diff-added:before,\n.monaco-editor .comment-range-glyph.comment-thread:before {\n    position: absolute;\n    height: 100%;\n    width: 9px;\n    left: -6px;\n    z-index: 10;\n    color: black;\n    text-align: center;\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    justify-content: center;\n}\n\n.monaco-editor .comment-diff-added {\n    border-left: 3px solid var(--theia-editorGutter-commentRangeForeground);\n    transition: opacity 0.5s;\n}\n\n.monaco-editor .comment-diff-added:before {\n    background: var(--theia-editorGutter-commentRangeForeground);\n}\n\n.monaco-editor .margin-view-overlays > div:hover > .comment-range-glyph.comment-diff-added:before {\n    content: \"+\";\n}\n\n.monaco-editor .comment-range-glyph.comment-thread {\n    z-index: 20;\n    border-left: 3px solid #000;\n}\n\n.monaco-editor .comment-thread:before {\n    background: var(--theia-editorGutter-commentRangeForeground);\n}\n\n.monaco-editor .comment-range-glyph.comment-thread:before {\n    content: \"\";\n    font-size: 10px;\n    line-height: 100%;\n    z-index: 20;\n}\n\n.monaco-editor .review-widget .body {\n    overflow: hidden;\n}\n\n.monaco-editor .review-widget .head {\n    box-sizing: border-box;\n    display: flex;\n    height: 100%;\n}\n\n.monaco-editor .review-widget .head .review-title {\n    display: inline-block;\n    font-size: 13px;\n    margin-left: 20px;\n    cursor: default;\n}\n\n.monaco-editor .review-widget .head .review-actions {\n    flex: 1;\n    text-align: right;\n    padding-right: 2px;\n}\n\n.monaco-editor .review-widget .head .review-actions > .monaco-action-bar {\n    display: inline-block;\n}\n\n.monaco-editor .review-widget .head .review-actions > .monaco-action-bar,\n.monaco-editor .review-widget .head .review-actions > .monaco-action-bar > .actions-container {\n    height: 100%;\n}\n\n.monaco-editor .review-widget .action-item {\n    min-width: 18px;\n    min-height: 20px;\n    margin-left: 4px;\n}\n\n.monaco-editor .review-widget .head .review-actions > .monaco-action-bar .action-label {\n    width: 16px;\n    height: 100%;\n    margin: 0;\n    color: var(--theia-editorWidget-foreground);\n    line-height: inherit;\n    background-repeat: no-repeat;\n    background-position: center center;\n}\n\n.monaco-editor .review-widget>.body {\n    border-top: 1px solid;\n    position: relative;\n}\n\n.monaco-editor .review-widget .body .comment-form {\n    margin: 8px 20px;\n}\n\n.monaco-editor .review-widget .body .review-comment {\n    padding: 8px 16px 8px 20px;\n    display: flex;\n}\n\n.monaco-editor .review-widget .body .review-comment .avatar-container {\n    margin-right: 8px !important;\n    margin-top: 4px !important;\n}\n\n.monaco-editor .review-widget .body .review-comment .avatar-container img.avatar {\n    height: 28px;\n    width: 28px;\n    display: inline-block;\n    overflow: hidden;\n    line-height: 1;\n    vertical-align: middle;\n    border-radius: 3px;\n    border-style: none;\n}\n\n.monaco-editor .review-widget .body .review-comment .review-comment-contents {\n    user-select: text;\n    -webkit-user-select: text;\n    width: 100%;\n    overflow: hidden;\n}\n\n.monaco-editor .review-widget .body .review-comment .review-comment-contents .author {\n    line-height: var(--theia-content-line-height);\n}\n\n.monaco-editor .review-widget .body .review-comment .review-comment-contents .timestamp {\n    line-height: var(--theia-content-line-height);\n    margin: 0 5px 0 5px;\n    padding: 0 2px 0 2px;\n}\n\n.monaco-editor .review-widget .body .review-comment .review-comment-contents .isPending {\n    margin: 0 5px 0 5px;\n    padding: 0 2px 0 2px;\n    font-style: italic;\n}\n\n.monaco-editor .review-widget .body .review-comment .review-comment-contents .comment-body {\n    padding-top: 4px;\n}\n\n.monaco-editor .review-widget .body .review-comment .comment-title {\n    display: flex;\n    width: 100%;\n}\n\n.monaco-editor .review-widget .body .comment-form .theia-comments-input-message-container {\n    display: none;\n}\n\n.monaco-editor .review-widget .body .comment-form.expand .theia-comments-input-message-container,\n.edit-textarea .theia-comments-input-message-container {\n    display: flex;\n    flex-direction: column;\n    margin: 0px 0px 7px 0px;\n    max-height: 400px;\n}\n\n.monaco-editor .review-widget .body .comment-form.expand .theia-comments-input-message-container textarea,\n.edit-textarea .theia-comments-input-message-container textarea {\n    line-height: var(--theia-content-line-height);\n    background: var(--theia-editor-background);\n    resize: none;\n    height: 90px;\n    box-sizing: border-box;\n    min-height: 32px;\n    padding: 4px;\n    border: none;\n}\n\n.monaco-editor .review-widget .body .comment-form.expand .theia-comments-input-message-container textarea:placeholder-shown,\n.edit-textarea .theia-comments-input-message-container textarea:placeholder-shown {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.monaco-editor .review-widget .body .comment-form.expand .theia-comments-input-message-container textarea:not(:focus),\n.edit-textarea .theia-comments-input-message-container textarea:not(:focus) {\n    border: var(--theia-border-width) solid var(--theia-editor-background);\n}\n\n.monaco-editor .review-widget .body .comment-form.expand .theia-comments-input-message-container textarea:focus,\n.edit-textarea .theia-comments-input-message-container textarea:focus {\n    border: var(--theia-border-width) solid var(--theia-focusBorder);\n}\n\n.theia-comments-input-message {\n    width: 100%;\n}\n\n.monaco-editor .review-widget .body .comment-body p,\n.monaco-editor .review-widget .body .comment-body ul {\n    margin: 8px 0;\n}\n\n.monaco-editor .review-widget .body .comment-body p:first-child,\n.monaco-editor .review-widget .body .comment-body ul:first-child {\n    margin-top: 0;\n}\n\n.monaco-editor .review-widget .body .comment-body p:last-child,\n.monaco-editor .review-widget .body.comment-body ul:last-child {\n    margin-bottom: 0;\n}\n\n.monaco-editor .review-widget .body .comment-body ul {\n    padding-left: 20px;\n}\n\n.monaco-editor .review-widget .body .comment-body li > p {\n    margin-bottom: 0;\n}\n\n.monaco-editor .review-widget .body .comment-body li > ul {\n    margin-top: 0;\n}\n\n.monaco-editor .review-widget .body .comment-body code {\n    border-radius: 3px;\n    padding: 0 0.4em;\n}\n\n.monaco-editor .review-widget .body .comment-body span {\n    white-space: pre;\n}\n\n.monaco-editor .review-widget .body .comment-body img {\n    max-width: 100%;\n}\n\n.monaco-editor .review-widget .body .comment-form {\n    flex: 1;\n    margin: 0px;\n    /* Reset margin as it's handled by container */\n}\n\n.monaco-editor .review-widget .body .comment-form .form-actions {\n    display: none;\n}\n\n.monaco-editor .review-widget .body .comment-form.expand .form-actions {\n    display: block;\n    box-sizing: content-box;\n}\n\n.monaco-editor .review-widget .body .comment-form.expand .review-thread-reply-button {\n    display: none;\n}\n\n.monaco-editor .review-widget .body .comment-form .review-thread-reply-button {\n    text-align: left;\n    display: block;\n    width: 100%;\n    resize: vertical;\n    background: var(--theia-editor-background);\n    color: var(--theia-input-foreground);\n    cursor: text;\n    font-size: var(--theia-ui-font-size1);\n    border-radius: 0;\n    box-sizing: border-box;\n    padding: 6px 12px;\n    font-weight: 600;\n    line-height: 20px;\n    white-space: nowrap;\n    border: 0px;\n    outline: 1px solid transparent;\n}\n\n.monaco-editor .review-widget .body .comment-form .review-thread-reply-button:focus {\n    outline-style: solid;\n    outline-width: 1px;\n}\n\n.monaco-editor .review-widget .body .comment-form.expand .form-actions,\n.monaco-editor .review-widget .body .edit-container .form-actions {\n    overflow: auto;\n    padding: 10px 0;\n}\n\n.monaco-editor .review-widget .body .edit-container .form-actions {\n    display: flex;\n    justify-content: flex-end;\n}\n\n.monaco-editor .review-widget .body .edit-textarea {\n    margin: 5px 0 10px 0;\n}\n\n.monaco-editor .review-widget .body .comment-form.expand .comments-text-button,\n.monaco-editor .review-widget .body .edit-container .comments-text-button {\n    width: auto;\n    padding: 4px 10px;\n    margin-left: 5px;\n    margin-bottom: 5px;\n}\n\n.monaco-editor .review-widget .body .comment-form.expand .comments-text-button {\n    float: right;\n}\n\n.theia-comments-inline-actions-container {\n    display: flex;\n    justify-content: flex-end;\n    margin-left: auto;\n    min-height: 16px;\n}\n\n.theia-comments-inline-actions {\n    display: flex;\n    margin: 0 3px;\n}\n\n.theia-comments-inline-actions a {\n    color: var(--theia-icon-foreground);\n}\n\n.theia-comments-inline-action {\n    padding: 0px 3px;\n    font-size: var(--theia-ui-font-size1);\n    margin: 0 2px;\n    cursor: pointer;\n    display: flex;\n    align-items: center;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ },

/***/ "../../node_modules/css-loader/dist/cjs.js!../../node_modules/@theia/plugin-ext/src/main/browser/style/index.css"
/*!***********************************************************************************************************************!*\
  !*** ../../node_modules/css-loader/dist/cjs.js!../../node_modules/@theia/plugin-ext/src/main/browser/style/index.css ***!
  \***********************************************************************************************************************/
(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../../css-loader/dist/runtime/sourceMaps.js */ "../../node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../../css-loader/dist/runtime/api.js */ "../../node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _css_loader_dist_cjs_js_plugin_sidebar_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! -!../../../../../../css-loader/dist/cjs.js!./plugin-sidebar.css */ "../../node_modules/css-loader/dist/cjs.js!../../node_modules/@theia/plugin-ext/src/main/browser/style/plugin-sidebar.css");
/* harmony import */ var _css_loader_dist_cjs_js_webview_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! -!../../../../../../css-loader/dist/cjs.js!./webview.css */ "../../node_modules/css-loader/dist/cjs.js!../../node_modules/@theia/plugin-ext/src/main/browser/style/webview.css");
/* harmony import */ var _css_loader_dist_cjs_js_tree_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! -!../../../../../../css-loader/dist/cjs.js!./tree.css */ "../../node_modules/css-loader/dist/cjs.js!../../node_modules/@theia/plugin-ext/src/main/browser/style/tree.css");
// Imports





var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
___CSS_LOADER_EXPORT___.i(_css_loader_dist_cjs_js_plugin_sidebar_css__WEBPACK_IMPORTED_MODULE_2__["default"]);
___CSS_LOADER_EXPORT___.i(_css_loader_dist_cjs_js_webview_css__WEBPACK_IMPORTED_MODULE_3__["default"]);
___CSS_LOADER_EXPORT___.i(_css_loader_dist_cjs_js_tree_css__WEBPACK_IMPORTED_MODULE_4__["default"]);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/********************************************************************************
 * Copyright (C) 2018 Red Hat, Inc. and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
 ********************************************************************************/

.spinnerContainer {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}

.flexcontainer {
  display: flex;
}

.row {
  width: 100%;
}

.column {
  flex-direction: column;
}

.theia-plugin-view-container {
  /*
        It might take a second or two until the real plugin mask is loaded
        To prevent flickering on the icon, we set a transparent mask instead
        Since masks only support images, svg or gradients, we create a transparent gradient here
    */
  -webkit-mask: linear-gradient(transparent, transparent);
  mask: linear-gradient(transparent, transparent);
  background-color: var(--theia-activityBar-inactiveForeground);
}

.theia-plugin-file-icon,
.theia-plugin-file-icon::before,
.theia-plugin-folder-icon,
.theia-plugin-folder-icon::before,
.theia-plugin-folder-expanded-icon,
.theia-plugin-folder-expanded-icon::before,
.theia-plugin-root-folder-icon,
.theia-plugin-root-folder-icon::before,
.theia-plugin-root-folder-expanded-icon,
.theia-plugin-root-folder-expanded-icon::before {
  padding-right: var(--theia-ui-padding);
  width: var(--theia-icon-size);
  height: var(--theia-content-line-height);
  line-height: inherit !important;
  display: inline-block;
}

.lm-TabBar.theia-app-sides .theia-plugin-file-icon,
.lm-TabBar.theia-app-sides .theia-plugin-file-icon::before,
.lm-TabBar.theia-app-sides .theia-plugin-folder-icon,
.lm-TabBar.theia-app-sides .theia-plugin-folder-icon::before,
.lm-TabBar.theia-app-sides .theia-plugin-folder-expanded-icon,
.lm-TabBar.theia-app-sides .theia-plugin-folder-expanded-icon::before,
.lm-TabBar.theia-app-sides .theia-plugin-root-folder-icon,
.lm-TabBar.theia-app-sides .theia-plugin-root-folder-icon::before,
.lm-TabBar.theia-app-sides .theia-plugin-root-folder-expanded-icon,
.lm-TabBar.theia-app-sides .theia-plugin-root-folder-expanded-icon::before {
  padding: 0px !important;
  width: var(--theia-private-sidebar-icon-size) !important;
  height: var(--theia-private-sidebar-icon-size) !important;
  background-size: var(--theia-private-sidebar-icon-size) !important;
  font-size: var(--theia-private-sidebar-icon-size) !important;
}
`, "",{"version":3,"sources":["webpack://./../../node_modules/@theia/plugin-ext/src/main/browser/style/index.css"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;iFAciF;;AAEjF;EACE,WAAW;EACX,YAAY;EACZ,aAAa;EACb,mBAAmB;EACnB,uBAAuB;AACzB;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,WAAW;AACb;;AAEA;EACE,sBAAsB;AACxB;;AAEA;EACE;;;;KAIG;EACH,uDAAuD;EACvD,+CAA+C;EAC/C,6DAA6D;AAC/D;;AAEA;;;;;;;;;;EAUE,sCAAsC;EACtC,6BAA6B;EAC7B,wCAAwC;EACxC,+BAA+B;EAC/B,qBAAqB;AACvB;;AAEA;;;;;;;;;;EAUE,uBAAuB;EACvB,wDAAwD;EACxD,yDAAyD;EACzD,kEAAkE;EAClE,4DAA4D;AAC9D","sourcesContent":["/********************************************************************************\n * Copyright (C) 2018 Red Hat, Inc. and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0\n ********************************************************************************/\n\n.spinnerContainer {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.flexcontainer {\n  display: flex;\n}\n\n.row {\n  width: 100%;\n}\n\n.column {\n  flex-direction: column;\n}\n\n.theia-plugin-view-container {\n  /*\n        It might take a second or two until the real plugin mask is loaded\n        To prevent flickering on the icon, we set a transparent mask instead\n        Since masks only support images, svg or gradients, we create a transparent gradient here\n    */\n  -webkit-mask: linear-gradient(transparent, transparent);\n  mask: linear-gradient(transparent, transparent);\n  background-color: var(--theia-activityBar-inactiveForeground);\n}\n\n.theia-plugin-file-icon,\n.theia-plugin-file-icon::before,\n.theia-plugin-folder-icon,\n.theia-plugin-folder-icon::before,\n.theia-plugin-folder-expanded-icon,\n.theia-plugin-folder-expanded-icon::before,\n.theia-plugin-root-folder-icon,\n.theia-plugin-root-folder-icon::before,\n.theia-plugin-root-folder-expanded-icon,\n.theia-plugin-root-folder-expanded-icon::before {\n  padding-right: var(--theia-ui-padding);\n  width: var(--theia-icon-size);\n  height: var(--theia-content-line-height);\n  line-height: inherit !important;\n  display: inline-block;\n}\n\n.lm-TabBar.theia-app-sides .theia-plugin-file-icon,\n.lm-TabBar.theia-app-sides .theia-plugin-file-icon::before,\n.lm-TabBar.theia-app-sides .theia-plugin-folder-icon,\n.lm-TabBar.theia-app-sides .theia-plugin-folder-icon::before,\n.lm-TabBar.theia-app-sides .theia-plugin-folder-expanded-icon,\n.lm-TabBar.theia-app-sides .theia-plugin-folder-expanded-icon::before,\n.lm-TabBar.theia-app-sides .theia-plugin-root-folder-icon,\n.lm-TabBar.theia-app-sides .theia-plugin-root-folder-icon::before,\n.lm-TabBar.theia-app-sides .theia-plugin-root-folder-expanded-icon,\n.lm-TabBar.theia-app-sides .theia-plugin-root-folder-expanded-icon::before {\n  padding: 0px !important;\n  width: var(--theia-private-sidebar-icon-size) !important;\n  height: var(--theia-private-sidebar-icon-size) !important;\n  background-size: var(--theia-private-sidebar-icon-size) !important;\n  font-size: var(--theia-private-sidebar-icon-size) !important;\n}\n\n@import \"./plugin-sidebar.css\";\n@import \"./webview.css\";\n@import \"./tree.css\";\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ },

/***/ "../../node_modules/css-loader/dist/cjs.js!../../node_modules/@theia/plugin-ext/src/main/browser/style/plugin-sidebar.css"
/*!********************************************************************************************************************************!*\
  !*** ../../node_modules/css-loader/dist/cjs.js!../../node_modules/@theia/plugin-ext/src/main/browser/style/plugin-sidebar.css ***!
  \********************************************************************************************************************************/
(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../../css-loader/dist/runtime/sourceMaps.js */ "../../node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../../css-loader/dist/runtime/api.js */ "../../node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/********************************************************************************
 * Copyright (C) 2018 Red Hat, Inc. and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
 ********************************************************************************/

.theia-plugins {
  min-width: 250px !important;
  display: flex;
  flex-direction: column;
}

#pluginListContainer {
  width: 100%;
  box-sizing: border-box;
  overflow-y: auto;
  flex-grow: 1;
}

.theia-plugins .pluginHeaderContainer {
  padding: 5px 15px;
  font-size: var(--theia-ui-font-size0);
}

.theia-side-panel .theia-plugins .pluginHeaderContainer {
  padding-left: 20px;
}

.theia-plugins .pluginHeaderContainer:hover {
  background: var(--theia-list-hoverBackground);
}

.theia-plugins .pluginHeaderContainer .row {
  margin: 3px 0;
}

.theia-plugins .pluginName {
  flex: 1;
  margin-right: 5px;
  margin-left: 4px;
  font-size: var(--theia-ui-font-size1);
  font-weight: 400;
}

.theia-plugins .pluginVersion {
  flex: 1;
  text-align: left;
  font-size: var(--theia-ui-font-size0);
}

.theia-plugins .pluginDescription {
  flex: 1;
}

.theia-plugins .pluginPublisher {
  font-size: var(--theia-ui-font-size0);
  flex: 5;
  align-items: center;
}

.plugins-tab-icon::before {
  content: "\\f0fe";
}
`, "",{"version":3,"sources":["webpack://./../../node_modules/@theia/plugin-ext/src/main/browser/style/plugin-sidebar.css"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;iFAciF;;AAEjF;EACE,2BAA2B;EAC3B,aAAa;EACb,sBAAsB;AACxB;;AAEA;EACE,WAAW;EACX,sBAAsB;EACtB,gBAAgB;EAChB,YAAY;AACd;;AAEA;EACE,iBAAiB;EACjB,qCAAqC;AACvC;;AAEA;EACE,kBAAkB;AACpB;;AAEA;EACE,6CAA6C;AAC/C;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,OAAO;EACP,iBAAiB;EACjB,gBAAgB;EAChB,qCAAqC;EACrC,gBAAgB;AAClB;;AAEA;EACE,OAAO;EACP,gBAAgB;EAChB,qCAAqC;AACvC;;AAEA;EACE,OAAO;AACT;;AAEA;EACE,qCAAqC;EACrC,OAAO;EACP,mBAAmB;AACrB;;AAEA;EACE,gBAAgB;AAClB","sourcesContent":["/********************************************************************************\n * Copyright (C) 2018 Red Hat, Inc. and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0\n ********************************************************************************/\n\n.theia-plugins {\n  min-width: 250px !important;\n  display: flex;\n  flex-direction: column;\n}\n\n#pluginListContainer {\n  width: 100%;\n  box-sizing: border-box;\n  overflow-y: auto;\n  flex-grow: 1;\n}\n\n.theia-plugins .pluginHeaderContainer {\n  padding: 5px 15px;\n  font-size: var(--theia-ui-font-size0);\n}\n\n.theia-side-panel .theia-plugins .pluginHeaderContainer {\n  padding-left: 20px;\n}\n\n.theia-plugins .pluginHeaderContainer:hover {\n  background: var(--theia-list-hoverBackground);\n}\n\n.theia-plugins .pluginHeaderContainer .row {\n  margin: 3px 0;\n}\n\n.theia-plugins .pluginName {\n  flex: 1;\n  margin-right: 5px;\n  margin-left: 4px;\n  font-size: var(--theia-ui-font-size1);\n  font-weight: 400;\n}\n\n.theia-plugins .pluginVersion {\n  flex: 1;\n  text-align: left;\n  font-size: var(--theia-ui-font-size0);\n}\n\n.theia-plugins .pluginDescription {\n  flex: 1;\n}\n\n.theia-plugins .pluginPublisher {\n  font-size: var(--theia-ui-font-size0);\n  flex: 5;\n  align-items: center;\n}\n\n.plugins-tab-icon::before {\n  content: \"\\f0fe\";\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ },

/***/ "../../node_modules/css-loader/dist/cjs.js!../../node_modules/@theia/plugin-ext/src/main/browser/style/tree.css"
/*!**********************************************************************************************************************!*\
  !*** ../../node_modules/css-loader/dist/cjs.js!../../node_modules/@theia/plugin-ext/src/main/browser/style/tree.css ***!
  \**********************************************************************************************************************/
(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../../css-loader/dist/runtime/sourceMaps.js */ "../../node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../../css-loader/dist/runtime/api.js */ "../../node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/********************************************************************************
 * Copyright (C) 2018 Red Hat, Inc. and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
 ********************************************************************************/

.theia-tree-view-icon {
  padding-right: var(--theia-ui-padding);
  -webkit-font-smoothing: antialiased;
  flex-shrink: 0;
  padding-left: 6px;
  margin-left: -6px;
}

.theia-tree-view-inline-action {
  padding: 2px;
}

.theia-tree-view-description {
  color: var(--theia-descriptionForeground);
  font-size: var(--theia-ui-font-size0);
  margin-left: var(--theia-ui-padding);
}

.theia-tree-view .theia-TreeNodeContent {
  align-items: center;
  height: 100%;
}

.theia-tree-view .theia-TreeContainer .theia-TreeViewInfo {
  margin-top: 7px;
  margin-bottom: 10px;
  margin-left: 17px;
}

.theia-tree-view
  .theia-TreeNode:not(:hover):not(.theia-mod-selected)
  .theia-tree-view-inline-action {
  display: none;
}

.codicon.icon-inline {
  font-size: var(--theia-ui-font-size1);
}
`, "",{"version":3,"sources":["webpack://./../../node_modules/@theia/plugin-ext/src/main/browser/style/tree.css"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;iFAciF;;AAEjF;EACE,sCAAsC;EACtC,mCAAmC;EACnC,cAAc;EACd,iBAAiB;EACjB,iBAAiB;AACnB;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,yCAAyC;EACzC,qCAAqC;EACrC,oCAAoC;AACtC;;AAEA;EACE,mBAAmB;EACnB,YAAY;AACd;;AAEA;EACE,eAAe;EACf,mBAAmB;EACnB,iBAAiB;AACnB;;AAEA;;;EAGE,aAAa;AACf;;AAEA;EACE,qCAAqC;AACvC","sourcesContent":["/********************************************************************************\n * Copyright (C) 2018 Red Hat, Inc. and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0\n ********************************************************************************/\n\n.theia-tree-view-icon {\n  padding-right: var(--theia-ui-padding);\n  -webkit-font-smoothing: antialiased;\n  flex-shrink: 0;\n  padding-left: 6px;\n  margin-left: -6px;\n}\n\n.theia-tree-view-inline-action {\n  padding: 2px;\n}\n\n.theia-tree-view-description {\n  color: var(--theia-descriptionForeground);\n  font-size: var(--theia-ui-font-size0);\n  margin-left: var(--theia-ui-padding);\n}\n\n.theia-tree-view .theia-TreeNodeContent {\n  align-items: center;\n  height: 100%;\n}\n\n.theia-tree-view .theia-TreeContainer .theia-TreeViewInfo {\n  margin-top: 7px;\n  margin-bottom: 10px;\n  margin-left: 17px;\n}\n\n.theia-tree-view\n  .theia-TreeNode:not(:hover):not(.theia-mod-selected)\n  .theia-tree-view-inline-action {\n  display: none;\n}\n\n.codicon.icon-inline {\n  font-size: var(--theia-ui-font-size1);\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ },

/***/ "../../node_modules/css-loader/dist/cjs.js!../../node_modules/@theia/plugin-ext/src/main/browser/style/webview.css"
/*!*************************************************************************************************************************!*\
  !*** ../../node_modules/css-loader/dist/cjs.js!../../node_modules/@theia/plugin-ext/src/main/browser/style/webview.css ***!
  \*************************************************************************************************************************/
(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../../css-loader/dist/runtime/sourceMaps.js */ "../../node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../../css-loader/dist/runtime/api.js */ "../../node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/********************************************************************************
 * Copyright (C) 2018 Red Hat, Inc. and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
 ********************************************************************************/

.theia-webview.lm-mod-hidden {
  visibility: hidden;
  display: flex !important;
}

.theia-webview {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.theia-webview iframe {
  flex-grow: 1;
  border: none;
  margin: 0;
  padding: 0;
}

.theia-webview-icon {
  background: none !important;
  min-height: 20px;
}

.theia-webview-icon::before {
  background-size: 13px;
  background-repeat: no-repeat;
  vertical-align: middle;
  display: inline-block;
  text-align: center;
  height: 15px;
  width: 15px;
  content: "";
}

.lm-TabBar.theia-app-sides .theia-webview-icon::before {
  width: var(--theia-private-sidebar-icon-size);
  height: var(--theia-private-sidebar-icon-size);
  background-size: contain;
}
`, "",{"version":3,"sources":["webpack://./../../node_modules/@theia/plugin-ext/src/main/browser/style/webview.css"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;iFAciF;;AAEjF;EACE,kBAAkB;EAClB,wBAAwB;AAC1B;;AAEA;EACE,aAAa;EACb,sBAAsB;EACtB,YAAY;AACd;;AAEA;EACE,YAAY;EACZ,YAAY;EACZ,SAAS;EACT,UAAU;AACZ;;AAEA;EACE,2BAA2B;EAC3B,gBAAgB;AAClB;;AAEA;EACE,qBAAqB;EACrB,4BAA4B;EAC5B,sBAAsB;EACtB,qBAAqB;EACrB,kBAAkB;EAClB,YAAY;EACZ,WAAW;EACX,WAAW;AACb;;AAEA;EACE,6CAA6C;EAC7C,8CAA8C;EAC9C,wBAAwB;AAC1B","sourcesContent":["/********************************************************************************\n * Copyright (C) 2018 Red Hat, Inc. and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0\n ********************************************************************************/\n\n.theia-webview.lm-mod-hidden {\n  visibility: hidden;\n  display: flex !important;\n}\n\n.theia-webview {\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n}\n\n.theia-webview iframe {\n  flex-grow: 1;\n  border: none;\n  margin: 0;\n  padding: 0;\n}\n\n.theia-webview-icon {\n  background: none !important;\n  min-height: 20px;\n}\n\n.theia-webview-icon::before {\n  background-size: 13px;\n  background-repeat: no-repeat;\n  vertical-align: middle;\n  display: inline-block;\n  text-align: center;\n  height: 15px;\n  width: 15px;\n  content: \"\";\n}\n\n.lm-TabBar.theia-app-sides .theia-webview-icon::before {\n  width: var(--theia-private-sidebar-icon-size);\n  height: var(--theia-private-sidebar-icon-size);\n  background-size: contain;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ },

/***/ "../../node_modules/css-loader/dist/cjs.js!../../node_modules/@theia/plugin-ext/src/main/style/status-bar.css"
/*!********************************************************************************************************************!*\
  !*** ../../node_modules/css-loader/dist/cjs.js!../../node_modules/@theia/plugin-ext/src/main/style/status-bar.css ***!
  \********************************************************************************************************************/
(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../css-loader/dist/runtime/sourceMaps.js */ "../../node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../css-loader/dist/runtime/api.js */ "../../node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/********************************************************************************
 * Copyright (C) 2018 Red Hat, Inc. and others.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the Eclipse
 * Public License v. 2.0 are satisfied: GNU General Public License, version 2
 * with the GNU Classpath Exception which is available at
 * https://www.gnu.org/software/classpath/license.html.
 *
 * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
 ********************************************************************************/

#theia-statusBar .development-host {
  background-color: var(--theia-successBackground);
}

#theia-statusBar .development-host-offline {
  background-color: var(--theia-errorBackground);
}

#theia-statusBar .hosted-plugin {
  background-color: var(--theia-inputValidation-infoBackground);
}

#theia-statusBar .hosted-plugin:hover {
  background-color: var(--theia-editorInfo-foreground);
}

#theia-statusBar .hosted-plugin-failed {
  background-color: var(--theia-errorBackground);
}
`, "",{"version":3,"sources":["webpack://./../../node_modules/@theia/plugin-ext/src/main/style/status-bar.css"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;iFAciF;;AAEjF;EACE,gDAAgD;AAClD;;AAEA;EACE,8CAA8C;AAChD;;AAEA;EACE,6DAA6D;AAC/D;;AAEA;EACE,oDAAoD;AACtD;;AAEA;EACE,8CAA8C;AAChD","sourcesContent":["/********************************************************************************\n * Copyright (C) 2018 Red Hat, Inc. and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0\n ********************************************************************************/\n\n#theia-statusBar .development-host {\n  background-color: var(--theia-successBackground);\n}\n\n#theia-statusBar .development-host-offline {\n  background-color: var(--theia-errorBackground);\n}\n\n#theia-statusBar .hosted-plugin {\n  background-color: var(--theia-inputValidation-infoBackground);\n}\n\n#theia-statusBar .hosted-plugin:hover {\n  background-color: var(--theia-editorInfo-foreground);\n}\n\n#theia-statusBar .hosted-plugin-failed {\n  background-color: var(--theia-errorBackground);\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }

}]);
//# sourceMappingURL=vendors-node_modules_theia_plugin-ext_lib_plugin-ext-frontend-module_js.js.map