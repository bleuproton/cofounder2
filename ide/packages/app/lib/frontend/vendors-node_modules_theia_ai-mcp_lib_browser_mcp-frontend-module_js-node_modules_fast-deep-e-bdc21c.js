"use strict";
(self["webpackChunkcofounder_theia_app"] = self["webpackChunkcofounder_theia_app"] || []).push([["vendors-node_modules_theia_ai-mcp_lib_browser_mcp-frontend-module_js-node_modules_fast-deep-e-bdc21c"],{

/***/ "../../node_modules/@theia/ai-mcp/lib/browser/mcp-frontend-application-contribution.js"
/*!*********************************************************************************************!*\
  !*** ../../node_modules/@theia/ai-mcp/lib/browser/mcp-frontend-application-contribution.js ***!
  \*********************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {


// *****************************************************************************
// Copyright (C) 2024 EclipseSource GmbH.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.McpFrontendApplicationContribution = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const common_1 = __webpack_require__(/*! ../common */ "../../node_modules/@theia/ai-mcp/lib/common/index.js");
const mcp_preferences_1 = __webpack_require__(/*! ../common/mcp-preferences */ "../../node_modules/@theia/ai-mcp/lib/common/mcp-preferences.js");
const mcp_server_manager_1 = __webpack_require__(/*! ../common/mcp-server-manager */ "../../node_modules/@theia/ai-mcp/lib/common/mcp-server-manager.js");
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
;
var MCPServersPreference;
(function (MCPServersPreference) {
    function isValue(obj) {
        return !!obj && typeof obj === 'object' &&
            ('command' in obj || 'serverUrl' in obj) &&
            (!('command' in obj) || typeof obj.command === 'string') &&
            (!('args' in obj) || Array.isArray(obj.args) && obj.args.every(arg => typeof arg === 'string')) &&
            (!('env' in obj) || !!obj.env && typeof obj.env === 'object' && Object.values(obj.env).every(value => typeof value === 'string')) &&
            (!('autostart' in obj) || typeof obj.autostart === 'boolean') &&
            (!('serverUrl' in obj) || typeof obj.serverUrl === 'string') &&
            (!('serverAuthToken' in obj) || typeof obj.serverAuthToken === 'string') &&
            (!('serverAuthTokenHeader' in obj) || typeof obj.serverAuthTokenHeader === 'string') &&
            (!('headers' in obj) || !!obj.headers && typeof obj.headers === 'object' && Object.values(obj.headers).every(value => typeof value === 'string'));
    }
    MCPServersPreference.isValue = isValue;
})(MCPServersPreference || (MCPServersPreference = {}));
function filterValidValues(servers) {
    const result = {};
    if (!servers || typeof servers !== 'object') {
        return result;
    }
    for (const [name, value] of Object.entries(servers)) {
        if (typeof name === 'string' && MCPServersPreference.isValue(value)) {
            result[name] = value;
        }
    }
    return result;
}
let McpFrontendApplicationContribution = class McpFrontendApplicationContribution {
    constructor() {
        this.prevServers = new Map();
    }
    onStart() {
        this.preferenceService.ready.then(() => {
            const servers = filterValidValues(this.preferenceService.get(mcp_preferences_1.MCP_SERVERS_PREF, {}));
            this.prevServers = this.convertToMap(servers);
            this.syncServers(this.prevServers);
            this.autoStartServers(this.prevServers);
            this.preferenceService.onPreferenceChanged(event => {
                if (event.preferenceName === mcp_preferences_1.MCP_SERVERS_PREF) {
                    this.handleServerChanges(filterValidValues(event.newValue));
                }
            });
        });
        this.frontendMCPService.registerToolsForAllStartedServers();
    }
    async autoStartServers(servers) {
        const startedServers = await this.frontendMCPService.getStartedServers();
        for (const [name, serverDesc] of servers) {
            if (serverDesc && serverDesc.autostart) {
                if (!startedServers.includes(name)) {
                    await this.frontendMCPService.startServer(name);
                }
            }
        }
    }
    handleServerChanges(newServers) {
        const oldServers = this.prevServers;
        const updatedServers = this.convertToMap(newServers);
        for (const [name] of oldServers) {
            if (!updatedServers.has(name)) {
                this.manager.removeServer(name);
            }
        }
        for (const [name, description] of updatedServers) {
            const oldDescription = oldServers.get(name);
            let diff = false;
            try {
                // We know that that the descriptions are actual JSONObjects as we construct them ourselves
                if (!oldDescription || !core_1.PreferenceUtils.deepEqual(oldDescription, description)) {
                    diff = true;
                }
            }
            catch (e) {
                // In some cases the deepEqual function throws an error, so we fall back to assuming that there is a difference
                // This seems to happen in cases where the objects are structured differently, e.g. whole sub-objects are missing
                console.debug('Failed to compare MCP server descriptions, assuming a difference', e);
                diff = true;
            }
            if (diff) {
                this.manager.addOrUpdateServer(description);
            }
        }
        this.prevServers = updatedServers;
    }
    syncServers(servers) {
        for (const [, description] of servers) {
            this.manager.addOrUpdateServer(description);
        }
        for (const [name] of this.prevServers) {
            if (!servers.has(name)) {
                this.manager.removeServer(name);
            }
        }
    }
    convertToMap(servers) {
        const map = new Map();
        Object.entries(servers).forEach(([name, description]) => {
            let filteredDescription;
            if ('serverUrl' in description) {
                // Create RemoteMCPServerDescription by picking only remote-specific properties
                const { serverUrl, serverAuthToken, serverAuthTokenHeader, headers, autostart } = description;
                filteredDescription = {
                    name,
                    serverUrl,
                    ...(serverAuthToken && { serverAuthToken }),
                    ...(serverAuthTokenHeader && { serverAuthTokenHeader }),
                    ...(headers && { headers }),
                    autostart: autostart !== null && autostart !== void 0 ? autostart : true,
                };
            }
            else {
                // Create LocalMCPServerDescription by picking only local-specific properties
                const { command, args, env, autostart } = description;
                filteredDescription = {
                    name,
                    command,
                    ...(args && { args }),
                    ...(env && { env }),
                    autostart: autostart !== null && autostart !== void 0 ? autostart : true,
                };
            }
            map.set(name, filteredDescription);
        });
        return map;
    }
};
exports.McpFrontendApplicationContribution = McpFrontendApplicationContribution;
tslib_1.__decorate([
    (0, inversify_1.inject)(core_1.PreferenceService),
    tslib_1.__metadata("design:type", Object)
], McpFrontendApplicationContribution.prototype, "preferenceService", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(common_1.MCPServerManager),
    tslib_1.__metadata("design:type", Object)
], McpFrontendApplicationContribution.prototype, "manager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(mcp_server_manager_1.MCPFrontendService),
    tslib_1.__metadata("design:type", Object)
], McpFrontendApplicationContribution.prototype, "frontendMCPService", void 0);
exports.McpFrontendApplicationContribution = McpFrontendApplicationContribution = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], McpFrontendApplicationContribution);


/***/ },

/***/ "../../node_modules/@theia/ai-mcp/lib/browser/mcp-frontend-module.js"
/*!***************************************************************************!*\
  !*** ../../node_modules/@theia/ai-mcp/lib/browser/mcp-frontend-module.js ***!
  \***************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {


// *****************************************************************************
// Copyright (C) 2024 EclipseSource GmbH.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const browser_1 = __webpack_require__(/*! @theia/core/lib/browser */ "../../node_modules/@theia/core/lib/browser/index.js");
const mcp_server_manager_1 = __webpack_require__(/*! ../common/mcp-server-manager */ "../../node_modules/@theia/ai-mcp/lib/common/mcp-server-manager.js");
const mcp_frontend_application_contribution_1 = __webpack_require__(/*! ./mcp-frontend-application-contribution */ "../../node_modules/@theia/ai-mcp/lib/browser/mcp-frontend-application-contribution.js");
const mcp_frontend_service_1 = __webpack_require__(/*! ./mcp-frontend-service */ "../../node_modules/@theia/ai-mcp/lib/browser/mcp-frontend-service.js");
const mcp_frontend_notification_service_1 = __webpack_require__(/*! ./mcp-frontend-notification-service */ "../../node_modules/@theia/ai-mcp/lib/browser/mcp-frontend-notification-service.js");
const mcp_server_manager_server_client_1 = __webpack_require__(/*! ./mcp-server-manager-server-client */ "../../node_modules/@theia/ai-mcp/lib/browser/mcp-server-manager-server-client.js");
const mcp_protocol_1 = __webpack_require__(/*! ../common/mcp-protocol */ "../../node_modules/@theia/ai-mcp/lib/common/mcp-protocol.js");
exports["default"] = new inversify_1.ContainerModule(bind => {
    bind(browser_1.FrontendApplicationContribution).to(mcp_frontend_application_contribution_1.McpFrontendApplicationContribution).inSingletonScope();
    bind(mcp_server_manager_1.MCPFrontendService).to(mcp_frontend_service_1.MCPFrontendServiceImpl).inSingletonScope();
    bind(mcp_server_manager_1.MCPFrontendNotificationService).to(mcp_frontend_notification_service_1.MCPFrontendNotificationServiceImpl).inSingletonScope();
    bind(mcp_protocol_1.MCPServerManagerServerClient).to(mcp_server_manager_server_client_1.MCPServerManagerServerClientImpl).inSingletonScope();
    bind(mcp_protocol_1.MCPServerManagerServer).toDynamicValue(ctx => {
        const connection = ctx.container.get(browser_1.RemoteConnectionProvider);
        const client = ctx.container.get(mcp_protocol_1.MCPServerManagerServerClient);
        return connection.createProxy(mcp_protocol_1.MCPServerManagerServerPath, client);
    }).inSingletonScope();
    bind(mcp_server_manager_1.MCPServerManager).toDynamicValue(ctx => {
        const mgrServer = ctx.container.get(mcp_protocol_1.MCPServerManagerServer);
        const connection = ctx.container.get(browser_1.RemoteConnectionProvider);
        const client = ctx.container.get(mcp_server_manager_1.MCPFrontendNotificationService);
        const serverClient = ctx.container.get(mcp_protocol_1.MCPServerManagerServerClient);
        const backendServerManager = connection.createProxy(mcp_server_manager_1.MCPServerManagerPath, client);
        // Listen to server updates to clean up removed servers
        client.onDidUpdateMCPServers(() => backendServerManager.getServerNames()
            .then(names => serverClient.cleanServers(names))
            .catch((error) => {
            console.error('Error cleaning server descriptions:', error);
        }));
        // We proxy the MCPServerManager to override addOrUpdateServer and getServerDescription
        // to handle the resolve functions via the MCPServerManagerServerClient.
        return new Proxy(backendServerManager, {
            get(target, prop, receiver) {
                // override addOrUpdateServer to store the original description in the MCPServerManagerServerClient
                // to be used in resolveServerDescription if a resolve function is provided
                if (prop === 'addOrUpdateServer') {
                    return async function (...args) {
                        const updated = serverClient.addServerDescription(args[0]);
                        await mgrServer.addOrUpdateServer(updated);
                    };
                }
                // override getServerDescription to mix in the resolve function from the client
                if (prop === 'getServerDescription') {
                    return async function (name) {
                        const description = await Reflect.apply(target.getServerDescription, target, [name]);
                        if (description) {
                            const resolveFunction = serverClient.getResolveFunction(name);
                            if (resolveFunction) {
                                return {
                                    ...description,
                                    resolve: resolveFunction
                                };
                            }
                        }
                        return description;
                    };
                }
                return Reflect.get(target, prop, receiver);
            }
        });
    }).inSingletonScope();
});


/***/ },

/***/ "../../node_modules/@theia/ai-mcp/lib/browser/mcp-frontend-notification-service.js"
/*!*****************************************************************************************!*\
  !*** ../../node_modules/@theia/ai-mcp/lib/browser/mcp-frontend-notification-service.js ***!
  \*****************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {


// *****************************************************************************
// Copyright (C) 2025 EclipseSource GmbH.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MCPFrontendNotificationServiceImpl = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const event_1 = __webpack_require__(/*! @theia/core/lib/common/event */ "../../node_modules/@theia/core/lib/common/event.js");
let MCPFrontendNotificationServiceImpl = class MCPFrontendNotificationServiceImpl {
    constructor() {
        this.onDidUpdateMCPServersEmitter = new event_1.Emitter();
        this.onDidUpdateMCPServers = this.onDidUpdateMCPServersEmitter.event;
    }
    didUpdateMCPServers() {
        this.onDidUpdateMCPServersEmitter.fire();
    }
};
exports.MCPFrontendNotificationServiceImpl = MCPFrontendNotificationServiceImpl;
exports.MCPFrontendNotificationServiceImpl = MCPFrontendNotificationServiceImpl = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], MCPFrontendNotificationServiceImpl);


/***/ },

/***/ "../../node_modules/@theia/ai-mcp/lib/browser/mcp-frontend-service.js"
/*!****************************************************************************!*\
  !*** ../../node_modules/@theia/ai-mcp/lib/browser/mcp-frontend-service.js ***!
  \****************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MCPFrontendServiceImpl = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
// *****************************************************************************
// Copyright (C) 2024 EclipseSource GmbH.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const mcp_server_manager_1 = __webpack_require__(/*! ../common/mcp-server-manager */ "../../node_modules/@theia/ai-mcp/lib/common/mcp-server-manager.js");
const ai_core_1 = __webpack_require__(/*! @theia/ai-core */ "../../node_modules/@theia/ai-core/lib/common/index.js");
let MCPFrontendServiceImpl = class MCPFrontendServiceImpl {
    async startServer(serverName) {
        await this.mcpServerManager.startServer(serverName);
        await this.registerTools(serverName);
    }
    async hasServer(serverName) {
        const serverNames = await this.getServerNames();
        return serverNames.includes(serverName);
    }
    async isServerStarted(serverName) {
        const startedServers = await this.getStartedServers();
        return startedServers.includes(serverName);
    }
    async registerToolsForAllStartedServers() {
        const startedServers = await this.getStartedServers();
        for (const serverName of startedServers) {
            await this.registerTools(serverName);
        }
    }
    async registerTools(serverName) {
        const returnedTools = await this.getTools(serverName);
        if (returnedTools) {
            const toolRequests = returnedTools.tools.map(tool => this.convertToToolRequest(tool, serverName));
            toolRequests.forEach(toolRequest => this.toolInvocationRegistry.registerTool(toolRequest));
            this.createPromptTemplate(serverName, toolRequests);
        }
    }
    getPromptTemplateId(serverName) {
        return `mcp_${serverName}_tools`;
    }
    createPromptTemplate(serverName, toolRequests) {
        const templateId = this.getPromptTemplateId(serverName);
        const functionIds = toolRequests.map(tool => `~{${tool.id}}`);
        const template = functionIds.join('\n');
        this.promptService.addBuiltInPromptFragment({
            id: templateId,
            template
        });
    }
    async stopServer(serverName) {
        this.toolInvocationRegistry.unregisterAllTools(`mcp_${serverName}`);
        this.promptService.removePromptFragment(this.getPromptTemplateId(serverName));
        await this.mcpServerManager.stopServer(serverName);
    }
    getStartedServers() {
        return this.mcpServerManager.getRunningServers();
    }
    getServerNames() {
        return this.mcpServerManager.getServerNames();
    }
    async getServerDescription(name) {
        return this.mcpServerManager.getServerDescription(name);
    }
    async getTools(serverName) {
        try {
            return await this.mcpServerManager.getTools(serverName);
        }
        catch (error) {
            console.error('Error while trying to get tools: ' + error);
            return undefined;
        }
    }
    async addOrUpdateServer(description) {
        return this.mcpServerManager.addOrUpdateServer(description);
    }
    convertToToolRequest(tool, serverName) {
        const id = `mcp_${serverName}_${tool.name}`;
        return {
            id: id,
            name: id,
            providerName: `mcp_${serverName}`,
            parameters: ai_core_1.ToolRequest.isToolRequestParameters(tool.inputSchema) ? {
                type: tool.inputSchema.type,
                properties: tool.inputSchema.properties,
                required: tool.inputSchema.required
            } : {
                type: 'object',
                properties: {}
            },
            description: tool.description,
            handler: async (arg_string) => {
                var _a;
                try {
                    const result = await this.mcpServerManager.callTool(serverName, tool.name, arg_string);
                    if (result.isError) {
                        const textContent = result.content.find(callContent => callContent.type === 'text');
                        return { content: [{ type: 'error', data: (_a = textContent === null || textContent === void 0 ? void 0 : textContent.text) !== null && _a !== void 0 ? _a : 'Unknown Error' }] };
                    }
                    const content = result.content.map(callContent => {
                        switch (callContent.type) {
                            case 'image':
                                return { type: 'image', base64data: callContent.data, mimeType: callContent.mimeType };
                            case 'text':
                                return { type: 'text', text: callContent.text };
                            case 'resource': {
                                return { type: 'text', text: JSON.stringify(callContent.resource) };
                            }
                            default: {
                                return { type: 'text', text: JSON.stringify(callContent) };
                            }
                        }
                    });
                    return { content };
                }
                catch (error) {
                    console.error(`Error in tool handler for ${tool.name} on MCP server ${serverName}:`, error);
                    throw error;
                }
            },
        };
    }
};
exports.MCPFrontendServiceImpl = MCPFrontendServiceImpl;
tslib_1.__decorate([
    (0, inversify_1.inject)(mcp_server_manager_1.MCPServerManager),
    tslib_1.__metadata("design:type", Object)
], MCPFrontendServiceImpl.prototype, "mcpServerManager", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(ai_core_1.ToolInvocationRegistry),
    tslib_1.__metadata("design:type", Object)
], MCPFrontendServiceImpl.prototype, "toolInvocationRegistry", void 0);
tslib_1.__decorate([
    (0, inversify_1.inject)(ai_core_1.PromptService),
    tslib_1.__metadata("design:type", Object)
], MCPFrontendServiceImpl.prototype, "promptService", void 0);
exports.MCPFrontendServiceImpl = MCPFrontendServiceImpl = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], MCPFrontendServiceImpl);


/***/ },

/***/ "../../node_modules/@theia/ai-mcp/lib/browser/mcp-server-manager-server-client.js"
/*!****************************************************************************************!*\
  !*** ../../node_modules/@theia/ai-mcp/lib/browser/mcp-server-manager-server-client.js ***!
  \****************************************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {


// *****************************************************************************
// Copyright (C) 2025 Dirk Fauth and others.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MCPServerManagerServerClientImpl = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
const inversify_1 = __webpack_require__(/*! @theia/core/shared/inversify */ "../../node_modules/@theia/core/shared/inversify/index.js");
const uuid_1 = __webpack_require__(/*! @theia/core/lib/common/uuid */ "../../node_modules/@theia/core/lib/common/uuid.js");
const mcp_protocol_1 = __webpack_require__(/*! ../common/mcp-protocol */ "../../node_modules/@theia/ai-mcp/lib/common/mcp-protocol.js");
let MCPServerManagerServerClientImpl = class MCPServerManagerServerClientImpl {
    constructor() {
        this.serverDescriptions = new Map();
    }
    addServerDescription(description) {
        if (description.resolve) {
            const serverDescription = {
                ...description,
                resolveId: (0, uuid_1.generateUuid)(),
            };
            // store only the name and resolve function
            if (serverDescription.resolveId) {
                this.serverDescriptions.set(serverDescription.resolveId, {
                    name: description.name,
                    resolve: description.resolve
                });
            }
            return serverDescription;
        }
        return description;
    }
    getResolveFunction(name) {
        for (const storedInfo of this.serverDescriptions.values()) {
            if (storedInfo.name === name) {
                return storedInfo.resolve;
            }
        }
        return undefined;
    }
    async resolveServerDescription(description) {
        const cleanDescription = (0, mcp_protocol_1.cleanServerDescription)(description);
        if (description.resolveId) {
            const storedInfo = this.serverDescriptions.get(description.resolveId);
            if (storedInfo === null || storedInfo === void 0 ? void 0 : storedInfo.resolve) {
                const updated = await storedInfo.resolve(cleanDescription);
                if (updated) {
                    return updated;
                }
            }
        }
        return cleanDescription;
    }
    cleanServers(serverNames) {
        const currentNamesSet = new Set(serverNames);
        // Remove descriptions for servers that no longer exist
        for (const [resolveId, storedInfo] of this.serverDescriptions.entries()) {
            if (storedInfo.name && !currentNamesSet.has(storedInfo.name)) {
                console.debug('Removing a frontend stored resolve function because the corresponding MCP server was removed', storedInfo);
                this.serverDescriptions.delete(resolveId);
            }
        }
    }
};
exports.MCPServerManagerServerClientImpl = MCPServerManagerServerClientImpl;
exports.MCPServerManagerServerClientImpl = MCPServerManagerServerClientImpl = tslib_1.__decorate([
    (0, inversify_1.injectable)()
], MCPServerManagerServerClientImpl);


/***/ },

/***/ "../../node_modules/@theia/ai-mcp/lib/common/index.js"
/*!************************************************************!*\
  !*** ../../node_modules/@theia/ai-mcp/lib/common/index.js ***!
  \************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.mjs");
// *****************************************************************************
// Copyright (C) 2024 EclipseSource GmbH.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
tslib_1.__exportStar(__webpack_require__(/*! ./mcp-server-manager */ "../../node_modules/@theia/ai-mcp/lib/common/mcp-server-manager.js"), exports);


/***/ },

/***/ "../../node_modules/@theia/ai-mcp/lib/common/mcp-preferences.js"
/*!**********************************************************************!*\
  !*** ../../node_modules/@theia/ai-mcp/lib/common/mcp-preferences.js ***!
  \**********************************************************************/
(__unused_webpack_module, exports, __webpack_require__) {


// *****************************************************************************
// Copyright (C) 2024 EclipseSource GmbH.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.McpServersPreferenceSchema = exports.MCP_SERVERS_PREF = void 0;
const core_1 = __webpack_require__(/*! @theia/core */ "../../node_modules/@theia/core/lib/common/index.js");
exports.MCP_SERVERS_PREF = 'ai-features.mcp.mcpServers';
exports.McpServersPreferenceSchema = {
    properties: {
        [exports.MCP_SERVERS_PREF]: {
            type: 'object',
            title: core_1.nls.localize('theia/ai/mcp/servers/title', 'MCP Server Configuration'),
            markdownDescription: core_1.nls.localize('theia/ai/mcp/servers/mdDescription', 'Configure MCP servers either local with command, \
arguments and optionally environment variables, \
or remote with server URL, authentication token and optionally an authentication header name. Additionally it is possible to configure autostart (true by default). \
Each server is identified by a unique key, such as "brave-search" or "filesystem". \
To start a server, use the "MCP: Start MCP Server" command, which enables you to select the desired server. \
To stop a server, use the "MCP: Stop MCP Server" command. \
Please note that autostart will only take effect after a restart, you need to start a server manually for the first time.\
\n\
Example configuration:\n\
```\
{\n\
  "brave-search": {\n\
    "command": "npx",\n\
    "args": [\n\
      "-y",\n\
      "@modelcontextprotocol/server-brave-search"\n\
    ],\n\
    "env": {\n\
      "BRAVE_API_KEY": "YOUR_API_KEY"\n\
    },\n\
  },\n\
  "filesystem": {\n\
    "command": "npx",\n\
    "args": ["-y", "@modelcontextprotocol/server-filesystem", "/Users/YOUR_USERNAME/Desktop"],\n\
    "env": {\n\
      "CUSTOM_ENV_VAR": "custom-value"\n\
    },\n\
    "autostart": false\n\
  },\n\
  "jira": {\n\
    "serverUrl": "YOUR_JIRA_MCP_SERVER_URL",\n\
    "serverAuthToken": "YOUR_JIRA_MCP_SERVER_TOKEN"\n\
  }\n\
}\n```'),
            additionalProperties: {
                type: 'object',
                properties: {
                    command: {
                        type: 'string',
                        title: core_1.nls.localize('theia/ai/mcp/servers/command/title', 'Command to execute the MCP server'),
                        markdownDescription: core_1.nls.localize('theia/ai/mcp/servers/command/mdDescription', 'The command used to start the MCP server, e.g., "uvx" or "npx".')
                    },
                    args: {
                        type: 'array',
                        title: core_1.nls.localize('theia/ai/mcp/servers/args/title', 'Arguments for the command'),
                        markdownDescription: core_1.nls.localize('theia/ai/mcp/servers/args/mdDescription', 'An array of arguments to pass to the command.'),
                    },
                    env: {
                        type: 'object',
                        title: core_1.nls.localize('theia/ai/mcp/servers/env/title', 'Environment variables'),
                        markdownDescription: core_1.nls.localize('theia/ai/mcp/servers/env/mdDescription', 'Optional environment variables to set for the server, such as an API key.'),
                        additionalProperties: {
                            type: 'string'
                        }
                    },
                    autostart: {
                        type: 'boolean',
                        title: core_1.nls.localize('theia/ai/mcp/servers/autostart/title', 'Autostart'),
                        markdownDescription: core_1.nls.localize('theia/ai/mcp/servers/autostart/mdDescription', 'Automatically start this server when the frontend starts. Newly added servers are not immediately auto started, but on restart'),
                        default: true
                    },
                    serverUrl: {
                        type: 'string',
                        title: core_1.nls.localize('theia/ai/mcp/servers/serverUrl/title', 'Server URL'),
                        markdownDescription: core_1.nls.localize('theia/ai/mcp/servers/serverUrl/mdDescription', 'The URL of the remote MCP server. If provided, the server will connect to this URL instead of starting a local process.'),
                    },
                    serverAuthToken: {
                        type: 'string',
                        title: core_1.nls.localize('theia/ai/mcp/servers/serverAuthToken/title', 'Authentication Token'),
                        markdownDescription: core_1.nls.localize('theia/ai/mcp/servers/serverAuthToken/mdDescription', 'The authentication token for the server, if required. This is used to authenticate with the remote server.'),
                    },
                    serverAuthTokenHeader: {
                        type: 'string',
                        title: core_1.nls.localize('theia/ai/mcp/servers/serverAuthTokenHeader/title', 'Authentication Header Name'),
                        markdownDescription: core_1.nls.localize('theia/ai/mcp/servers/serverAuthTokenHeader/mdDescription', 'The header name to use for the server authentication token. If not provided, "Authorization" with "Bearer" will be used.'),
                    },
                    headers: {
                        type: 'object',
                        title: core_1.nls.localize('theia/ai/mcp/servers/headers/title', 'Headers'),
                        markdownDescription: core_1.nls.localize('theia/ai/mcp/servers/headers/mdDescription', 'Optional additional headers included with each request to the server.'),
                    }
                },
                required: []
            }
        }
    }
};


/***/ },

/***/ "../../node_modules/@theia/ai-mcp/lib/common/mcp-protocol.js"
/*!*******************************************************************!*\
  !*** ../../node_modules/@theia/ai-mcp/lib/common/mcp-protocol.js ***!
  \*******************************************************************/
(__unused_webpack_module, exports) {


// *****************************************************************************
// Copyright (C) 2025 EclipseSource GmbH.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cleanServerDescription = exports.MCPServerManagerServerClient = exports.MCPServerManagerServerPath = exports.MCPServerManagerServer = void 0;
exports.MCPServerManagerServer = Symbol('MCPServerManagerServer');
exports.MCPServerManagerServerPath = '/services/mcpservermanagerserver';
exports.MCPServerManagerServerClient = Symbol('MCPServerManagerServerClient');
/**
 * Util function to convert a MCPServerDescriptionRCP to a MCPServerDescription by removing the resolveId.
 */
const cleanServerDescription = (description) => {
    const { resolveId, ...descriptionProperties } = description;
    return { ...descriptionProperties };
};
exports.cleanServerDescription = cleanServerDescription;


/***/ },

/***/ "../../node_modules/@theia/ai-mcp/lib/common/mcp-server-manager.js"
/*!*************************************************************************!*\
  !*** ../../node_modules/@theia/ai-mcp/lib/common/mcp-server-manager.js ***!
  \*************************************************************************/
(__unused_webpack_module, exports) {


// *****************************************************************************
// Copyright (C) 2024 EclipseSource GmbH.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License v. 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0.
//
// This Source Code may also be made available under the following Secondary
// Licenses when the conditions for such availability set forth in the Eclipse
// Public License v. 2.0 are satisfied: GNU General Public License, version 2
// with the GNU Classpath Exception which is available at
// https://www.gnu.org/software/classpath/license.html.
//
// SPDX-License-Identifier: EPL-2.0 OR GPL-2.0-only WITH Classpath-exception-2.0
// *****************************************************************************
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MCPServerManagerPath = exports.MCPServerManager = exports.isRemoteMCPServerDescription = exports.isLocalMCPServerDescription = exports.MCPServerStatus = exports.MCPFrontendNotificationService = exports.MCPFrontendService = void 0;
exports.MCPFrontendService = Symbol('MCPFrontendService');
exports.MCPFrontendNotificationService = Symbol('MCPFrontendNotificationService');
var MCPServerStatus;
(function (MCPServerStatus) {
    MCPServerStatus["NotRunning"] = "Not Running";
    MCPServerStatus["NotConnected"] = "Not Connected";
    MCPServerStatus["Starting"] = "Starting";
    MCPServerStatus["Connecting"] = "Connecting";
    MCPServerStatus["Running"] = "Running";
    MCPServerStatus["Connected"] = "Connected";
    MCPServerStatus["Errored"] = "Errored";
})(MCPServerStatus || (exports.MCPServerStatus = MCPServerStatus = {}));
function isLocalMCPServerDescription(description) {
    return description.command !== undefined;
}
exports.isLocalMCPServerDescription = isLocalMCPServerDescription;
function isRemoteMCPServerDescription(description) {
    return description.serverUrl !== undefined;
}
exports.isRemoteMCPServerDescription = isRemoteMCPServerDescription;
exports.MCPServerManager = Symbol('MCPServerManager');
exports.MCPServerManagerPath = '/services/mcpservermanager';


/***/ },

/***/ "../../node_modules/fast-deep-equal/index.js"
/*!***************************************************!*\
  !*** ../../node_modules/fast-deep-equal/index.js ***!
  \***************************************************/
(module) {



// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};


/***/ }

}]);
//# sourceMappingURL=vendors-node_modules_theia_ai-mcp_lib_browser_mcp-frontend-module_js-node_modules_fast-deep-e-bdc21c.js.map